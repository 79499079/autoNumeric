(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0-beta.10 - 2016-12-20 UTC 20:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by decimalCharacter\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"}\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"}\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    negativePositiveSignPlacement: 'l',\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    roundingMethod: 'S',\n\n    /* Controls decimal padding\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * negativeBracketsTypeOnBlur: null - (default)\n     * negativeBracketsTypeOnBlur: '(,)', negativeBracketsTypeOnBlur: '[,]', negativeBracketsTypeOnBlur: '<,>' or negativeBracketsTypeOnBlur: '{,}'\n     * Deprecated older option name : nBracket\n     */\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select\n     * the complete input text or only the input numeric value\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return TRUE if the text given as a parameter is valid.\n     *\n     * @param text\n     * @returns {boolean}\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param text\n     * @param holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param event\n     * @returns {string|Number}\n     */\n    function key(event) {\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param $this\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted characters and leave only a number alert\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string|*}\n     */\n    function autoStrip(s, settings, leftOrAll) {\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.onOff && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Places or removes brackets on negative values\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function negativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare number string to be converted to real number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function fixNumber(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Prepare real number to be converted to our format\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function presentNumber(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Private function that formats our number\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoGroup(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = autoStrip(inputValue, settings, false);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNegative = contains(inputValue, '-');\n        if (isNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = negativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param rDec\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (rDec === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoRound(inputValue, settings) {\n        // value to string\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            rDec = settings.decimalPlacesOverride;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < rDec) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var decimalCharacter = settings.decimalCharacter;\n        var decimalPlacesOverride = settings.decimalPlacesOverride;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n\n        if (decimalCharacter && decimalPlacesOverride) {\n            var _s$split3 = s.split(decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > decimalPlacesOverride) {\n                if (decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, decimalPlacesOverride);\n                    s = '' + integerPart + decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(obj)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            obj = '#' + obj.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param $that\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getHolder($that, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\n     * original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave(element, settings, toDo) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateFieldProperties',\n            value: function _updateFieldProperties(e) {\n                this.value = this.that.value;\n                this.ctrlKey = e.ctrlKey;\n                this.cmdKey = e.metaKey;\n                this.shiftKey = e.shiftKey;\n\n                // keypress event overwrites meaningful value of e.keyCode\n                this.selection = getElementSelection(this.that);\n                if (e.type === 'keydown' || e.type === 'keyup') {\n                    this.kdCode = e.keyCode;\n                }\n                this.which = e.which;\n            }\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length);\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n        }, {\n            key: '_setPosition',\n            value: function _setPosition(pos, setReal) {\n                this._setSelection(pos, pos, setReal);\n            }\n        }, {\n            key: '_getBeforeAfter',\n            value: function _getBeforeAfter() {\n                var value = this.value;\n                //FIXME `this.selection` can sometimes be undefined, found why and fix it\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n        }, {\n            key: '_getBeforeAfterStripped',\n            value: function _getBeforeAfterStripped() {\n                var settingsClone = this.settingsClone;\n\n                var _getBeforeAfter2 = this._getBeforeAfter(),\n                    _getBeforeAfter3 = _slicedToArray(_getBeforeAfter2, 2),\n                    left = _getBeforeAfter3[0],\n                    right = _getBeforeAfter3[1];\n\n                left = autoStrip(left, this.settingsClone, true);\n                right = autoStrip(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                }\n\n                settingsClone.trailingNegative = false;\n\n                return [left, right];\n            }\n\n            /**\n             * strip parts from excess characters and leading zeroes\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // prevents multiple leading zeros from being entered\n                left = autoStrip(left, settingsClone, true);\n                if (Number(left) === 0 && settingsClone.leadingZero === 'deny') {\n                    if (right === '' && left.indexOf('-') === -1) {\n                        left = '';\n                    }\n                    if (right !== '' && left.indexOf('-') !== -1) {\n                        left = '-';\n                    }\n                }\n\n                // if right is not empty and first character is not decimalCharacter,\n                right = autoStrip(right, settingsClone, false);\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right, advent) {\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _autoCheck = autoCheck(this.newValue, settingsClone),\n                    _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                    minTest = _autoCheck2[0],\n                    maxTest = _autoCheck2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = '';\n                    } else {\n                        settingsClone.rawValue = testValue;\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * helper function for _expandSelectionOnSign\n             * returns sign position of a formatted value\n             */\n\n        }, {\n            key: '_signPosition',\n            value: function _signPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                var signPosition = this._signPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getBeforeAfter4 = this._getBeforeAfter(),\n                        _getBeforeAfter5 = _slicedToArray(_getBeforeAfter4, 2),\n                        left = _getBeforeAfter5[0],\n                        right = _getBeforeAfter5[1];\n\n                    // try to strip pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, 'paste')) {\n                        this.value = oldParts.join('');\n                        this._setPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys\n             * If returns true, further processing is not performed\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                var kdCode = this.kdCode;\n                var which = this.which;\n                var ctrlKey = this.ctrlKey;\n                var cmdKey = this.cmdKey;\n\n                // catch the ctrl up on ctrl-v\n                var shiftKey = this.shiftKey;\n                if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                    this._checkPaste();\n                    return false;\n                }\n\n                // skip Fx keys, windows keys, other special keys\n                if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                    return true;\n                }\n\n                // if select all (a)\n                if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // preventDefault is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // if copy (c)\n                if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // try to prevent wrong paste\n                    if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getBeforeAfter();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n                }\n\n                if (ctrlKey || cmdKey) {\n                    return true;\n                }\n\n                // jump over thousand separator\n                if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                    var digitGroupSeparator = this.settingsClone.digitGroupSeparator;\n                    var decimalCharacter = this.settingsClone.decimalCharacter;\n                    var startJump = this.selection.start;\n                    var value = this.that.value;\n                    if (e.type === 'keydown' && !this.shiftKey) {\n                        if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === digitGroupSeparator || value.charAt(startJump - 2) === decimalCharacter)) {\n                            this._setPosition(startJump - 1);\n                        } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === digitGroupSeparator || value.charAt(startJump + 1) === decimalCharacter)) {\n                            this._setPosition(startJump + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * process deletion of characters when the minus sign is to the right of the numeric characters\n             */\n\n        }, {\n            key: '_processTrailing',\n            value: function _processTrailing(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.kdCode === 8) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripp = this._getBeforeAfterStripped();\n\n                    var _getBeforeAfterStripp2 = _slicedToArray(_getBeforeAfterStripp, 2);\n\n                    left = _getBeforeAfterStripp2[0];\n                    right = _getBeforeAfterStripp2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing2 = this._processTrailing([left, right]);\n\n                        var _processTrailing3 = _slicedToArray(_processTrailing2, 2);\n\n                        left = _processTrailing3[0];\n                        right = _processTrailing3[1];\n                    } else {\n                        if (this.kdCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripp3 = this._getBeforeAfterStripped();\n\n                    var _getBeforeAfterStripp4 = _slicedToArray(_getBeforeAfterStripp3, 2);\n\n                    left = _getBeforeAfterStripp4[0];\n                    right = _getBeforeAfterStripp4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if a processing is performed.\n             *\n             * @returns {boolean} //FIXME This always returns TRUE\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion() {\n                var settingsClone = this.settingsClone;\n                var cCode = String.fromCharCode(this.which);\n\n                var _getBeforeAfterStripp5 = this._getBeforeAfterStripped(),\n                    _getBeforeAfterStripp6 = _slicedToArray(_getBeforeAfterStripp5, 2),\n                    left = _getBeforeAfterStripp6[0],\n                    right = _getBeforeAfterStripp6[1];\n\n                settingsClone.throwInput = true;\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (cCode === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && cCode === settingsClone.decimalCharacterAlternative || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right, null);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((cCode === '-' || cCode === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === '-' || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right, null);\n\n                    return true;\n                }\n\n                // If try to insert digit before minus\n                if (cCode >= '0' && cCode <= '9') {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && cCode !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + cCode, right, null);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return true;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             */\n\n        }, {\n            key: '_formatQuick',\n            value: function _formatQuick(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n                var eventKeyCode = e.keyCode;\n\n                var _getBeforeAfterStripp7 = this._getBeforeAfterStripped(),\n                    _getBeforeAfterStripp8 = _slicedToArray(_getBeforeAfterStripp7, 1),\n                    left = _getBeforeAfterStripp8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (contains(subParts, '-')) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = autoGroup(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((eventKeyCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || eventKeyCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (eventKeyCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            position = this.settingsClone.currencySymbol.length + (value.charAt(0) === '-' ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                this.that.value = value;\n                this._setPosition(position);\n                this.formatted = true;\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.onOff = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(negativeBracket(e.target.value, settings));\n            }\n\n            var result = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if ((result = autoStrip(e.target.value, settings, true)) !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        var currentKeyCode = key(e); // The key being used\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (e.keyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (currentKeyCode === keyCode.Backspace || currentKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatQuick(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeypress(holder, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        // Firefox fix for Shift && insert paste event\n        if (e.shiftKey && currentKeyCode === keyCode.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        //FIXME `_processCharacterInsertion()` always returns TRUE, which means `holder.formatted = false;` at the end is NEVER called.\n        if (holder._processCharacterInsertion()) {\n            holder._formatQuick(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                // If the value has not changed, we do not allow the input event to be sent\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeyup(holder, settings, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (currentKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            autoSave(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatQuick(e);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.onOff = false;\n\n            if (settings.saveValueToSessionStorage) {\n                autoSave(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = autoStrip(value, settings, true);\n            if (value !== '') {\n                if (settings.trailingNegative) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _autoCheck3 = autoCheck(value, settings),\n                    _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                    minTest = _autoCheck4[0],\n                    maxTest = _autoCheck4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = fixNumber(value, settings);\n                    settings.rawValue = value;\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                    value = autoRound(value, settings);\n                    value = presentNumber(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = autoRound('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = autoGroup(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onPaste($this, holder, e) {\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var oldRawValue = $this.autoNumeric('get');\n        var currentValue = e.target.value || '';\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var prefix = currentValue.substring(0, selectionStart);\n        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n        var pastedText = preparePastedText(e.clipboardData.getData('text/plain'), holder);\n\n        if (isValidPasteText(pastedText)) {\n            var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n            if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                $this.autoNumeric('set', newValue);\n                // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n                triggerEvent('input', e.target);\n                //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators, the decimal character, the negative sign/brackets, and the currency sign.\n            }\n        } else {\n            e.target.selectionStart = selectionEnd;\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @returns {*}\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param $this\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param settings\n     * @param $input\n     * @param $this\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = autoSave($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && settings.negativeSignCharacter !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings, true) : autoStrip(toStrip, settings, true);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.negativePositiveSignPlacement) && options.currencySymbol !== '') {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p';\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     * @returns {{maximumValue: Array, minimumValue: Array}}\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctMDecOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n        } else if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n            settings.oDec = String(settings.decimalPlacesOverride);\n        }\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for autoStrip\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.negativeSignCharacter ? '\\\\' + settings.negativeSignCharacter : '') + '\\\\' + settings.decimalCharacter + '\\\\d].*?(\\\\d|\\\\' + settings.decimalCharacter + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + '\\\\d]\\\\D*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(\\\\d+\\\\' + settings.decimalCharacter + '\\\\d+)|(\\\\d*(?:\\\\' + settings.decimalCharacter + '\\\\d*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(\\\\d)');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            onOff: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param $this\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // The settings are generated for the first time\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    onOff: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign if needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctMDecOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('focusout', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: '€ '}).\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var strip = $this.autoNumeric('get');\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getHolder($this, settings, true);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.decimalPlacesOverride = settings.scaleDecimalPlaces ? settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                            }\n\n                            value = autoRound(value, settings);\n                            if (settings.decimalPlacesShownOnFocus === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            autoSave($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = autoGet(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    value = autoStrip(value, settings, true);\n                }\n\n                value = fixNumber(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = autoGet(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // return the decimalCharacter setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @return {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Check the validity of the `value` parameter\n        if (!isNumber(value)) {\n            throwError('A number is needed to be able to format it, [' + value + '] given.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Basic tests to check if the given value is valid\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var showWarnings = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            // isNaN(parseInt(options.digitalGroupSpacing)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', '.'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (contains(options.suffixText, '-') || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) < Number(options.decimalPlacesShownOnFocus)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] is greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value.');\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9ib2Jrbi9Eb2N1bWVudHMvR2l0SHViL2F1dG9OdW1lcmljL3NyYy9hdXRvTnVtZXJpYy5qcz81OTRhIl0sIm5hbWVzIjpbImF1dG9Gb3JtYXQiLCJhdXRvVW5Gb3JtYXQiLCJnZXREZWZhdWx0Q29uZmlnIiwidmFsaWRhdGUiLCJhcmVTZXR0aW5nc1ZhbGlkIiwiYWxsb3dlZFRhZ0xpc3QiLCJkZWZhdWx0U2V0dGluZ3MiLCJkaWdpdEdyb3VwU2VwYXJhdG9yIiwibm9TZXBhcmF0b3JPbkZvY3VzIiwiZGlnaXRhbEdyb3VwU3BhY2luZyIsImRlY2ltYWxDaGFyYWN0ZXIiLCJkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUiLCJjdXJyZW5jeVN5bWJvbCIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwibmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQiLCJzdWZmaXhUZXh0Iiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJtYXhpbXVtVmFsdWUiLCJtaW5pbXVtVmFsdWUiLCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIiwic2NhbGVEaXZpc29yIiwic2NhbGVEZWNpbWFsUGxhY2VzIiwic2NhbGVTeW1ib2wiLCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlIiwicm91bmRpbmdNZXRob2QiLCJhbGxvd0RlY2ltYWxQYWRkaW5nIiwibmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIiLCJlbXB0eUlucHV0QmVoYXZpb3IiLCJsZWFkaW5nWmVybyIsImZvcm1hdE9uUGFnZUxvYWQiLCJzZWxlY3ROdW1iZXJPbmx5IiwiZGVmYXVsdFZhbHVlT3ZlcnJpZGUiLCJ1bmZvcm1hdE9uU3VibWl0Iiwib3V0cHV0Rm9ybWF0Iiwic2hvd1dhcm5pbmdzIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJpc1ZhbGlkUGFzdGVUZXh0IiwidGV4dCIsInByZXBhcmVQYXN0ZWRUZXh0IiwiaG9sZGVyIiwiYXV0b1N0cmlwIiwic2V0dGluZ3NDbG9uZSIsInJlcGxhY2UiLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkVycm9yIiwiZGVjaW1hbFBsYWNlcyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJsZW5ndGgiLCJrZXkiLCJldmVudCIsIndoaWNoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzaG93V2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwicnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0IiwiJHRoaXMiLCJzZXR0aW5ncyIsIiQiLCJlYWNoIiwidmFsIiwiYXV0b051bWVyaWMiLCJtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoIiwiTWF0aCIsIm1heCIsImxlZnRPckFsbCIsInNraXBGaXJzdEF1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJtYXRjaCIsIm51bVJlZ0F1dG9TdHJpcCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsIm5lZ2F0aXZlU2lnbkNoYXJhY3RlciIsIm1JbnRQb3MiLCJjaGFyQXQiLCJzbGljZSIsIm1JbnROZWciLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJmcm9tTG9jYWxlIiwibGFzdEluZGV4T2YiLCJ0b0xvY2FsZSIsImxvY2FsZSIsInJlc3VsdCIsIk51bWJlciIsImZpeE51bWJlciIsInByZXNlbnROdW1iZXIiLCJjaGVja0VtcHR5IiwiaW5wdXRWYWx1ZSIsInNpZ25PbkVtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnYXRpdmUiLCJkaWdpdGFsR3JvdXAiLCJ0ZXN0Iiwic3Vic3RyaW5nIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwicm91bmRlZElucHV0VmFsdWUiLCJyRGVjIiwicmVnZXgiLCJSZWdFeHAiLCJhdXRvUm91bmQiLCJyb3VuZCIsImNlaWwiLCJmbG9vciIsIml2Um91bmRlZCIsImRQb3MiLCJpbnB1dFZhbHVlSGFzQURvdCIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJwYXN0ZSIsIm1vZGlmaWVkRGVjaW1hbFBhcnQiLCJwYXJzZVN0ciIsIm5MIiwic2VhcmNoIiwidGVzdE1pbk1heCIsInhjIiwieWMiLCJ4TmVnIiwiYXV0b0NoZWNrIiwibWluUGFyc2UiLCJtYXhQYXJzZSIsInZhbFBhcnNlIiwiYXV0b0dldCIsImdldEhvbGRlciIsIiR0aGF0IiwidXBkYXRlIiwiZGF0YSIsIkF1dG9OdW1lcmljSG9sZGVyIiwiZ2V0Iiwia2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkiLCJvRGVjIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwib1N1ZmZpeCIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJhdXRvU2F2ZSIsImVsZW1lbnQiLCJ0b0RvIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCJmb3JtYXR0ZWQiLCJjdHJsS2V5IiwiY21kS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwidHlwZSIsImtkQ29kZSIsInNldFJlYWwiLCJtaW4iLCJwb3MiLCJfc2V0U2VsZWN0aW9uIiwibGVmdCIsInJpZ2h0IiwiX2dldEJlZm9yZUFmdGVyIiwibmV3VmFsdWUiLCJhTmVnUmVnQXV0b1N0cmlwIiwiYWR2ZW50IiwicGFydHMiLCJfbm9ybWFsaXplUGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsIl9zZXRQb3NpdGlvbiIsInRyaWdnZXIiLCJjdXJyZW5jeVN5bWJvbExlbiIsImhhc05lZyIsInZhbHVlTGVuIiwic2lnblBvc2l0aW9uIiwiX3NpZ25Qb3NpdGlvbiIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsInN1YnN0ciIsIl9zZXRWYWx1ZVBhcnRzIiwiX2NoZWNrUGFzdGUiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsInN1ZmZpeFRleHRMZW4iLCJfZXhwYW5kU2VsZWN0aW9uT25TaWduIiwic3RhcnRKdW1wIiwiY2FyZXRGaXgiLCJfZ2V0QmVmb3JlQWZ0ZXJTdHJpcHBlZCIsInRocm93SW5wdXQiLCJfcHJvY2Vzc1RyYWlsaW5nIiwiY0NvZGUiLCJmcm9tQ2hhckNvZGUiLCJsZWZ0TGVuZ3RoIiwiZXZlbnRLZXlDb2RlIiwic3ViUGFydHMiLCJsZWZ0QXIiLCJzaGlmdCIsInB1c2giLCJzaWduUGFydHMiLCJlc2NhcGVDaHIiLCJlc2NhcGVkUGFydHMiLCJtaW5pUGFydHMiLCJsZWZ0UmVnIiwibmV3TGVmdCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsImluQXJyYXkiLCJ0ZXN0SW5wdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW5BbmRNb3VzZUVudGVyIiwiaXMiLCJ0YXJnZXQiLCJ2YWx1ZU9uRm9jdXMiLCJsYXN0VmFsIiwib25FbXB0eSIsIm9uS2V5ZG93biIsImN1cnJlbnRLZXlDb2RlIiwicmVhZE9ubHkiLCJwcm9jZXNzZWQiLCJ0cmlnZ2VyRXZlbnQiLCJfdXBkYXRlRmllbGRQcm9wZXJ0aWVzIiwiX3NraXBBbHdheXMiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uIiwiX2Zvcm1hdFF1aWNrIiwib25LZXlwcmVzcyIsIl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uIiwib25LZXl1cCIsInNraXAiLCJvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsIm9uUGFzdGUiLCJvbGRSYXdWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsInByZWZpeCIsInN1ZmZpeCIsInBhc3RlZFRleHQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RGF0YSIsInZhbHVlT2YiLCJvbkJsdXIiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJvbiIsIiRzZXR0aW5ncyIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJhdHRyIiwidGVzdGVkQ3VycmVudFZhbHVlIiwiSW5maW5pdHkiLCJpc051bWVyaWMiLCJ0b1N0cmlwIiwidGFnTGlzdCIsImNvcnJlY3RQTmVnT3B0aW9uIiwib3B0aW9ucyIsImNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzIiwibWF4aW11bVZhbHVlSW50ZWdlclBhcnQiLCJtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCIsImNvcnJlY3RNRGVjT3B0aW9uIiwic2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlciIsImNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zIiwiYU5lZ1JlZyIsImFsbG93ZWQiLCJ0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMiLCJjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyIsIm9sZE9wdGlvbnNDb252ZXJ0ZXIiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGVjaW1hbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwicnVuT25jZSIsIm9wdGlvbiIsImdldEluaXRpYWxTZXR0aW5ncyIsImV4dGVuZCIsInRhZ0RhdGEiLCJtZXRob2RzIiwiaW5pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJmbiIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzIiwiaXNWYWxpZCIsImVycm9yIiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInBhcmFtcyIsImV2dCIsIkV2ZW50IiwiZm9ybWF0IiwidW5Gb3JtYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTs7QUFFQTtBQUNBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjtBQUNBLElBQUlDLGlCQUFKO0FBQ0EsSUFBSUMseUJBQUo7O0FBRUE7QUFDQTs7O0FBR0EsSUFBTUMsaUJBQWlCLENBQ25CLEdBRG1CLEVBRW5CLFNBRm1CLEVBR25CLE1BSG1CLEVBSW5CLE1BSm1CLEVBS25CLE9BTG1CLEVBTW5CLElBTm1CLEVBT25CLEtBUG1CLEVBUW5CLEtBUm1CLEVBU25CLEtBVG1CLEVBVW5CLElBVm1C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aUIsVUFEQztBQUVYK2lCLGNBQVU5aUIsWUFGQztBQUdYQyxzQ0FIVztBQUlYQyxzQkFKVyxFQUlEO0FBQ1ZDLHNDQUxXLEUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBhdXRvTnVtZXJpYy5qc1xuKiBAYXV0aG9yOiBCb2IgS25vdGhlXG4qIEBjb250cmlidXRvcnM6IFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzXG4qIEB2ZXJzaW9uOiAyLjAtYmV0YS4xMCAtIDIwMTYtMTItMjAgVVRDIDIwOjAwXG4qXG4qIENyZWF0ZWQgYnkgUm9iZXJ0IEouIEtub3RoZSBvbiAyMDA5LTA4LTA5LiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbipcbiogQ29weXJpZ2h0IChjKSAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xuKlxuKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xubGV0IHZhbGlkYXRlO1xubGV0IGFyZVNldHRpbmdzVmFsaWQ7XG5cbi8vIEF1dG9OdW1lcmljIGRlZmF1bHQgc2V0dGluZ3Ncbi8qKlxuICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cbiAqL1xuY29uc3QgYWxsb3dlZFRhZ0xpc3QgPSBbXG4gICAgJ2InLFxuICAgICdjYXB0aW9uJyxcbiAgICAnY2l0ZScsXG4gICAgJ2NvZGUnLFxuICAgICdjb25zdCcsXG4gICAgJ2RkJyxcbiAgICAnZGVsJyxcbiAgICAnZGl2JyxcbiAgICAnZGZuJyxcbiAgICAnZHQnLFxuICAgICdlbScsXG4gICAgJ2gxJyxcbiAgICAnaDInLFxuICAgICdoMycsXG4gICAgJ2g0JyxcbiAgICAnaDUnLFxuICAgICdoNicsXG4gICAgJ2lucycsXG4gICAgJ2tkYicsXG4gICAgJ2xhYmVsJyxcbiAgICAnbGknLFxuICAgICdvcHRpb24nLFxuICAgICdvdXRwdXQnLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3MnLFxuICAgICdzYW1wbGUnLFxuICAgICdzcGFuJyxcbiAgICAnc3Ryb25nJyxcbiAgICAndGQnLFxuICAgICd0aCcsXG4gICAgJ3UnLFxuXTtcblxuLyoqXG4gKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXNcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAqL1xuY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXG4gICAgICogc3BhY2UgPSBcIiBcIlxuICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxuICAgICAqL1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcsJyxcblxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogblNlcFxuICAgICAqL1xuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXG5cbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRHcm91cFxuICAgICAqL1xuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcblxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFEZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsQ2hhcmFjdGVyOiAnLicsXG5cbiAgICAvKiBBbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgZGVjaW1hbENoYXJhY3RlclxuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYWx0RGVjXG4gICAgICovXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiBudWxsLFxuXG4gICAgLyogY3VycmVuY3lTeW1ib2wgPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGN1cnJlbmN5U3ltYm9sOiBcIiRcIlxuICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGN1cnJlbmN5U3ltYm9sOiAnJCAnXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyAkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2lnblxuICAgICAqL1xuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcblxuICAgIC8qIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0gcGxhY2VtZW50IG9mIGN1cnJlbmN5IHNpZ24gYXMgYSBwPXByZWZpeCBvciBzPXN1ZmZpeFxuICAgICAqIGZvciBwcmVmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwicFwiIChkZWZhdWx0KVxuICAgICAqIGZvciBzdWZmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHBTaWduXG4gICAgICovXG4gICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdwJyxcblxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW5jeVN5bWJvbCBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn1cbiAgICAgKiAxLDIzNC41Ni0gID0+IHtuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogJDEsMjM0LjU2LSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYtJCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYkLSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn1cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcE5lZ1xuICAgICAqL1xuICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiAnbCcsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIHN1ZmZpeFRleHQ6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBzdWZmaXhUZXh0OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3VmZml4XG4gICAgICovXG4gICAgc3VmZml4VGV4dDogJycsXG5cbiAgICAvKiBPdmVycmlkZSBtaW4gbWF4IGxpbWl0c1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gbWluaW11bVZhbHVlIGFuZCBpZ25vcmVzIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xuICAgICAqL1xuICAgIG92ZXJyaWRlTWluTWF4TGltaXRzOiBudWxsLFxuXG4gICAgLyogTWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWF4XG4gICAgICovXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIHZhbHVlIG11c3QgYmUgc21hbGxlciB0aGFuIG1heGltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWluXG4gICAgICovXG4gICAgbWluaW11bVZhbHVlOiAnLTk5OTk5OTk5OTk5OTkuOTknLCAvLyAtOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcblxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcblxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IG51bGwsXG5cbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlXCIgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxuICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAqL1xuXG4gICAgLyogVGhlIGBzY2FsZURpdmlzb3JgIGRlY2lkZXMgdGhlIG9uIGZvY3VzIHZhbHVlIGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgb24gZm9jdXNvdXRcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAqIFRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlICdoaWRkZW4nIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgOyBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyB0aGUgZm9jdXMuXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNjYWxlRGVjaW1hbFxuICAgICAqL1xuICAgIHNjYWxlRGVjaW1hbFBsYWNlczogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbDogbnVsbCxcblxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3RvclxuICAgICAqL1xuICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2U6IGZhbHNlLFxuXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtUm91bmRcbiAgICAgKi9cbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxuXG4gICAgLyogQ29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICogTm90ZTogc2V0dGluZyBhbGxvd0RlY2ltYWxQYWRkaW5nIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFQYWRcbiAgICAgKi9cbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICogbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI6ICcoLCknLCBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ1ssXScsIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiAnPCw+JyBvciBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ3ssfSdcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbkJyYWNrZXRcbiAgICAgKi9cbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogbnVsbCxcblxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogd0VtcHR5XG4gICAgICovXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yOiAnZm9jdXMnLFxuXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICogbGVhZGluZ1plcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogbGVhZGluZ1plcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbFplcm9cbiAgICAgKi9cbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhRm9ybVxuICAgICAqL1xuICAgIGZvcm1hdE9uUGFnZUxvYWQ6IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxuICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgKiBpZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzTnVtYmVyXG4gICAgICovXG4gICAgc2VsZWN0TnVtYmVyT25seTogZmFsc2UsXG5cbiAgICAvKiBIZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGV4YW1wbGVzOlxuICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IFwiXCJ9XG4gICAgICogdmFsdWU9MTIzNC41NiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6ICcxMjM0LjU2J31cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYW5EZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IG51bGwsXG5cbiAgICAvKiBSZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdW5TZXRPblN1Ym1pdFxuICAgICAqL1xuICAgIHVuZm9ybWF0T25TdWJtaXQ6IGZhbHNlLFxuXG4gICAgLyogQWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcbiAgICAgKiBudWxsIG9yICdzdHJpbmcnID0+ICdubm5uLm5uJyBvciAnLW5ubm4ubm4nIGFzIHRleHQgdHlwZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKiAnbnVtYmVyJyAgICAgICAgID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gYXMgYSBOdW1iZXIgKFdhcm5pbmc6IHRoaXMgd29ya3Mgb25seSBmb3IgaW50ZWdlcnMgaW5mZXJpb3IgdG8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICogJywnIG9yICctLCcgICAgICA9PiAnbm5ubixubicgb3IgJy1ubm5uLG5uJ1xuICAgICAqICcuLScgICAgICAgICAgICAgPT4gJ25ubm4ubm4nIG9yICdubm5uLm5uLSdcbiAgICAgKiAnLC0nICAgICAgICAgICAgID0+ICdubm5uLG5uJyBvciAnbm5ubixubi0nXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG91dHB1dFR5cGVcbiAgICAgKi9cbiAgICBvdXRwdXRGb3JtYXQ6IG51bGwsXG5cbiAgICAvKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAqIHRydWUgPT4gYWxsIHdhcm5pbmcgYXJlIHNob3duXG4gICAgICogZmFsc2UgPT4gbm8gd2FybmluZ3MgYXJlIHNob3duLCBvbmx5IHRoZSB0aG93biBlcnJvcnNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZGVidWdcbiAgICAgKi9cbiAgICBzaG93V2FybmluZ3M6IHRydWUsXG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICovXG5jb25zdCBrZXlDb2RlID0ge1xuICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgIFRhYjogICAgICAgICAgICA5LFxuICAgIEVudGVyOiAgICAgICAgICAxMyxcbiAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgQ3RybDogICAgICAgICAgIDE3LFxuICAgIEFsdDogICAgICAgICAgICAxOCxcbiAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgQ2Fwc0xvY2s6ICAgICAgIDIwLFxuICAgIEVzYzogICAgICAgICAgICAyNyxcbiAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgUGFnZVVwOiAgICAgICAgIDMzLFxuICAgIFBhZ2VEb3duOiAgICAgICAzNCxcbiAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgSG9tZTogICAgICAgICAgIDM2LFxuICAgIExlZnRBcnJvdzogICAgICAzNyxcbiAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgUmlnaHRBcnJvdzogICAgIDM5LFxuICAgIERvd25BcnJvdzogICAgICA0MCxcbiAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgRGVsZXRlOiAgICAgICAgIDQ2LFxuICAgIG51bTA6ICAgICAgICAgICA0OCxcbiAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgbnVtMjogICAgICAgICAgIDUwLFxuICAgIG51bTM6ICAgICAgICAgICA1MSxcbiAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgbnVtNTogICAgICAgICAgIDUzLFxuICAgIG51bTY6ICAgICAgICAgICA1NCxcbiAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgbnVtODogICAgICAgICAgIDU2LFxuICAgIG51bTk6ICAgICAgICAgICA1NyxcbiAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgYjogICAgICAgICAgICAgIDY2LFxuICAgIGM6ICAgICAgICAgICAgICA2NyxcbiAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgZTogICAgICAgICAgICAgIDY5LFxuICAgIGY6ICAgICAgICAgICAgICA3MCxcbiAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgaDogICAgICAgICAgICAgIDcyLFxuICAgIGk6ICAgICAgICAgICAgICA3MyxcbiAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgazogICAgICAgICAgICAgIDc1LFxuICAgIGw6ICAgICAgICAgICAgICA3NixcbiAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgbjogICAgICAgICAgICAgIDc4LFxuICAgIG86ICAgICAgICAgICAgICA3OSxcbiAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgcTogICAgICAgICAgICAgIDgxLFxuICAgIHI6ICAgICAgICAgICAgICA4MixcbiAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgdDogICAgICAgICAgICAgIDg0LFxuICAgIHU6ICAgICAgICAgICAgICA4NSxcbiAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgdzogICAgICAgICAgICAgIDg3LFxuICAgIHg6ICAgICAgICAgICAgICA4OCxcbiAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgejogICAgICAgICAgICAgIDkwLFxuICAgIFdpbmRvd3M6ICAgICAgICA5MSxcbiAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgbnVtcGFkMDogICAgICAgIDk2LFxuICAgIG51bXBhZDE6ICAgICAgICA5NyxcbiAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgbnVtcGFkMzogICAgICAgIDk5LFxuICAgIG51bXBhZDQ6ICAgICAgICAxMDAsXG4gICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICBudW1wYWQ2OiAgICAgICAgMTAyLFxuICAgIG51bXBhZDc6ICAgICAgICAxMDMsXG4gICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICBudW1wYWQ5OiAgICAgICAgMTA1LFxuICAgIE11bHRpcGx5TnVtcGFkOiAxMDYsXG4gICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICBNaW51c051bXBhZDogICAgMTA5LFxuICAgIERvdE51bXBhZDogICAgICAxMTAsXG4gICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICBGMTogICAgICAgICAgICAgMTEyLFxuICAgIEYyOiAgICAgICAgICAgICAxMTMsXG4gICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICBGNDogICAgICAgICAgICAgMTE1LFxuICAgIEY1OiAgICAgICAgICAgICAxMTYsXG4gICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICBGNzogICAgICAgICAgICAgMTE4LFxuICAgIEY4OiAgICAgICAgICAgICAxMTksXG4gICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICBGMTA6ICAgICAgICAgICAgMTIxLFxuICAgIEYxMTogICAgICAgICAgICAxMjIsXG4gICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICBOdW1Mb2NrOiAgICAgICAgMTQ0LFxuICAgIFNjcm9sbExvY2s6ICAgICAxNDUsXG4gICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICBNeUNhbGN1bGF0b3I6ICAgMTgzLFxuICAgIFNlbWljb2xvbjogICAgICAxODYsXG4gICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICBDb21tYTogICAgICAgICAgMTg4LFxuICAgIEh5cGhlbjogICAgICAgICAxODksXG4gICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICBTbGFzaDogICAgICAgICAgMTkxLFxuICAgIEJhY2txdW90ZTogICAgICAxOTIsXG4gICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICBCYWNrc2xhc2g6ICAgICAgMjIwLFxuICAgIFJpZ2h0QnJhY2tldDogICAyMjEsXG4gICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICBDb21tYW5kOiAgICAgICAgMjI0LFxufTtcblxuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xufSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xufVxufSgkID0+IHtcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIG51bGwgb3IgZW1wdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFueSBjYXNlcyBmb3IgdGhvc2Ugc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1RydWVPckZhbHNlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG93ZXJjYXNlVmFsdWUgPT09ICd0cnVlJyB8fCBsb3dlcmNhc2VWYWx1ZSA9PT0gJ2ZhbHNlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdChyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZlcmVuY2UgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QgYW5kIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5LW9iamVjdC10ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIChvciBhIG51bWJlciB3cml0dGVuIGFzIGEgc3RyaW5nKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc0FycmF5KG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgKGFuZCBub3QgYSBmbG9hdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludChuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgcGFyc2VGbG9hdChuKSA9PT0gcGFyc2VJbnQobiwgMTApICYmICFpc05hTihuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgdGV4dCBnaXZlbiBhcyBhIHBhcmFtZXRlciBpcyB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZFBhc3RlVGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHBhcmFtIGhvbGRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF1dG9TdHJpcCh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSwgdHJ1ZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIC8vIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xuICAgIC8vICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAvLyAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXkoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhyb3cgZXJyb3IgbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3dXYXJuaW5nIElmIEZBTFNFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSwgc2hvd1dhcm5pbmcgPSB0cnVlKSB7XG4gICAgICAgIGlmIChzaG93V2FybmluZykge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXV0b051bWVyaWMtc3BlY2lmaWMgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSdW4gYW55IGNhbGxiYWNrcyBmb3VuZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqIEFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbWF4aW11bSBkZWNpbWFsIGxlbmd0aCBmcm9tIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgobWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRlY2ltYWxQbGFjZXMobWluaW11bVZhbHVlKSwgZGVjaW1hbFBsYWNlcyhtYXhpbXVtVmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBhbGwgdW53YW50ZWQgY2hhcmFjdGVycyBhbmQgbGVhdmUgb25seSBhIG51bWJlciBhbGVydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1N0cmlwKHMsIHNldHRpbmdzLCBsZWZ0T3JBbGwpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLnN1ZmZpeFRleHQpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJiBjb250YWlucyhzLCAnLScpICYmIHMgIT09ICcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XG5cbiAgICAgICAgLy8gVGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RpbmcgY2hhcmFjdGVyc1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGxlZnRPckFsbCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB8fFxuICAgICAgICAgICAgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICgoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3AnKSkge1xuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGxvY2FsZSBmb3JtYXQgdG8gSmF2YXNjcmlwdCBudW1lcmljIHN0cmluZ1xuICAgICAqIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBwZXJpb2Qgb3IgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZCBvZiBjdXJyZW5jeSBzaWducyBhbGxvd2VkXG4gICAgICogJzEyMzQuNTYnICAgIE9LXG4gICAgICogJy0xMjM0LjU2JyAgIE9LXG4gICAgICogJzEyMzQuNTYtJyAgIE9LXG4gICAgICogJzEyMzQsNTYnICAgIE9LXG4gICAgICogJy0xMjM0LDU2JyAgIE9LXG4gICAgICogJzEyMzQsNTYtJyAgIE9LXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUxvY2FsZShzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBpZiAoY29udGFpbnMocywgJy0nKSAmJiBzLmxhc3RJbmRleE9mKCctJykgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgIHMgPSAnLScgKyBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50LlxuICAgICAqIFNlZSB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGlzTnVsbChsb2NhbGUpIHx8IGxvY2FsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAobG9jYWxlKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcuLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGNhc2UgJy0sJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywtJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyhyZXN1bHQsICctJykgPyByZXN1bHQucmVwbGFjZSgnLScsICcnKSArICctJyA6IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNhc2VcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgY2FzZSAnLS4nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGdpdmVuIG91dHB1dEZvcm1hdCBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZml4TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcbiAgICAgICAgICAgIHMgKz0gJzAuMDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSByZWFsIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gb3VyIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3Muc3VmZml4VGV4dCA6IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR3JvdXAoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gYXV0b1N0cmlwKGlucHV0VmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICctJyArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBpc05lZ2F0aXZlID0gY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChlbXB0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcgPSBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXA7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZykge1xuICAgICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzJzJzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzQnOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaW5wdXRWYWx1ZS5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyBSZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgKyBkZWNpbWFsUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBpdCdzIGFuIGludGVnZXJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gbmVnYXRpdmVCcmFja2V0KGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3VuZGVkSW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSByRGVjXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHJEZWMpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHJEZWMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBsZW5ndGggd2hlbiBhbGxvd0RlY2ltYWxQYWRkaW5nIGlzIHNldCB0byB0cnVlXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske3JEZWN9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAockRlYyA9PT0gMCkge1xuICAgICAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdW5kIG51bWJlciBhZnRlciBzZXR0aW5nIGJ5IHBhc3Rpbmcgb3IgJCgpLmF1dG9OdW1lcmljU2V0KClcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIGZvciByb3VuZCB0aGUgbnVtYmVyXG4gICAgICogcGxlYXNlIG5vdGUgdGhpcyBoYW5kbGVkIGFzIHRleHQgLSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlc1xuICAgICAqIGFsc28gdGhpcyBvZmZlcnMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcyB0aGF0IGFyZSBub3QgZWFzaWx5IGFjY29tcGxpc2hlZCBpbiBKYXZhU2NyaXB0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Sb3VuZChpbnB1dFZhbHVlLCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcbiAgICAgICAgaW5wdXRWYWx1ZSA9IChpbnB1dFZhbHVlID09PSAnJykgPyAnMCcgOiBpbnB1dFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ04wNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdDSEYnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0QwNScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGgucm91bmQoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguY2VpbChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguZmxvb3IoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpbnB1dFZhbHVlLCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcuMDAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFZhbHVlLmxlbmd0aCAtIGlucHV0VmFsdWUuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICBsZXQgckRlYztcblxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZykge1xuICAgICAgICAgICAgckRlYyA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJEZWMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpbnB1dFZhbHVlIChpbnB1dCBWYWx1ZSkgaXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBpZiAoaW5wdXRWYWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgblNpZ24gPSAnLSc7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgYSB6ZXJvIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90KVxuICAgICAgICBpZiAoIWlucHV0VmFsdWUubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICcwJyArIGlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBlcXVhbCB0byB6ZXJvLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIE51bWJlcihpbnB1dFZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpbnB1dFZhbHVlKSA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykgfHwgKGlucHV0VmFsdWUubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkUG9zID0gaW5wdXRWYWx1ZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlSGFzQURvdCA9IGRQb3MgPT09IC0xO1xuXG4gICAgICAgIC8vIFZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxuICAgICAgICBjb25zdCB2ZFBvcyA9IGlucHV0VmFsdWVIYXNBRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZFBvcztcblxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcbiAgICAgICAgbGV0IGNEZWMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIHZkUG9zO1xuXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgemVyb3MgPSAnMDAwMDAwJztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHJEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgckRlYyAtIGNEZWMpO1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHJEZWMpIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPT09IDAgJiYgckRlYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBsZXQgckxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKyBkUG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggKyAxKSk7XG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xuICAgICAgICBsZXQgaXZBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnUycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRicgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgdG8gZmxvb3IgdG93YXJkIG5lZ2F0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdkFycmF5LmpvaW4oJycpLCByRGVjKTtcblxuICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXN0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlRGVjaW1hbChzLCBzZXR0aW5ncywgcGFzdGUpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbENoYXJhY3RlciA9IHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXI7XG4gICAgICAgIGNvbnN0IGRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcblxuICAgICAgICBpZiAoZGVjaW1hbENoYXJhY3RlciAmJiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChkZWNpbWFsQ2hhcmFjdGVyKTtcblxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgZGVjaW1hbCBwYXJ0IHRvIHNhdGlzZnlpbmcgbGVuZ3RoIHNpbmNlIHdlIHdvdWxkIHJvdW5kIGl0IGFueXdheVxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0ICYmIGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IGRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGAke2ludGVnZXJQYXJ0fSR7ZGVjaW1hbENoYXJhY3Rlcn0ke21vZGlmaWVkRGVjaW1hbFBhcnR9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gcGFyc2UgbWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUgJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiBtaW5pbXVtVmFsdWU6IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAgICAgKiBNYW55IHRoYW5rcyB0byBNaWtlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTdHIobikge1xuICAgICAgICBjb25zdCB4ID0ge307XG4gICAgICAgIGxldCBlO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IG5MO1xuICAgICAgICBsZXQgajtcblxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xuICAgICAgICBpZiAobiA9PT0gMCAmJiAxIC8gbiA8IDApIHtcbiAgICAgICAgICAgIG4gPSAnLTAnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uIDEgcG9zaXRpdmUsIC0xIG5lZ2F0aXZlXG4gICAgICAgIG4gPSBuLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuID0gbi5zbGljZSgxKTtcbiAgICAgICAgICAgIHgucyA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeC5zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XG4gICAgICAgIGUgPSBuLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGUgPiAtMSkge1xuICAgICAgICAgICAgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxlbmd0aCBvZiBzdHJpbmcgaWYgbm8gZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKGUgPCAwKSB7XG4gICAgICAgICAgICAvLyBJbnRlZ2VyXG4gICAgICAgICAgICBlID0gbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvc1xuICAgICAgICBpID0gKG4uc2VhcmNoKC9bMS05XS9pKSA9PT0gLTEpID8gbi5sZW5ndGggOiBuLnNlYXJjaCgvWzEtOV0vaSk7XG4gICAgICAgIG5MID0gbi5sZW5ndGg7XG4gICAgICAgIGlmIChpID09PSBuTCkge1xuICAgICAgICAgICAgLy8gWmVyb1xuICAgICAgICAgICAgeC5lID0gMDtcbiAgICAgICAgICAgIHguYyA9IFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChqID0gbkwgLSAxOyBuLmNoYXJBdChqKSA9PT0gJzAnOyBqIC09IDEpIHtcbiAgICAgICAgICAgICAgICBuTCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbkwgLT0gMTtcblxuICAgICAgICAgICAgLy8gRGVjaW1hbCBsb2NhdGlvblxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xuICAgICAgICAgICAgeC5jID0gW107XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGkgPD0gbkw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHguY1tlXSA9ICtuLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byB0ZXN0IGlmIHRoZSBpbnB1dCB2YWx1ZSBmYWxscyB3aXRoIHRoZSBNaW4gLyBNYXggc2V0dGluZ3NcbiAgICAgKiBUaGlzIHVzZXMgdGhlIHBhcnNlZCBzdHJpbmdzIGZvciB0aGUgYWJvdmUgcGFyc2VTdHIgZnVuY3Rpb25cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZXN0TWluTWF4KHksIHgpIHtcbiAgICAgICAgY29uc3QgeGMgPSB4LmM7XG4gICAgICAgIGNvbnN0IHljID0geS5jO1xuICAgICAgICBsZXQgaSA9IHgucztcbiAgICAgICAgbGV0IGogPSB5LnM7XG4gICAgICAgIGxldCBrID0geC5lO1xuICAgICAgICBsZXQgbCA9IHkuZTtcblxuICAgICAgICAvLyBFaXRoZXIgemVybz9cbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIXhjWzBdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXljWzBdPzA6LWo7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeE5lZyA9IGkgPCAwO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzXG4gICAgICAgIGlmIChrICE9PSBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuICAgICAgICBpID0gLTE7XG4gICAgICAgIGsgPSB4Yy5sZW5ndGg7XG4gICAgICAgIGwgPSB5Yy5sZW5ndGg7XG4gICAgICAgIGogPSAoayA8IGwpID8gayA6IGw7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdFxuICAgICAgICBmb3IgKGkgKz0gMTsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHhjW2ldICE9PSB5Y1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeGNbaV0gPiB5Y1tpXSBeIHhOZWcpPzE6LTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHNcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGsgPT09IGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBudW1iZXIgc2F0aXNmeSB0aGUgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbFBhcnNlID0gcGFyc2VTdHIocyk7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5vdmVycmlkZU1pbk1heExpbWl0cykge1xuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhhbmtzIHRvIEFudGhvbnkgJiBFdmFuIENcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR2V0KG9iaikge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIChhbmQgdGhlcmVmb3JlIGlzIGEgQ1NTIHNlbGVjdG9yKSwgdGhlbiB3ZSBuZWVkIHRvIG1vZGlmeSB0aGlzIHN0cmluZyBpbiBvcmRlclxuICAgICAgICAgKiBmb3IgalF1ZXJ5IHRvIGJlIGFibGUgdG8gcGFyc2UgdGhlIHNlbGVjdG9yIGNvcnJlY3RseS5cbiAgICAgICAgICogY2YuIGh0dHA6Ly9sZWFybi5qcXVlcnkuY29tL3VzaW5nLWpxdWVyeS1jb3JlL2ZhcS9ob3ctZG8taS1zZWxlY3QtYW4tZWxlbWVudC1ieS1hbi1pZC10aGF0LWhhcy1jaGFyYWN0ZXJzLXVzZWQtaW4tY3NzLW5vdGF0aW9uL1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzU3RyaW5nKG9iaikpIHtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGJsb2NrIGlzIGFwcGFyZW50bHkgbmV2ZXIgZW50ZXJlZC4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBhZnRlciBtYWtpbmcgc3VyZSB0aGF0J3MgMTAwJSB0aGUgY2FzZVxuICAgICAgICAgICAgb2JqID0gYCMke29iai5yZXBsYWNlKC8oOnxcXC58XFxbfF18LHw9KS9nLCAnXFxcXCQxJyl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkKG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhdHRhY2ggdGhlIGF1dG9OdW1lcmljIGZpZWxkIHByb3BlcnRpZXMgdG8gdGhlIERPTSBlbGVtZW50IHZpYSBhbiBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoYXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xuICAgICAgICBpZiAodXBkYXRlIHx8IChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGF0LmdldCgwKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhvc2Ugb3JpZ2luYWwgc2V0dGluZ3MgYXJlIHVzZWQgZXhjbHVzaXZlbHkgaW4gdGhlIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmc7XG4gICAgICAgIHNldHRpbmdzLm9CcmFja2V0ID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI7XG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcjtcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgc2V0dGluZ3Mub1N1ZmZpeCAgPSBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkIC0gdGFrZW4gZnJvbSBtb2Rlcm5penJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU2F2ZShlbGVtZW50LCBzZXR0aW5ncywgdG9Ebykge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9IChlbGVtZW50Lm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZChlbGVtZW50Lm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoZWxlbWVudC5uYW1lKX1gIDpgQVVUT18ke2VsZW1lbnQuaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIHNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKC0xICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgY2xhc3MgQXV0b051bWVyaWNIb2xkZXIge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xhc3MgY29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGhhdCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IERPTSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzQ2xvbmUgPSBzZXR0aW5ncztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3VwZGF0ZUZpZWxkUHJvcGVydGllcyhlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgICAgICAgICAgdGhpcy5jbWRLZXkgPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcblxuICAgICAgICAgICAgLy8ga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndoaWNoID0gZS53aGljaDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCwgc2V0UmVhbCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heChzdGFydCwgMCk7XG4gICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIHRoaXMudGhhdC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZW5kIC0gc3RhcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0UG9zaXRpb24ocG9zLCBzZXRSZWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dldEJlZm9yZUFmdGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgLy9GSVhNRSBgdGhpcy5zZWxlY3Rpb25gIGNhbiBzb21ldGltZXMgYmUgdW5kZWZpbmVkLCBmb3VuZCB3aHkgYW5kIGZpeCBpdFxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIHRydWUpO1xuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHRoaXMuc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSAocmlnaHQgPT09ICctJykgPyAnJyA6IHJpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIF9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgc2V0dGluZ3NDbG9uZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyKGxlZnQpID09PSAwICYmIHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA9PT0gJycgJiYgbGVmdC5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ICE9PSAnJyAmJiBsZWZ0LmluZGV4T2YoJy0nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9ICctJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBkZWNpbWFsQ2hhcmFjdGVyLFxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHNldHRpbmdzQ2xvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJ9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcGFydCBvZiBudW1iZXIgdG8gdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgYWR2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0c1swXS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gcGFydHMuam9pbignJyk7XG5cbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gdHJ1bmNhdGVEZWNpbWFsKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUsIGFkdmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm5ld1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMubmV3VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3aGVuIHRoZSB1c2VyIGVudGVyIGEgJzAnIG9uIHRoZSBmYXIgbGVmdCB3aXRoIGEgbGVhZGluZyB6ZXJvIG9wdGlvbiBzZXQgdG8gJ2RlbnknLCB0aGF0IHRoZSBjYXJldCBkb2VzIG5vdCBtb3ZlcyBzaW5jZSB0aGUgaW5wdXQgaXMgZHJvcHBlZCAoZml4IGlzc3VlICMyODMpXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAxICYmIHBhcnRzWzBdID09PSAnMCcgJiYgc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGVudGVyIGAwYCwgdGhlbiB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSByaWdodCBzaWRlIG9mIGl0IChGaXggaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciBfZXhwYW5kU2VsZWN0aW9uT25TaWduXG4gICAgICAgICAqIHJldHVybnMgc2lnbiBwb3NpdGlvbiBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbCA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xuXG4gICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IGN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc05lZyA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGN1cnJlbmN5U3ltYm9sTGVuICsgMV0gOiBbMCwgY3VycmVuY3lTeW1ib2xMZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBjdXJyZW5jeVN5bWJvbExlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmRzIHNlbGVjdGlvbiB0byBjb3ZlciB3aG9sZSBzaWduXG4gICAgICAgICAqIFByZXZlbnRzIHBhcnRpYWwgZGVsZXRpb24vY29weWluZy9vdmVyd3JpdGluZyBvZiBhIHNpZ25cbiAgICAgICAgICovXG4gICAgICAgIF9leHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5fc2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgX2NoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIGZpcnN0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0LnN1YnN0cigwLCBvbGRQYXJ0c1swXS5sZW5ndGgpICsgYXV0b1N0cmlwKGxlZnQuc3Vic3RyKG9sZFBhcnRzWzBdLmxlbmd0aCksIHRoaXMuc2V0dGluZ3NDbG9uZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIElmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIF9za2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2ggPSB0aGlzLndoaWNoO1xuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xuXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcbiAgICAgICAgICAgIGlmICgoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKHNoaWZ0S2V5ICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBGeCBrZXlzLCB3aW5kb3dzIGtleXMsIG90aGVyIHNwZWNpYWwga2V5c1xuICAgICAgICAgICAgaWYgKChrZENvZGUgPj0ga2V5Q29kZS5GMSAmJiBrZENvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLldpbmRvd3MgJiYga2RDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuVGFiICYmIGtkQ29kZSA8IGtleUNvZGUuU3BhY2UpIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXG4gICAgICAgICAgICAgICAgKHdoaWNoID09PSAwIHx8IHdoaWNoID09PSBrZENvZGUpKSB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5OdW1Mb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLlNjcm9sbExvY2sgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGFsbCAoYSlcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VsZWN0TnVtYmVyT25seSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBpcyB1c2VkIGhlcmUgdG8gcHJldmVudCB0aGUgYnJvd3NlciB0byBmaXJzdCBzZWxlY3QgYWxsIHRoZSBpbnB1dCB0ZXh0IChpbmNsdWRpbmcgdGhlIGN1cnJlbmN5IHNpZ24pLCBvdGhlcndpc2Ugd2Ugd291bGQgc2VlIHRoYXQgd2hvbGUgc2VsZWN0aW9uIGZpcnN0IGluIGEgZmxhc2gsIHRoZW4gdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIG51bWJlciBwYXJ0IHdpdGhvdXQgdGhlIGN1cnJlbmN5IHNpZ24uXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWNvbnRhaW5zKHRoaXMudGhhdC52YWx1ZSwgJy0nKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXhUZXh0TGVuID0gdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgY3VycmVuY3lTeW1ib2xMZW4gPiAwKT9jdXJyZW5jeVN5bWJvbExlbiArIDE6Y3VycmVuY3lTeW1ib2xMZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBzdWZmaXhUZXh0TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChzdWZmaXhUZXh0TGVuICsgY3VycmVuY3lTeW1ib2xMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKGN1cnJlbmN5U3ltYm9sTGVuID4gMCk/dmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBuZWdMZW4gKyBzdWZmaXhUZXh0TGVuKTp2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBzdWZmaXhUZXh0TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY29weSAoYylcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIChrZENvZGUgPT09IGtleUNvZGUuYyB8fCBrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHByZXZlbnQgd3JvbmcgcGFzdGVcbiAgICAgICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLnYgfHwga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUgPSB0aGlzLl9nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCBrZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN0cmxLZXkgfHwgY21kS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXRHcm91cFNlcGFyYXRvciA9IHRoaXMuc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxDaGFyYWN0ZXIgPSB0aGlzLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gZGlnaXRHcm91cFNlcGFyYXRvciB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBkaWdpdEdyb3VwU2VwYXJhdG9yIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgKyAxKSA9PT0gZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHN0YXJ0SnVtcCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ga2RDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYga2RDb2RlIDw9IGtleUNvZGUuRG93bkFycm93O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBfcHJvY2Vzc1RyYWlsaW5nKFtsZWZ0LCByaWdodF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkgKyBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiAoKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAtIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJycgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyB0aGUgZGVsZXRpb24gb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgICAgIGxldCByaWdodDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0QmVmb3JlQWZ0ZXJTdHJpcHBlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCgoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykgfHxcbiAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHRoaXMudmFsdWUsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX3Byb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBkZWNpZGVzIGlmIHRoZSBrZXkgcHJlc3NlZCBzaG91bGQgYmUgZHJvcHBlZCBvciBhY2NlcHRlZCwgYW5kIG1vZGlmeSB0aGUgdmFsdWUgJ29uLXRoZS1mbHknIGFjY29yZGluZ2x5LlxuICAgICAgICAgKiBSZXR1cm5zIFRSVUUgaWYgYSBwcm9jZXNzaW5nIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IC8vRklYTUUgVGhpcyBhbHdheXMgcmV0dXJucyBUUlVFXG4gICAgICAgICAqL1xuICAgICAgICBfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBjQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy53aGljaCk7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKChjQ29kZSA9PT0gJy4nIHx8IGNDb2RlID09PSAnLCcpICYmIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRvdE51bXBhZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUuZGVjaW1hbFBsYWNlc092ZXJyaWRlIHx8ICFzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciwgcmlnaHQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGlmICgoY0NvZGUgPT09ICctJyB8fCBjQ29kZSA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG51bWJlciBzaWduLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRyeSB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzXG4gICAgICAgICAgICBpZiAoY0NvZGUgPj0gJzAnICYmIGNDb2RlIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5tYXhpbXVtVmFsdWUgPD0gMCAmJiBzZXR0aW5nc0Nsb25lLm1pbmltdW1WYWx1ZSA8IHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIGNDb2RlLCByaWdodCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgb3RoZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aGlsZSBrZWVwaW5nIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIF9mb3JtYXRRdWljayhlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBldmVudEtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5fZ2V0QmVmb3JlQWZ0ZXJTdHJpcHBlZCgpO1xuXG4gICAgICAgICAgICAvLyBObyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IpKSkgJiZcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHN1YlBhcnRzLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXV0b0dyb3VwKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKGV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnblBhcnRzID0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2lnblBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCdcXFxcJyArIG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUganVzdCBiZWZvcmUgdGhlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAodmFsdWUuY2hhckF0KDApID09PSAnLScgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBmYWN0b3Jpc2UgdGhlIGBnZXRTdHJpbmcoKWAgYW5kIGBnZXRBcnJheSgpYCBmdW5jdGlvbnMgc2luY2UgdGhleSBzaGFyZSBxdWl0ZSBhIGxvdCBvZiBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2V0QXJyYXlCZWhhdmlvciAtIElmIHNldCB0byBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gYmVoYXZlIGxpa2UgYGdldEFycmF5KClgLCBvdGhlcndpc2UgaWYgc2V0IHRvIEZBTFNFLCBpdCBiZWhhdmUgbGlrZSBgZ2V0U3RyaW5nKClgXG4gICAgICogQHBhcmFtIHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoYXQpO1xuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRTdHJpbmcoKSBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybVBhcnRzLCBpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRJbnB1dFZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IGAke2lucHV0TmFtZX09JHttb2RpZmllZElucHV0VmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybVBhcnRzLmpvaW4oJyYnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c2luJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwobmVnYXRpdmVCcmFja2V0KGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gJyc7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBhdXRvU3RyaXAoZS50YXJnZXQudmFsdWUsIHNldHRpbmdzLCB0cnVlKSkgIT09IHNldHRpbmdzLnJhd1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHNlbmQgYSAnbmF0aXZlJyBjaGFuZ2UgZXZlbnQgd2hlbiBibHVycmluZyB0aGUgaW5wdXQsIHdlIG5lZWQgdG8gZmlyc3Qgc3RvcmUgdGhlIGluaXRpYWwgaW5wdXQgdmFsdWUgb24gZm9jdXMuXG4gICAgICAgICAgICBob2xkZXIudmFsdWVPbkZvY3VzID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci52YWx1ZU9uRm9jdXM7XG4gICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIudmFsdWVPbkZvY3VzLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoKG9uRW1wdHkgIT09IG51bGwgJiYgb25FbXB0eSAhPT0gJycpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICBpZiAob25FbXB0eSA9PT0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgJiYgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gY2hhbmdlXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxuICAgICAqXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bihob2xkZXIsIGUpIHtcbiAgICAgICAgLy9UT0RPIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmUgdGhlIGVsZW1lbnQgdmFsdWUgKGVpdGhlciBieSB1c2luZyBgZS50YXJnZXQudmFsdWVgIHdoZW4gdGhlIGVsZW1lbnQgaXMgYW4gPGlucHV0Piwgb3IgYnkgdXNpbmcgYGVsZW1lbnQudGV4dENvbnRlbnRgIHdoZW4gdGhlIGVsZW1lbnQgYXMgaXRzIGBjb250ZW50ZWRpdGFibGVgIHNldCB0byB0cnVlKVxuICAgICAgICBjb25zdCBjdXJyZW50S2V5Q29kZSA9IGtleShlKTsgLy8gVGhlIGtleSBiZWluZyB1c2VkXG5cbiAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLnZhbHVlT25Gb2N1cyAhPT0gZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9sZGVyLl91cGRhdGVGaWVsZFByb3BlcnRpZXMoZSk7IC8vRklYTUUgVGhpcyBpcyBjYWxsZWQgMiB0byAzIHRpbWVzXG4gICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGlzIGEgZGVsZXRlL2JhY2tzcGFjZSBrZXlcbiAgICAgICAgaWYgKGN1cnJlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBjdXJyZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcbiAgICAgICAgICAgIGhvbGRlci5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFF1aWNrKGUpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmQgb25seSBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGhhcyBjaGFuZ2VkIGFmdGVyIHRoYXQgYmFja3NwYWNlL2RlbGV0ZSwgdGhlbiB3ZSBoYXZlIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCBsaWtlIGJyb3dzZXJzIG5vcm1hbGx5IGRvLlxuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7IC8vVE9ETyBJcyB0aGlzIGxpbmUgbmVlZGVkP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXByZXNzKGhvbGRlciwgZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50S2V5Q29kZSA9IGtleShlKTsgLy8gVGhlIGtleSBiZWluZyB1c2VkXG5cbiAgICAgICAgLy8gRmlyZWZveCBmaXggZm9yIFNoaWZ0ICYmIGluc2VydCBwYXN0ZSBldmVudFxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBjdXJyZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XG4gICAgICAgIGhvbGRlci5fdXBkYXRlRmllbGRQcm9wZXJ0aWVzKGUpOyAvL0ZJWE1FIFRoaXMgaXMgY2FsbGVkIDIgdG8gMyB0aW1lc1xuICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vRklYTUUgYF9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKClgIGFsd2F5cyByZXR1cm5zIFRSVUUsIHdoaWNoIG1lYW5zIGBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7YCBhdCB0aGUgZW5kIGlzIE5FVkVSIGNhbGxlZC5cbiAgICAgICAgaWYgKGhvbGRlci5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpKSB7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGFkZCBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIHdlIGRvIG5vdCBhbGxvdyB0aGUgaW5wdXQgZXZlbnQgdG8gYmUgc2VudFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXVwJyBldmVudHMuXG4gICAgICogVGhlIHVzZXIganVzdCByZWxlYXNlZCBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEtleUNvZGUgPSBrZXkoZSk7IC8vIFRoZSBrZXkgYmVpbmcgdXNlZFxuXG4gICAgICAgIGhvbGRlci5fdXBkYXRlRmllbGRQcm9wZXJ0aWVzKGUpOyAvL0ZJWE1FIFRoaXMgaXMgY2FsbGVkIDIgdG8gMyB0aW1lc1xuICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLl9za2lwQWx3YXlzKGUpO1xuICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgaWYgKHNraXAgfHwgZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkge1xuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRLZXlDb2RlID09PSBrZXlDb2RlLlRhYikge1xuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHx8XG4gICAgICAgICAgICAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJykpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxuICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICBhdXRvU2F2ZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRRdWljayhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c291dCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICBpZiAoISR0aGlzLmlzKCc6Zm9jdXMnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGF1dG9TYXZlKGUudGFyZ2V0LCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9IHNldHRpbmdzLm9TZXA7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSBzZXR0aW5ncy5vU2lnbjtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdWZmaXhUZXh0ID0gc2V0dGluZ3Mub1N1ZmZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPSBzZXR0aW5ncy5vUGFkO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0gc2V0dGluZ3Mub0JyYWNrZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gYXV0b1N0cmlwKHZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgPyArc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzIDogc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZXNlbnROdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQoJzAnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKSB7XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWRcbiAgICAgICAgLy8gVGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBkZWZhdWx0LCBzaW5jZSBvdGhlcndpc2UgdGhlIHVzZXIgd291bGQgYmUgYWJsZSB0byBwYXN0ZSBpbnZhbGlkIGNoYXJhY3RlcnMgaW50byB0aGUgaW5wdXRcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBlLnRhcmdldC52YWx1ZSB8fCAnJztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBjdXJyZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyksIGhvbGRlcik7XG5cbiAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQocGFzdGVkVGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJlcGFyZVBhc3RlZFRleHQocHJlZml4ICsgTnVtYmVyKHBhc3RlZFRleHQpLnZhbHVlT2YoKSArIHN1ZmZpeCwgaG9sZGVyKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQobmV3VmFsdWUpICYmIE51bWJlcihvbGRSYXdWYWx1ZSkudmFsdWVPZigpICE9PSBOdW1iZXIobmV3VmFsdWUpLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gT24gYSAnbm9ybWFsJyBub24tYXV0b051bWVyaWMgaW5wdXQsIGFuIGBpbnB1dGAgZXZlbnQgaXMgc2VudCB3aGVuIGEgcGFzdGUgaXMgZG9uZS4gV2UgbWltaWMgdGhhdC5cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8vRklYTUUgQWZ0ZXIgYSBwYXN0ZSwgdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgZmFyIHJpZ2h0IG9mIHRoZSBpbnB1dCwgaXQgc2hvdWxkIGJlIHNldCB0byBzb21ldGhpbmcgbGlrZSBgbmV3Q2FyZXRQb3NpdGlvbiA9IG9sZENhcmV0UG9zaXRpb24gKyBwYXN0ZVRleHQubGVuZ3RoO2AsIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMsIHRoZSBkZWNpbWFsIGNoYXJhY3RlciwgdGhlIG5lZ2F0aXZlIHNpZ24vYnJhY2tldHMsIGFuZCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBmb2N1c2luZyBvdXQgb2YgdGhlIGlucHV0LCB3ZSBjaGVjayBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsIHRoZW4gd2Ugc2VuZCBhIGBjaGFuZ2VgIGV2ZW50IChzaW5jZSB0aGUgbmF0aXZlIG9uZSB3b3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGBlLnByZXZlbnREZWZhdWx0KClgIGNhbGxlZCBpbiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkJsdXIoaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLnZhbHVlT25Gb2N1cykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIHNlbmQgYSBzZWNvbmQgY2hhbmdlIGV2ZW50ICh0aGF0IHNvbWVob3cgZ2V0cyBwaWNrZWQgdXAgYnkgalF1ZXJ5LCBidXQgbm90IGJ5IGBhZGRFdmVudExpc3RlbmVyKClgIC8vRklYTUUgS05PV04gQlVHIDogVGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBzZWNvbmQgY2hhbmdlIGV2ZW50IHRvIGJlIHBpY2tlZCB1cCBieSBqUXVlcnlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdzdWJtaXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25TdWJtaXQoJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5jbG9zZXN0KCdmb3JtJykub24oJ3N1Ym1pdC5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5mb3JtYXRPblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgalF1ZXJ5IHNlbGVjdGVkIGlucHV0IGlmIHRoZSB0YWcgYW5kIHR5cGUgYXJlIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcbiAgICAgICAgLy8gU3VwcG9ydGVkIGlucHV0IHR5cGVcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xuICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudFRhZyA9ICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRUYWcgIT09ICdpbnB1dCcgJiYgIWlzSW5BcnJheShjdXJyZW50RWxlbWVudFRhZywgYWxsb3dlZFRhZ0xpc3QpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRpbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3V0aW5lIHRvIGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSAkaW5wdXRcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKSB7XG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkYCkpLlxuICAgICAgICAgICAgICogTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXIgaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgaWdub3JlIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJ1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsICYmIHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlLnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICEkLmlzTnVtZXJpYyhjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gYXV0b1NhdmUoJHRoaXNbMF0sIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB2YWx1ZSBzaG91bGQgTk9UIGJlIHNhdmVkIGluIHNlc3Npb25TdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnICYmIGNvbnRhaW5zKGN1cnJlbnRWYWx1ZSwgJy0nKSk/Jy0nICsgYXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzLCB0cnVlKTphdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWZhdWx0VmFsdWVPdmVycmlkZSA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlIHRoZSB1c2VyIGV4cGVyaWVuY2UgYnkgbW9kaWZ5aW5nIHRoZSBkZWZhdWx0IGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgb3B0aW9uIGRlcGVuZGluZyBvbiBgY3VycmVuY3lTeW1ib2xgIGFuZCBgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiAoYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgY3VycmVuY3lTeW1ib2xgKSxcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIGluIG9yZGVyIHRvIGtlZXAgdGhlIHJlc3VsdGluZyBvdXRwdXQgbG9naWNhbCBieSBkZWZhdWx0IDpcbiAgICAgKiAtIFwiJC0xLDIzNC41NlwiIGluc3RlYWQgb2YgXCItJDEsMjM0LjU2XCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn0pXG4gICAgICogLSBcIi0xLDIzNC41NiRcIiBpbnN0ZWFkIG9mIFwiMSwyMzQuNTYtJFwiICh7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9ucykgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpICYmIG9wdGlvbnMuY3VycmVuY3lTeW1ib2wgIT09ICcnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ3AnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPSAncic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXplIGFuZCBzYXZlIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBpbnRlZ2VyIHNpemUgZm9yIGxhdGVyIHVzZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHt7bWF4aW11bVZhbHVlOiBBcnJheSwgbWluaW11bVZhbHVlOiBBcnJheX19XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgW21pbmltdW1WYWx1ZUludGVnZXJQYXJ0XSA9ICghc2V0dGluZ3MubWluaW11bVZhbHVlICYmIHNldHRpbmdzLm1pbmltdW1WYWx1ZSAhPT0gMCk/W106c2V0dGluZ3MubWluaW11bVZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4aW11bVZhbHVlSW50ZWdlclBhcnQgPSBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG5cbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KG1heGltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBhcyBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3RNRGVjT3B0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghaXNOdWxsKHNldHRpbmdzLnNjYWxlRGl2aXNvcikgJiYgIWlzTnVsbChzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpKSB7XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgd2l0aCB0aGUgb25lIGRlZmluZWQgd2l0aCB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIHRvIHNob3cgd2hlbiBub3QgaW4gZm9jdXMsIGlmIHNldFxuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBTdHJpbmcoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vc3QgY2FsY3VsdXMgYXNzdW1lIGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGlzIGFuIGludGVnZXIsIHRoZSBmb2xsb3dpbmcgc3RhdGVtZW50IG1ha2VzIGl0IGNsZWFyIChvdGhlcndpc2UgaGF2aW5nIGl0IGFzIGEgc3RyaW5nIGxlYWRzIHRvIHByb2JsZW1zIGluIHJvdW5kaW5nIGZvciBpbnN0YW5jZSlcbiAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncykge1xuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgJiYgTnVtYmVyKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciA9PT0gJy4nICYmIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciA9PT0gJywnICYmIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBhdXRvU3RyaXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcbiAgICAgICAgc2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG4gICAgICAgIHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ31bXi0keyhzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YFxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gOicnKX1cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfVxcXFxkXS4qPyhcXFxcZHxcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfVxcXFxkKWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9PylbXlxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9XFxcXGRdXFxcXEQqJGApO1xuXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWA7XG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8oXFxcXGQrXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1cXFxcZCspfChcXFxcZCooPzpcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfVxcXFxkKik/KSlgKTtcblxuICAgICAgICAvLyBVc2luZyB0aGlzIHJlZ2V4IHZlcnNpb24gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGR8JClgIGVudGlyZWx5IGNsZWFyIHRoZSBpbnB1dCBvbiBibHVyXG4gICAgICAgIHNldHRpbmdzLnN0cmlwUmVnID0gbmV3IFJlZ0V4cChgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZClgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZScgbGF0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIGFscmVhZHkgb2YgdHlwZSAnTnVtYmVyJywgc2hvdWxkbid0IHdlIGtlZXAgaXQgYXMgYSBudW1iZXIgZm9yIGZ1cnRoZXIgbWFuaXB1bGF0aW9uLCBpbnN0ZWFkIG9mIHVzaW5nIGEgc3RyaW5nP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYga2V5ICE9PSAnYVNjYWxlJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBvbGQgc2V0dGluZ3Mgb3B0aW9ucyBuYW1lIHRvIG5ldyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyhvcHRpb25zKSB7XG4gICAgICAgIC8vVE9ETyBEZWxldGUgdGhpcyBmdW5jdGlvbiBvbmNlIHRoZSBvbGQgb3B0aW9ucyBhcmUgbm90IHVzZWQgYW55bW9yZVxuICAgICAgICBjb25zdCBvbGRPcHRpb25zQ29udmVydGVyID0ge1xuICAgICAgICAgICAgLy8gT2xkIG9wdGlvbiBuYW1lLCB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgbmV3IG9wdGlvblxuICAgICAgICAgICAgYVNlcCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdEdyb3VwU2VwYXJhdG9yJyxcbiAgICAgICAgICAgIG5TZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9TZXBhcmF0b3JPbkZvY3VzJyxcbiAgICAgICAgICAgIGRHcm91cCAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRhbEdyb3VwU3BhY2luZycsXG4gICAgICAgICAgICBhRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxDaGFyYWN0ZXInLFxuICAgICAgICAgICAgYWx0RGVjICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUnLFxuICAgICAgICAgICAgYVNpZ24gICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbCcsXG4gICAgICAgICAgICBwU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sUGxhY2VtZW50JyxcbiAgICAgICAgICAgIHBOZWcgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnLFxuICAgICAgICAgICAgYVN1ZmZpeCAgICAgICAgICAgICAgICAgICAgICA6ICdzdWZmaXhUZXh0JyxcbiAgICAgICAgICAgIG9MaW1pdHMgICAgICAgICAgICAgICAgICAgICAgOiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnLFxuICAgICAgICAgICAgdk1heCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtYXhpbXVtVmFsdWUnLFxuICAgICAgICAgICAgdk1pbiAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtaW5pbXVtVmFsdWUnLFxuICAgICAgICAgICAgbURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnLFxuICAgICAgICAgICAgZURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyxcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbCAgICAgICAgICAgICAgICAgOiAnc2NhbGVEZWNpbWFsUGxhY2VzJyxcbiAgICAgICAgICAgIGFTdG9yICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScsXG4gICAgICAgICAgICBtUm91bmQgICAgICAgICAgICAgICAgICAgICAgIDogJ3JvdW5kaW5nTWV0aG9kJyxcbiAgICAgICAgICAgIGFQYWQgICAgICAgICAgICAgICAgICAgICAgICAgOiAnYWxsb3dEZWNpbWFsUGFkZGluZycsXG4gICAgICAgICAgICBuQnJhY2tldCAgICAgICAgICAgICAgICAgICAgIDogJ25lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyJyxcbiAgICAgICAgICAgIHdFbXB0eSAgICAgICAgICAgICAgICAgICAgICAgOiAnZW1wdHlJbnB1dEJlaGF2aW9yJyxcbiAgICAgICAgICAgIGxaZXJvICAgICAgICAgICAgICAgICAgICAgICAgOiAnbGVhZGluZ1plcm8nLFxuICAgICAgICAgICAgYUZvcm0gICAgICAgICAgICAgICAgICAgICAgICA6ICdmb3JtYXRPblBhZ2VMb2FkJyxcbiAgICAgICAgICAgIHNOdW1iZXIgICAgICAgICAgICAgICAgICAgICAgOiAnc2VsZWN0TnVtYmVyT25seScsXG4gICAgICAgICAgICBhbkRlZmF1bHQgICAgICAgICAgICAgICAgICAgIDogJ2RlZmF1bHRWYWx1ZU92ZXJyaWRlJyxcbiAgICAgICAgICAgIHVuU2V0T25TdWJtaXQgICAgICAgICAgICAgICAgOiAndW5mb3JtYXRPblN1Ym1pdCcsXG4gICAgICAgICAgICBvdXRwdXRUeXBlICAgICAgICAgICAgICAgICAgIDogJ291dHB1dEZvcm1hdCcsXG4gICAgICAgICAgICBkZWJ1ZyAgICAgICAgICAgICAgICAgICAgICAgIDogJ3Nob3dXYXJuaW5ncycsXG4gICAgICAgICAgICAvLyBDdXJyZW50IG9wdGlvbnMgOlxuICAgICAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBub1NlcGFyYXRvck9uRm9jdXMgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cFNwYWNpbmcgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgIDogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgICAgICA6IHRydWUsXG4gICAgICAgICAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIHN1ZmZpeFRleHQgICAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3ZlcnJpZGVNaW5NYXhMaW1pdHMgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc092ZXJyaWRlICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlRGl2aXNvciAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsUGxhY2VzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZVN5bWJvbCAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgICAgOiB0cnVlLFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgOiB0cnVlLFxuICAgICAgICAgICAgZW1wdHlJbnB1dEJlaGF2aW9yICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzaG93V2FybmluZ3MgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIC8vRklYTUUgRmluZCBhIHdheSB0byBleGNsdWRlIHRob3NlIGludGVybmFsIGRhdGEgZnJvbSB0aGUgc2V0dGluZ3Mgb2JqZWN0IChpZGVhbGx5IGJ5IHVzaW5nIGFub3RoZXIgb2JqZWN0LCBvciBiZXR0ZXIgeWV0LCBjbGFzcyBhdHRyaWJ1dGVzKSAtLT5cbiAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmUgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRocm93SW5wdXQgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmlwICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnbkNoYXJhY3RlcjogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnRQb3MgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG1JbnROZWcgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9EZWMgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9QYWQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9CcmFja2V0ICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TZXAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TaWduICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9TdWZmaXggICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGFOZWdSZWdBdXRvU3RyaXAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBGaXJzdEF1dG9TdHJpcCAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNraXBMYXN0QXV0b1N0cmlwICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93ZWRBdXRvU3RyaXAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG51bVJlZ0F1dG9TdHJpcCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmlwUmVnICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGhvbGRlciAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW9uIGlzIGEgJ25ldycgb3B0aW9uLCB3ZSBjb250aW51ZSBsb29waW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvbGRPcHRpb25zQ29udmVydGVyLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSB3ZSBoYXZlIGFuICdvbGQnIG9wdGlvbiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFlvdSBhcmUgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgb3B0aW9uIG5hbWUgJyR7b3B0aW9ufScuIFBsZWFzZSB1c2UgJyR7b2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dfScgaW5zdGVhZCBmcm9tIG5vdyBvbi4gVGhlIG9sZCBvcHRpb24gbmFtZSB3aWxsIGJlIGRyb3BwZWQgc29vbi5gLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIHdlIG1vZGlmeSB0aGUgaW5pdGlhbCBvcHRpb24gb2JqZWN0IHRvIHVzZSB0aGUgbmV3IG9wdGlvbnMgaW5zdGVhZCBvZiB0aGUgb2xkIG9uZXNcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl1dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLm9yIHRoZSBvcHRpb24gbmFtZSBpcyB1bmtub3duLiBUaGlzIG1lYW5zIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlcmVmb3JlIHdlIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBPcHRpb24gbmFtZSAnJHtvcHRpb259JyBpcyB1bmtub3duLiBQbGVhc2UgZml4IHRoZSBvcHRpb25zIHBhc3NlZCB0byBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5c2UgdGhlIHNldHRpbmdzL29wdGlvbnMgcGFzc2VkIGJ5IHRoZSB1c2VyLCB2YWxpZGF0ZSBhbmQgY2xlYW4gdGhlbSwgdGhlbiByZXR1cm4gdGhlbS5cbiAgICAgKiBOb3RlOiBUaGlzIHJldHVybnMgYG51bGxgIGlmIHNvbWVob3cgdGhlIHNldHRpbmdzIHJldHVybmVkIGJ5IGpRdWVyeSBpcyBub3QgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIFRSVUUsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIWlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCBpc1VuZGVmaW5lZChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHNldHRpbmdzIGFyZSBnZW5lcmF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIEhUTUw1IGRhdGEsIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIHdlJ2xsIGdldCBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgb25PZmYgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLCAvLyBUaHJvdyBpbnB1dCBldmVudFxuICAgICAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgOiBhbGxvd2VkVGFnTGlzdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXG4gICAgICAgICAgICB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBJbXByb3ZlIHRoZSBgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgIG9wdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgICAgIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZWdhdGl2ZSBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gc2V0dGluZ3MubWluaW11bVZhbHVlIDwgMCA/ICctJyA6ICcnO1xuXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGNoYW5nZXMgdG8gdGhlIHNldHRpbmdzIG9iamVjdCAoZnJvbSB0aGUgb3JpZ2luYWwgYXV0b0NvZGUoKSBmdW5jdGlvbilcbiAgICAgICAgICAgIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29ycmVjdE1EZWNPcHRpb24oc2V0dGluZ3MpO1xuICAgICAgICAgICAgc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncyk7XG4gICAgICAgICAgICBjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgdmFsaWRhdGUoc2V0dGluZ3MsIGZhbHNlKTsgLy8gVGhyb3dzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cywgc2NhbGVEaXZpc29yICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgICAgICAgIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHtkaWdpdEdyb3VwU2VwYXJhdG9yOiBcIi5cIiwgZGVjaW1hbENoYXJhY3RlcjogXCIsXCIsIGN1cnJlbmN5U3ltYm9sOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCAkaW5wdXQgPSBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgkdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0IHRoYXQgc3RvcmUgdGhlIGZpZWxkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBjb25zdCBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnJ1bk9uY2UgJiYgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBlID0+IHsgb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7IG9uS2V5ZG93bihob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBlID0+IHsgb25LZXlwcmVzcyhob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHsgb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBlID0+IHsgb25CbHVyKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGUgPT4geyBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpOyAvL1RPRE8gU3dpdGNoIHRvIGBhZGRFdmVudExpc3RlbmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gcmVtb3ZlIHNldHRpbmdzIGFuZCBzdG9wIGF1dG9OdW1lcmljKCkgLSBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gZGVzdHJveXMgYXV0b051bWVyaWNcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpc1swXSwgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZignLmF1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgYW5kIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyByZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3aXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwidXBkYXRlXCIsIHtvcHRpb25zfSk7IC8vIHVwZGF0ZXMgdGhlIHNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZhbCgpICE9PSAnJyB8fCAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJ3ZhbHVlJyk7IC8vIGZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZGApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgYmVpbmcgc2V0IGlzIG5vdCBudW1lcmljXG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzTnVtZXJpYyhOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmAsIHNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgJiYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IChzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzIDogc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgPT09IG51bGwgJiYgc2V0dGluZ3Muc2NhbGVEaXZpc29yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UgJiYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIG1pbmltdW1WYWx1ZSBbJHtzZXR0aW5ncy5taW5pbXVtVmFsdWV9XSBhbmQgbWF4aW11bVZhbHVlIFske3NldHRpbmdzLm1heGltdW1WYWx1ZX1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byB1bi1mb3JtYXQgaW5wdXRzIC0gaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCd1blNldCcpOyAvLyBubyBwYXJhbWV0ZXIgYWNjZXB0ZWRcbiAgICAgICAgICogYnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiLCBvciBldmVuIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICB1blNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cyAtIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpOyAvLyBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqIHRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSAndW5TZXQnIG1ldGhvZCB0byByZWZvcm1hdCB0aGUgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIHJlU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGVsZW1lbnQgdHlwZSB0aGVuIHVzZSAuZXEoMCkgc2VsZWN0b3IgdG8gZ3JhYiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gc2VsZWN0b3JcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MucmF3VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCgvXFxkLykudGVzdCh2YWx1ZSkgfHwgTnVtYmVyKHZhbHVlKSA9PT0gMCkgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnICYmIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gZml4TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYSBudW1lcmljIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgYnV0IGZvbGxvd2luZyB0aGUgYG91dHB1dEZvcm1hdGAgc2V0dGluZywgd2hpY2ggbWVhbnMgdGhlIG91dHB1dCBjYW4gZWl0aGVyIGJlIDpcbiAgICAgICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxuICAgICAgICAgKiAtIGEgcGxhaW4gbnVtYmVyIChpZiB0aGUgc2V0dGluZyAnbnVtYmVyJyBpcyB1c2VkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgICAgICogQ2hlY2sgdGhlIFwib3V0cHV0Rm9ybWF0XCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMb2NhbGl6ZWQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnMCcpIHx8ICEoJ3ZhbHVlJyBpbiB0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KGZhbHNlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KHRydWUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIHRoZSBvYmplY3Qgd2l0aCBhdXRvTnVtZXJpYyBzZXR0aW5ncyBmb3IgdGhvc2Ugd2hvIG5lZWQgdG8gbG9vayB1bmRlciB0aGUgaG9vZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJyk7IC8vIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpLmRlY2ltYWxDaGFyYWN0ZXI7IC8vIHJldHVybiB0aGUgZGVjaW1hbENoYXJhY3RlciBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW50IHZhbGlkIHNldHRpbmcgY2FuIGJlIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cbiAgICAgKiBJdCBpbml0aWFsaXplIGF1dG9OdW1lcmljIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XG5cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0gZGVmYXVsdFNldHRpbmdzOyAvLyBNYWtlIHRob3NlIHNldHRpbmdzIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyXG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYEEgbnVtYmVyIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIGZvcm1hdCBpdCwgWyR7dmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYXRlIGEgdmVyeSBiYXNpYyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xuICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy5taW5pbXVtVmFsdWUsIHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNpYyB0ZXN0cyB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIGlmICghbWluVGVzdCB8fCAhbWF4VGVzdCkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGRvY3VtZW50LCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSBtaW5pbXVtVmFsdWUgWyR7c2V0dGluZ3MubWluaW11bVZhbHVlfV0gYW5kIG1heGltdW1WYWx1ZSBbJHtzZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXZlcnl0aGluZyBpcyBvaywgcHJvY2VlZCB0byByb3VuZGluZywgZm9ybWF0dGluZyBhbmQgZ3JvdXBpbmdcbiAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0OyAvLyBUaGUgalF1ZXJ5IGV4cG9ydFxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdXRvVW5Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHaXZpbmcgYW4gdW5mb3JtYXR0ZWQgdmFsdWUgc2hvdWxkIHJldHVybiB0aGUgc2FtZSB1bmZvcm1hdHRlZCB2YWx1ZSwgd2hhdGV2ZXIgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzT2JqZWN0KHZhbHVlKSkgeyAvL1RPRE8gQ29tcGxldGUgdGhlIHRlc3QgdG8gdGhyb3cgd2hlbiBnaXZlbiBhIHdyb25nbHkgZm9ybWF0dGVkIG51bWJlciAoaWUuICdmb29iYXInKVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgQSBudW1iZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbnVtYmVyIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIHVuZm9ybWF0IGl0LCBbJHt2YWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgJiYgc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKVswXSA9PT0gdmFsdWUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRGb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0cnVlOyAvLyBUaGUgZXJyb3IgaGVyZSBtdXN0IGFsd2F5cyBiZSB0aHJvd24sIHNpbmNlIGEgYmFkbHkgY29uZmlndXJlZCBvcHRpb25zIG9iamVjdCB3aWxsIGxlYWQgdG8gd3JvbmcgcmVzdWx0cywgaWYgYW55LlxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgb2xkIG9wdGlvbnMsIHdlIGNvbnZlcnQgdGhlbSB0byBuZXcgb25lc1xuICAgICAgICBpZiAoIWlzTnVsbCh1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKHVzZXJPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB1c2VyIGNhbiBjaG9vc2UgaWYgdGhlIGB1c2VyT3B0aW9uc2AgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIG9yIG5vdFxuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdXNlck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XG4gICAgICAgIGNvbnN0IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzID0gL1swLTldKy87XG4gICAgICAgIC8vIGNvbnN0IHRlc3RGbG9hdEFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKSQvO1xuICAgICAgICBjb25zdCB0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKyk/JC87XG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyID0gL15bMC05XSsoXFwuP1swLTldKyk/JC87XG5cbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBbJywnLCAnLicsICcgJywgJyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcsJywgJy4nLCAnICcgb3IgZW1wdHkgKCcnKSwgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgJ25vU2VwYXJhdG9yT25Gb2N1cycgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nKSkgeyAvLyBpc05hTihwYXJzZUludChvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcpKSAvL0RFQlVHXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZGlnaXRhbEdyb3VwU3BhY2luZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLCBbJywnLCAnLiddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJy4nIG9yICcsJywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXIgPT09IG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ2RlY2ltYWxDaGFyYWN0ZXInIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yICdkaWdpdEdyb3VwU2VwYXJhdG9yJyBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmICFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhbHRlcm5hdGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmICFpc1N0cmluZyhvcHRpb25zLmN1cnJlbmN5U3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1cnJlbmN5IHN5bWJvbCBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50LCBbJ3AnLCAncyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgY3VycmVuY3kgc2lnbiBvcHRpb24gJ2N1cnJlbmN5U3ltYm9sUGxhY2VtZW50JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCkgb3IgJ3MnIChzdWZmaXgpLCBbJHtvcHRpb25zLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50LCBbJ3AnLCAncycsICdsJywgJ3InXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpLCAncycgKHN1ZmZpeCksICdsJyAobGVmdCkgb3IgJ3InIChyaWdodCksIFske29wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5zdWZmaXhUZXh0KSB8fCAob3B0aW9ucy5zdWZmaXhUZXh0ICE9PSAnJyAmJiAoY29udGFpbnMob3B0aW9ucy5zdWZmaXhUZXh0LCAnLScpIHx8IHRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzLnRlc3Qob3B0aW9ucy5zdWZmaXhUZXh0KSkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWRkaXRpb25hbCBzdWZmaXggb3B0aW9uICdzdWZmaXhUZXh0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIG5vdCBjb250YWlucyB0aGUgbmVnYXRpdmUgc2lnbiAnLScgbm9yIGFueSBudW1lcmljYWwgY2hhcmFjdGVycywgWyR7b3B0aW9ucy5zdWZmaXhUZXh0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb3ZlcnJpZGVNaW5NYXhMaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1heGltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21heGltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMubWluaW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1pbmltdW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWluaW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMubWluaW11bVZhbHVlKSA+IHBhcnNlRmxvYXQob3B0aW9ucy5tYXhpbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB8fFxuICAgICAgICAgICAgKGlzSW50KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+PSAwKSB8fCAvLyBJZiBpbnRlZ2VyIG9wdGlvblxuICAgICAgICAgICAgKGlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSkgIC8vIElmIHN0cmluZyBvcHRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUgaXMgb3ZlcnJpZGRlbiBieSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKGFuZCBub3QgaWYgZGVjaW1hbFBsYWNlc092ZXJyaWRlIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCB1c2VkIGluIG1pbmltdW1WYWx1ZS9tYXhpbXVtVmFsdWUpXG4gICAgICAgIGNvbnN0IHZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKG9wdGlvbnMubWluaW11bVZhbHVlLCBvcHRpb25zLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzICE9PSBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIHRvIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gd2lsbCBvdmVycmlkZSB0aGUgZGVjaW1hbHMgZGVjbGFyZWQgaW4gJ21pbmltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBhbmQgJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gLCBzaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FsbG93RGVjaW1hbFBhZGRpbmcnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0uYCwgc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1wiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbm9ybWFsIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc092ZXJyaWRlXCJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAhaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIDwgTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBpcyBncmVhdGVyIHRoYW4gdGhlICdkZWNpbWFsUGxhY2VzT3ZlcnJpZGUnIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gdmFsdWUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGl2aXNvcikgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgZGl2aXNvciBvcHRpb24gJ3NjYWxlRGl2aXNvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlciwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGl2aXNvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsUGxhY2VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzYXZlIHRvIHNlc3Npb24gc3RvcmFnZSBvcHRpb24gJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2V9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucm91bmRpbmdNZXRob2QsIFtcbiAgICAgICAgICAgICdTJyxcbiAgICAgICAgICAgICdBJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICdCJyxcbiAgICAgICAgICAgICdVJyxcbiAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICdDJyxcbiAgICAgICAgICAgICdGJyxcbiAgICAgICAgICAgICdOMDUnLFxuICAgICAgICAgICAgJ0NIRicsXG4gICAgICAgICAgICAnVTA1JyxcbiAgICAgICAgICAgICdEMDUnLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ3JvdW5kaW5nTWV0aG9kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMucm91bmRpbmdNZXRob2R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGNvbnRyb2wgZGVjaW1hbCBwYWRkaW5nIG9wdGlvbiAnYWxsb3dEZWNpbWFsUGFkZGluZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IsIFsnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJywgJ3plcm8nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2VtcHR5SW5wdXRCZWhhdmlvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgWydhbGxvdycsICdkZW55JywgJ2tlZXAnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3Igb3B0aW9uICdsZWFkaW5nWmVybycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2FsbG93JywgJ2RlbnknIG9yICdrZWVwJywgWyR7b3B0aW9ucy5sZWFkaW5nWmVyb31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnZm9ybWF0T25QYWdlTG9hZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZm9ybWF0T25QYWdlTG9hZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdkZWZhdWx0VmFsdWVPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuZm9ybWF0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuZm9ybWF0T25TdWJtaXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3V0cHV0Rm9ybWF0KSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3V0cHV0Rm9ybWF0LCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2hvd1dhcm5pbmdzKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnc2hvd1dhcm5pbmdzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zaG93V2FybmluZ3N9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlU2V0dGluZ3NWYWxpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50IGFuZCBpbW1lZGlhdGVseSBzZW50IGl0IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCwgaWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgdGhlIGV2ZW50IGlzIHRocm93biBmcm9tIGBkb2N1bWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRldGFpbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGVsZW1lbnQgPSBkb2N1bWVudCwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICBsZXQgZXZlbnQ7XG4gICAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIHsgZGV0YWlsIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgKElFKVxuICAgICAqL1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB2b2lkKDApIH07XG4gICAgICAgICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG4gICAgfSkoKTtcbn0pKTtcblxuLyoqXG4gKiBUaGlzIGV4cG9ydHMgdGhlIGludGVyZmFjZSBmb3IgdGhlIGF1dG9OdW1lcmljIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZm9ybWF0ICA6IGF1dG9Gb3JtYXQsXG4gICAgdW5Gb3JtYXQ6IGF1dG9VbkZvcm1hdCxcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxuICAgIHZhbGlkYXRlLCAvLyBhbi52YWxpZGF0ZShvcHRpb25zKSA6IHRocm93cyBpZiBuZWNlc3NhcnlcbiAgICBhcmVTZXR0aW5nc1ZhbGlkLCAvL2FuLmFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgOiByZXR1cm4gdHJ1ZSBvciBmYWxzZSAvL1RPRE8gSXMgdGhpcyByZWR1bmRhbnQ/IFNob3VsZCB3ZSBsZXQgdGhlIGRldmVsb3BlcnMgd3JhcCBlYWNoIGF1dG9OdW1lcmljLnZhbGlkYXRlKCkgY2FsbHMgaW4gdHJ5L2NhdGNoIGJsb2NrPyBPciBzaG91bGQgd2UganVzdCBmYWNpbGl0YXRlIHRoZWlyIGxpZmUgYnkgZG9pbmcgaXQgYWxyZWFkeT9cblxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxuICAgIC8vaW5pdCAgICAgICAgIDogYW4uaW5pdChvcHRpb25zLCBpbnB1dClcbiAgICAvL2dldCAgICAgICAgICA6IGFuLmdldChpbnB1dClcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXG4gICAgLy9mb3JtU3RyaW5nICAgOiBhbi5mb3JtU3RyaW5nKGZvcm0pXG4gICAgLy9mb3JtQXJyYXkgICAgOiBhbi5mb3JtQXJyYXkoZm9ybSlcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcbiAgICAvL3Vuc2V0ICAgICAgICA6IGFuLnVuc2V0KGlucHV0KSAvL3RvIHJlbmFtZSB0byAndW5mb3JtYXQnPyAoYW5kIG1lcmdlIHdpdGggYXV0b1VuRm9ybWF0L3VuRm9ybWF0PylcbiAgICAvL3JlZm9ybWF0ICAgICA6IGFuLnJlZm9ybWF0KGlucHV0KSAvLyAncmVTZXQnIGlzIHZlcnkgdG8gY2xvc2UgdG8gJ3Jlc2V0JyBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSByZW5hbWVkLiBXZSBjb3VsZCBzdGlsbCBleHBvc2UgJ3JlU2V0JywgYnV0IGFkZCBhIEBkZXByZWNhdGVkIHRhZyBvbiBpdHMgZGVjbGFyYXRpb24uXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcbiAgICAvL3VwZGF0ZSAgICAgICA6IGFuLnVwZGF0ZShvcHRpb25zLCBpbnB1dClcbiAgICAvL3dpcGUgICAgICAgICA6IGFuLndpcGUoaW5wdXQpXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL2JvYmtuL0RvY3VtZW50cy9HaXRIdWIvYXV0b051bWVyaWMvc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
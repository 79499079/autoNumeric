(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-12-01 UTC 21:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     */\n    aSep: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     */\n    nSep: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * dGroup: \"3\", results in 999,999,999 default\n     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n     */\n    dGroup: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     */\n    aDec: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     */\n    altDec: null,\n\n    /* aSign = allowed currency symbol\n     * Must be in quotes aSign: \"$\"\n     * space to the right of the currency symbol aSign: '$ '\n     * space to the left of the currency symbol aSign: ' $'\n     */\n    aSign: '',\n\n    /* pSign = placement of currency sign as a p=prefix or s=suffix\n     * for prefix pSign: \"p\" (default)\n     * for suffix pSign: \"s\"\n     */\n    pSign: 'p',\n\n    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {aSign: \"$\"}\n     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n     * 1,234.56-  => {pNeg: \"s\"}\n     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n     */\n    pNeg: 'l',\n\n    /* Additional suffix\n     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     */\n    aSuffix: '',\n\n    /* Override min max limits\n     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n     * oLimits: \"ignore\" ignores both vMin & vMax\n     */\n    oLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than vMin\n     */\n    vMax: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than vMax\n     */\n    vMin: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n     */\n    mDec: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     */\n    eDec: null,\n\n    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     */\n    scaleDecimal: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the eDec value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     */\n    aStor: false,\n\n    /* method used for rounding\n     * mRound: \"S\", Round-Half-Up Symmetric (default)\n     * mRound: \"A\", Round-Half-Up Asymmetric\n     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * mRound: \"U05\" Rounds up to next .05\n     * mRound: \"D05\" Rounds down to next .05\n     */\n    mRound: 'S',\n\n    /* Controls decimal padding\n     * aPad: true - always Pad decimals with zeros\n     * aPad: false - does not pad with zeros.\n     * Note: setting aPad to 'false' will override the 'mDec' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     */\n    aPad: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * nBracket: null - (default)\n     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n     */\n    nBracket: null,\n\n    /* Displayed on empty string \"\"\n     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n     * wEmpty: \"press\" - currency sign displays on any key being pressed\n     * wEmpty: \"always\" - always displays the currency sign only\n     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     */\n    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n    wEmpty: 'focus',\n\n    /* Controls leading zero behavior\n     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * lZero: \"deny\", - allows only one leading zero on values less than one\n     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     */\n    lZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value\n     */\n    aForm: true,\n\n    /* Determine if the select all keyboard command will select\n     * the complete input text or only the input numeric value\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n     */\n    sNumber: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {anDefault: \"\"}\n     * value=1234.56 {anDefault: '1234.56'}\n     */\n    anDefault: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     */\n    unSetOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     */\n    outputType: null,\n\n    /* Error handling function\n     * true => all errors are thrown - helpful in site development\n     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n     */\n    debug: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return TRUE if the text given as a parameter is valid.\n     *\n     * @param text\n     * @returns {boolean}\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param text\n     * @param holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param event\n     * @returns {string|Number}\n     */\n    function key(event) {\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} suppressWarnings If TRUE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param $this\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the vMin and vMax settings\n     */\n    function maximumVMinAndVMaxDecimalLength(vMin, vMax) {\n        return Math.max(decimalPlaces(vMin), decimalPlaces(vMax));\n    }\n\n    /**\n     * Strip all unwanted characters and leave only a number alert\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string|*}\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // Remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // Remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n\n        if (settings.onOff && settings.lZero === 'deny' || !settings.onOff && settings.lZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Places or removes brackets on negative values\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputType\" option definition for more details.\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputType [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare number string to be converted to real number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function fixNumber(s, settings) {\n        if (settings.aDec !== '.') {\n            s = s.replace(settings.aDec, '.');\n        }\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace(settings.aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Prepare real number to be converted to our format\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? inputValue + settings.aSign + settings.aSuffix : settings.aSign + inputValue + settings.aSuffix;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Private function that formats our number\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoGroup(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = autoStrip(inputValue, settings);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNegative = contains(inputValue, '-');\n        if (isNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.dGroup = settings.dGroup.toString();\n        var digitalGroup = void 0;\n        switch (settings.dGroup) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.aDec),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.altDec);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.aSep !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.aDec + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        if (settings.pSign === 'p') {\n            if (isNegative) {\n                switch (settings.pNeg) {\n                    case 'l':\n                        inputValue = settings.aNeg + settings.aSign + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = settings.aSign + settings.aNeg + inputValue;\n                        break;\n                    case 's':\n                        inputValue = settings.aSign + inputValue + settings.aNeg;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.aSign + inputValue;\n            }\n        }\n\n        if (settings.pSign === 's') {\n            if (isNegative) {\n                switch (settings.pNeg) {\n                    case 'r':\n                        inputValue = inputValue + settings.aSign + settings.aNeg;\n                        break;\n                    case 'l':\n                        inputValue = inputValue + settings.aNeg + settings.aSign;\n                        break;\n                    case 'p':\n                        inputValue = settings.aNeg + inputValue + settings.aSign;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.aSign;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = negativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param rDec\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the mDec length when aPad is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (rDec === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoRound(inputValue, settings) {\n        // value to string\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.lZero !== 'keep' || inputValue.length > 0 && settings.lZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < rDec) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.mDec - 1;\n        } else {\n            rLength = settings.mDec + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(obj)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            obj = '#' + obj.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param $that\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getHolder($that, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when eDec & nSep options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave(element, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateFieldProperties',\n            value: function _updateFieldProperties(e) {\n                this.value = this.that.value;\n                this.ctrlKey = e.ctrlKey;\n                this.cmdKey = e.metaKey;\n                this.shiftKey = e.shiftKey;\n\n                // keypress event overwrites meaningful value of e.keyCode\n                this.selection = getElementSelection(this.that);\n                if (e.type === 'keydown' || e.type === 'keyup') {\n                    this.kdCode = e.keyCode;\n                }\n                this.which = e.which;\n            }\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length);\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n        }, {\n            key: '_setPosition',\n            value: function _setPosition(pos, setReal) {\n                this._setSelection(pos, pos, setReal);\n            }\n        }, {\n            key: '_getBeforeAfter',\n            value: function _getBeforeAfter() {\n                var value = this.value;\n                //FIXME `this.selection` can sometimes be undefined, found why and fix it\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n        }, {\n            key: '_getBeforeAfterStripped',\n            value: function _getBeforeAfterStripped() {\n                var settingsClone = this.settingsClone;\n\n                var _getBeforeAfter2 = this._getBeforeAfter(),\n                    _getBeforeAfter3 = _slicedToArray(_getBeforeAfter2, 2),\n                    left = _getBeforeAfter3[0],\n                    right = _getBeforeAfter3[1];\n\n                left = autoStrip(left, this.settingsClone);\n                right = autoStrip(right, this.settingsClone);\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                }\n\n                settingsClone.trailingNegative = false;\n\n                return [left, right];\n            }\n\n            /**\n             * strip parts from excess characters and leading zeroes\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // prevents multiple leading zeros from being entered\n                left = autoStrip(left, settingsClone);\n\n                // if right is not empty and first character is not aDec,\n                right = autoStrip(right, settingsClone);\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n                if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                    if (right > '') {\n                        right = right.replace(/^0*(\\d)/, '$1');\n                    }\n                }\n\n                // insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.aDec) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right, advent) {\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _autoCheck = autoCheck(this.newValue, settingsClone),\n                    _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                    minTest = _autoCheck2[0],\n                    maxTest = _autoCheck2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.aNeg) {\n                        settingsClone.rawValue = '';\n                    } else {\n                        settingsClone.rawValue = testValue;\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.lZero === 'deny') {\n                        position = 0;\n                    }\n\n                    this.value = this.newValue;\n                    this._setPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * helper function for _expandSelectionOnSign\n             * returns sign position of a formatted value\n             */\n\n        }, {\n            key: '_signPosition',\n            value: function _signPosition() {\n                var settingsClone = this.settingsClone;\n                var aSign = settingsClone.aSign;\n                var that = this.that;\n\n                if (aSign) {\n                    var aSignLen = aSign.length;\n                    if (settingsClone.pSign === 'p') {\n                        var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                        return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - aSignLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                var signPosition = this._signPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getBeforeAfter4 = this._getBeforeAfter(),\n                        _getBeforeAfter5 = _slicedToArray(_getBeforeAfter4, 2),\n                        left = _getBeforeAfter5[0],\n                        right = _getBeforeAfter5[1];\n\n                    // try to strip pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                    if (!this._setValueParts(modifiedLeftPart, right, 'paste')) {\n                        this.value = oldParts.join('');\n                        this._setPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys\n             * If returns true, further processing is not performed\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                var kdCode = this.kdCode;\n                var which = this.which;\n                var ctrlKey = this.ctrlKey;\n                var cmdKey = this.cmdKey;\n\n                // catch the ctrl up on ctrl-v\n                var shiftKey = this.shiftKey;\n                if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                    this._checkPaste();\n                    return false;\n                }\n\n                // skip Fx keys, windows keys, other special keys\n                if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                    return true;\n                }\n\n                // if select all (a)\n                if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                    if (this.settings.sNumber) {\n                        // preventDefault is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var aSignLen = this.settings.aSign.length;\n                        var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                        var aSuffixLen = this.settings.aSuffix.length;\n                        var pSign = this.settings.pSign;\n                        var pNeg = this.settings.pNeg;\n\n                        var start = void 0;\n                        if (pSign === 's') {\n                            start = 0;\n                        } else {\n                            start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                        }\n\n                        var end = void 0;\n                        if (pSign === 'p') {\n                            end = valueLen - aSuffixLen;\n                        } else {\n                            switch (pNeg) {\n                                case 'l':\n                                    end = valueLen - (aSuffixLen + aSignLen);\n                                    break;\n                                case 'r':\n                                    end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                    break;\n                                default:\n                                    end = valueLen - (aSignLen + aSuffixLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // if copy (c)\n                if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // try to prevent wrong paste\n                    if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getBeforeAfter();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n                }\n\n                if (ctrlKey || cmdKey) {\n                    return true;\n                }\n\n                // jump over thousand separator\n                if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                    var aSep = this.settingsClone.aSep;\n                    var aDec = this.settingsClone.aDec;\n                    var startJump = this.selection.start;\n                    var value = this.that.value;\n                    if (e.type === 'keydown' && !this.shiftKey) {\n                        if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                            this._setPosition(startJump - 1);\n                        } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                            this._setPosition(startJump + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * process deletion of characters when the minus sign is to the right of the numeric characters\n             */\n\n        }, {\n            key: '_processTrailing',\n            value: function _processTrailing(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                    if (this.kdCode === 8) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripp = this._getBeforeAfterStripped();\n\n                    var _getBeforeAfterStripp2 = _slicedToArray(_getBeforeAfterStripp, 2);\n\n                    left = _getBeforeAfterStripp2[0];\n                    right = _getBeforeAfterStripp2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing2 = this._processTrailing([left, right]);\n\n                        var _processTrailing3 = _slicedToArray(_processTrailing2, 2);\n\n                        left = _processTrailing3[0];\n                        right = _processTrailing3[1];\n                    } else {\n                        if (this.kdCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripp3 = this._getBeforeAfterStripped();\n\n                    var _getBeforeAfterStripp4 = _slicedToArray(_getBeforeAfterStripp3, 2);\n\n                    left = _getBeforeAfterStripp4[0];\n                    right = _getBeforeAfterStripp4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if a processing is performed.\n             *\n             * @returns {boolean} //FIXME This always returns TRUE\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion() {\n                var settingsClone = this.settingsClone;\n                var cCode = String.fromCharCode(this.which);\n\n                var _getBeforeAfterStripp5 = this._getBeforeAfterStripped(),\n                    _getBeforeAfterStripp6 = _slicedToArray(_getBeforeAfterStripp5, 2),\n                    left = _getBeforeAfterStripp6[0],\n                    right = _getBeforeAfterStripp6[1];\n\n                settingsClone.throwInput = true;\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                    if (!settingsClone.mDec || !settingsClone.aDec) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before aNeg character\n                    if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.aDec)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.aDec) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.aDec) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.aDec, right, null);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                        if (left === '' && contains(right, settingsClone.aNeg)) {\n                            left = settingsClone.aNeg;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.aNeg + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.aNeg)) {\n                            left = settingsClone.aNeg;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.aNeg) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.aNeg + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right, null);\n\n                    return true;\n                }\n\n                // If try to insert digit before minus\n                if (cCode >= '0' && cCode <= '9') {\n                    if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                        left = settingsClone.aNeg + left;\n                    }\n\n                    this._setValueParts(left + cCode, right, null);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return true;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             */\n\n        }, {\n            key: '_formatQuick',\n            value: function _formatQuick(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n                var eventKeyCode = e.keyCode;\n\n                var _getBeforeAfterStripp7 = this._getBeforeAfterStripped(),\n                    _getBeforeAfterStripp8 = _slicedToArray(_getBeforeAfterStripp7, 1),\n                    left = _getBeforeAfterStripp8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                    var _leftLength$split = leftLength.split(settingsClone.aDec),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (contains(subParts, '-')) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = autoGroup(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                        leftAr.shift();\n\n                        if ((eventKeyCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || eventKeyCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.aSign.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (eventKeyCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                            // Place caret after prefix sign\n                            position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.aSign && settingsClone.pSign === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.aSign.length;\n                        }\n\n                        if (settingsClone.aSuffix) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.aSuffix.length;\n                        }\n                    }\n                }\n\n                this.that.value = value;\n                this._setPosition(position);\n                this.formatted = true;\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.wEmpty === 'focus') {\n            settings.onOff = true;\n\n            if (settings.nBracket !== null && settings.aNeg !== '') {\n                $this.val(negativeBracket(e.target.value, settings));\n            }\n\n            var result = void 0;\n            if (settings.eDec) {\n                settings.mDec = settings.eDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.mDec = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.nSep) {\n                settings.aSep = '';\n                settings.aSign = '';\n                settings.aSuffix = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if ((result = autoStrip(e.target.value, settings)) !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.wEmpty === 'focus') {\n                $this.val(onEmpty);\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        var currentKeyCode = key(e); // The key being used\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (e.keyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (currentKeyCode === keyCode.Backspace || currentKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatQuick(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeypress(holder, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        // Firefox fix for Shift && insert paste event\n        if (e.shiftKey && currentKeyCode === keyCode.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        //FIXME `_processCharacterInsertion()` always returns TRUE, which means `holder.formatted = false;` at the end is NEVER called.\n        if (holder._processCharacterInsertion()) {\n            holder._formatQuick(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                // If the value has not changed, we do not allow the input event to be sent\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onKeyup(holder, settings, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.aSign) {\n            if (holder.settingsClone.pSign === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n            }\n        } else if (currentKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.aSuffix || holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n            autoSave(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatQuick(e);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.onOff = false;\n\n            if (settings.aStor) {\n                autoSave(e.target, settings, 'set');\n            }\n\n            if (settings.nSep === true) {\n                settings.aSep = settings.oSep;\n                settings.aSign = settings.oSign;\n                settings.aSuffix = settings.oSuffix;\n            }\n\n            if (settings.eDec !== null) {\n                settings.mDec = settings.oDec;\n                settings.aPad = settings.oPad;\n                settings.nBracket = settings.oBracket;\n            }\n\n            value = autoStrip(value, settings);\n            if (value !== '') {\n                if (settings.trailingNegative) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _autoCheck3 = autoCheck(value, settings),\n                    _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                    minTest = _autoCheck4[0],\n                    maxTest = _autoCheck4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = fixNumber(value, settings);\n                    settings.rawValue = value;\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? +settings.scaleDecimal : settings.mDec;\n                    value = autoRound(value, settings);\n                    value = presentNumber(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.wEmpty === 'zero') {\n                    settings.rawValue = '0';\n                    value = autoRound('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = autoGroup(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     * @returns {*}\n     */\n    function onPaste($this, holder, e) {\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var oldRawValue = $this.autoNumeric('get');\n        var currentValue = e.target.value || '';\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var prefix = currentValue.substring(0, selectionStart);\n        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n        var pastedText = preparePastedText(e.clipboardData.getData('text/plain'), holder);\n\n        if (isValidPasteText(pastedText)) {\n            var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n            if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                $this.autoNumeric('set', newValue);\n                // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n                triggerEvent('input', e.target);\n                //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators, the decimal character, the negative sign/brackets, and the currency sign.\n            }\n        } else {\n            e.target.selectionStart = selectionEnd;\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param $this\n     * @param {AutoNumericHolder} holder\n     * @returns {*}\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unSetOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param $this\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param settings\n     * @param $input\n     * @param $this\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.aForm`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `anDefault` altogether.\n             */\n            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.eDec !== null && settings.aStor || settings.scaleDivisor && settings.aStor) {\n                        settings.rawValue = autoSave($this[0], settings, 'get');\n                    }\n\n                    // If the eDec value should NOT be saved in sessionStorage\n                    if (!settings.aStor) {\n                        var toStrip = void 0;\n\n                        if (settings.nBracket !== null && settings.aNeg !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.wEmpty) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.aSign);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.anDefault !== null) {\n                if (settings.anDefault === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `pNeg` option depending on `aSign` and `pSign`.\n     *\n     * If the user has not set the placement of the negative sign (`pNeg`), but has set a currency symbol (`aSign`),\n     * then we modify the default value of `pNeg` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({aSign: \"$\", pNeg: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({aSign: \"$\", pSign: \"s\", pNeg: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.pNeg) && options.aSign !== '') {\n            switch (settings.pSign) {\n                case 's':\n                    settings.pNeg = 'p';\n                    break;\n                case 'p':\n                    settings.pNeg = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyze and save the vMin and vMax integer size for later uses\n     *\n     * @param {object} settings\n     * @returns {{vMax: Array, vMin: Array}}\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$vMax$toStri = settings.vMax.toString().split('.'),\n            _settings$vMax$toStri2 = _slicedToArray(_settings$vMax$toStri, 1),\n            vMaxIntegerPart = _settings$vMax$toStri2[0];\n\n        var _ref3 = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            vMinIntegerPart = _ref4[0];\n\n        vMaxIntegerPart = vMaxIntegerPart.replace('-', '');\n        vMinIntegerPart = vMinIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(vMaxIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(vMinIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `mDec` as needed\n     *\n     * @param {object} settings\n     */\n    function correctMDecOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimal)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.mDec = settings.scaleDecimal;\n        } else if (isNull(settings.mDec)) {\n            settings.mDec = maximumVMinAndVMaxDecimalLength(settings.vMin, settings.vMax);\n            settings.oDec = String(settings.mDec);\n        }\n\n        // Most calculus assume `mDec` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.mDec = Number(settings.mDec);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.altDec) && Number(settings.mDec) > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for autoStrip\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(\\\\d)');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param $this\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // The settings are generated for the first time\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    onOff: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `pNeg` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign if needed\n            settings.aNeg = settings.vMin < 0 ? '-' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctMDecOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when eDec, scaleDivisor & nSep options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.aForm) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('focusout', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '}).\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var strip = $this.autoNumeric('get');\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getHolder($this, settings, true);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = autoGet(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n\n                value = fixNumber(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputType` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputType\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = autoGet(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputType);\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @return {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Check the validity of the `value` parameter\n        if (!isNumber(value)) {\n            throwError('A number is needed to be able to format it, [' + value + '] given.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (isNull(settings.mDec)) {\n            settings.mDec = maximumVMinAndVMaxDecimalLength(settings.vMin, settings.vMax);\n        }\n\n        // Basic tests to check if the given value is valid\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputType);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.');\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.');\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.');\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.');\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.');\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.');\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.');\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.');\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.');\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.');\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].');\n        }\n\n        if (!(isNull(options.mDec) || isInt(options.mDec) && options.mDec >= 0 || // If integer option\n        isString(options.mDec) && testPositiveInteger.test(options.mDec)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var vMinMaxDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.vMin, options.vMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.');\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.');\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.');\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.');\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.');\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.');\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.');\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputType) && !isInArray(options.outputType, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputType\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputType + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.');\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJzY2FsZVN5bWJvbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJpc1ZhbGlkUGFzdGVUZXh0IiwidGV4dCIsInByZXBhcmVQYXN0ZWRUZXh0IiwiaG9sZGVyIiwiYXV0b1N0cmlwIiwic2V0dGluZ3NDbG9uZSIsInJlcGxhY2UiLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkVycm9yIiwiaGFzRGVjaW1hbHMiLCJzcGxpdCIsImRlY2ltYWxQYXJ0IiwiZGVjaW1hbFBsYWNlcyIsImxlbmd0aCIsImtleSIsImV2ZW50Iiwid2hpY2giLCJnZXRFbGVtZW50U2VsZWN0aW9uIiwidGhhdCIsInBvc2l0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJmb2N1cyIsInNlbGVjdCIsImRvY3VtZW50Iiwic2VsZWN0aW9uIiwiY3JlYXRlUmFuZ2UiLCJtb3ZlU3RhcnQiLCJlbmQiLCJzdGFydCIsInNlbGVjdGlvbkVuZCIsInNldEVsZW1lbnRTZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwibW92ZUVuZCIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwid2FybmluZyIsInN1cHByZXNzV2FybmluZ3MiLCJjb25zb2xlIiwid2FybiIsInJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCIsIiR0aGlzIiwic2V0dGluZ3MiLCIkIiwiZWFjaCIsInZhbCIsImF1dG9OdW1lcmljIiwibWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCIsIk1hdGgiLCJtYXgiLCJza2lwRmlyc3RBdXRvU3RyaXAiLCJ0cmFpbGluZ05lZ2F0aXZlIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkQXV0b1N0cmlwIiwibWF0Y2giLCJudW1SZWdBdXRvU3RyaXAiLCJqb2luIiwiblNpZ24iLCJpbnRlZ2VyUGFydCIsIm1vZGlmaWVkSW50ZWdlclBhcnQiLCJhTmVnIiwibUludFBvcyIsImNoYXJBdCIsInNsaWNlIiwibUludE5lZyIsIm9uT2ZmIiwic3RyaXBSZWciLCJuZWdhdGl2ZUJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwicmVzdWx0IiwiTnVtYmVyIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpbnB1dFZhbHVlIiwic2lnbk9uRW1wdHkiLCJhdXRvR3JvdXAiLCJzdHJpcCIsImVtcHR5IiwiaXNOZWdhdGl2ZSIsImRpZ2l0YWxHcm91cCIsInRlc3QiLCJzdWJzdHJpbmciLCJyYXdWYWx1ZSIsInRydW5jYXRlWmVyb3MiLCJyb3VuZGVkSW5wdXRWYWx1ZSIsInJEZWMiLCJyZWdleCIsIlJlZ0V4cCIsImF1dG9Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwiaXZSb3VuZGVkIiwiZFBvcyIsImlucHV0VmFsdWVIYXNBRG90IiwidmRQb3MiLCJjRGVjIiwiemVyb3MiLCJyTGVuZ3RoIiwidFJvdW5kIiwib2RkIiwiaXZBcnJheSIsInRydW5jYXRlRGVjaW1hbCIsInBhc3RlIiwibW9kaWZpZWREZWNpbWFsUGFydCIsInBhcnNlU3RyIiwibkwiLCJzZWFyY2giLCJ0ZXN0TWluTWF4IiwieGMiLCJ5YyIsInhOZWciLCJhdXRvQ2hlY2siLCJtaW5QYXJzZSIsIm1heFBhcnNlIiwidmFsUGFyc2UiLCJhdXRvR2V0IiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weSIsIm9EZWMiLCJvUGFkIiwib0JyYWNrZXQiLCJvU2VwIiwib1NpZ24iLCJvU3VmZml4IiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImF1dG9TYXZlIiwiZWxlbWVudCIsInRvRG8iLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsImZvcm1hdHRlZCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwic2V0UmVhbCIsIm1pbiIsInBvcyIsIl9zZXRTZWxlY3Rpb24iLCJsZWZ0IiwicmlnaHQiLCJfZ2V0QmVmb3JlQWZ0ZXIiLCJuZXdWYWx1ZSIsImFOZWdSZWdBdXRvU3RyaXAiLCJhZHZlbnQiLCJwYXJ0cyIsIl9ub3JtYWxpemVQYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwiX3NldFBvc2l0aW9uIiwidHJpZ2dlciIsImFTaWduTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJzaWduUG9zaXRpb24iLCJfc2lnblBvc2l0aW9uIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0Iiwic3Vic3RyIiwiX3NldFZhbHVlUGFydHMiLCJfY2hlY2tQYXN0ZSIsInByZXZlbnREZWZhdWx0IiwibmVnTGVuIiwiYVN1ZmZpeExlbiIsIl9leHBhbmRTZWxlY3Rpb25PblNpZ24iLCJzdGFydEp1bXAiLCJjYXJldEZpeCIsIl9nZXRCZWZvcmVBZnRlclN0cmlwcGVkIiwidGhyb3dJbnB1dCIsIl9wcm9jZXNzVHJhaWxpbmciLCJjQ29kZSIsImZyb21DaGFyQ29kZSIsImxlZnRMZW5ndGgiLCJldmVudEtleUNvZGUiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiaW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwiaW5BcnJheSIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJpcyIsInRhcmdldCIsInZhbHVlT25Gb2N1cyIsImxhc3RWYWwiLCJvbkVtcHR5Iiwib25LZXlkb3duIiwiY3VycmVudEtleUNvZGUiLCJyZWFkT25seSIsInByb2Nlc3NlZCIsInRyaWdnZXJFdmVudCIsIl91cGRhdGVGaWVsZFByb3BlcnRpZXMiLCJfc2tpcEFsd2F5cyIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24iLCJfZm9ybWF0UXVpY2siLCJvbktleXByZXNzIiwiX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24iLCJvbktleXVwIiwic2tpcCIsIm9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlIiwib3JpZ1ZhbHVlIiwiZ3JvdXBlZFZhbHVlIiwiY2hhbmdlIiwib25QYXN0ZSIsIm9sZFJhd1ZhbHVlIiwiY3VycmVudFZhbHVlIiwicHJlZml4Iiwic3VmZml4IiwicGFzdGVkVGV4dCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidmFsdWVPZiIsIm9uQmx1ciIsIm9uU3VibWl0IiwiY2xvc2VzdCIsIm9uIiwiJHNldHRpbmdzIiwiZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUiLCIkaW5wdXQiLCJjdXJyZW50RWxlbWVudFRhZyIsImZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQiLCJzZXRWYWx1ZSIsImF0dHIiLCJ0ZXN0ZWRDdXJyZW50VmFsdWUiLCJJbmZpbml0eSIsImlzTnVtZXJpYyIsInRvU3RyaXAiLCJ0YWdMaXN0IiwiY29ycmVjdFBOZWdPcHRpb24iLCJvcHRpb25zIiwiY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMiLCJ2TWF4SW50ZWdlclBhcnQiLCJ2TWluSW50ZWdlclBhcnQiLCJjb3JyZWN0TURlY09wdGlvbiIsInNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIiLCJjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyIsImFOZWdSZWciLCJhbGxvd2VkIiwidHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzIiwiZ2V0SW5pdGlhbFNldHRpbmdzIiwiZXh0ZW5kIiwidGFnRGF0YSIsInJ1bk9uY2UiLCJtZXRob2RzIiwiaW5pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJmbiIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluTWF4RGVjaW1hbFBsYWNlcyIsImlzVmFsaWQiLCJlcnJvciIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJwYXJhbXMiLCJldnQiLCJFdmVudCIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7O0FBRUE7QUFDQSxJQUFJQSxtQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBO0FBQ0E7OztBQUdBLElBQU1DLGlCQUFpQixDQUNuQixHQURtQixFQUVuQixTQUZtQixFQUduQixNQUhtQixFQUluQixNQUptQixFQUtuQixPQUxtQixFQU1uQixJQU5tQixFQU9uQixLQVBtQixFQVFuQixLQVJtQixFQVNuQixLQVRtQixFQVVuQixJQVZtQixFQVduQixJQVhtQixFQVluQixJQVptQixFQWFuQixJQWJtQixFQWNuQixJQWRtQixFQWVuQixJQWZtQixFQWdCbkIsSUFoQm1CLEVBaUJuQixJQWpCbUIsRUFrQm5CLEtBbEJtQixFQW1CbkIsS0FuQm1CLEVBb0JuQixPQXBCbUIsRUFxQm5CLElBckJtQixFQXNCbkIsUUF0Qm1CLEVBdUJuQixRQXZCbUIsRUF3Qm5CLEdBeEJtQixFQXlCbkIsR0F6Qm1CLEVBMEJuQixHQTFCbUIsRUEyQm5CLFFBM0JtQixFQTRCbkIsTUE1Qm1CLEVBNkJuQixRQTdCbUIsRUE4Qm5CLElBOUJtQixFQStCbkIsSUEvQm1CLEVBZ0NuQixHQWhDbUIsQ0FBdkI7O0FBbUNBOzs7Ozs7QUFNQSxJQUFNQyxrQkFBa0I7QUFDcEI7Ozs7Ozs7O0FBUUFDLFVBQU0sR0FUYzs7QUFXcEI7Ozs7QUFJQUMsVUFBTSxLQWZjOztBQWlCcEI7Ozs7OztBQU1BQyxZQUFRLEdBdkJZOztBQXlCcEI7Ozs7QUFJQUMsVUFBTSxHQTdCYzs7QUErQnBCOzs7O0FBSUFDLFlBQVEsSUFuQ1k7O0FBcUNwQjs7Ozs7QUFLQUMsV0FBTyxFQTFDYTs7QUE0Q3BCOzs7O0FBSUFDLFdBQU8sR0FoRGE7O0FBa0RwQjs7Ozs7Ozs7OztBQVVBQyxVQUFNLEdBNURjOztBQThEcEI7Ozs7QUFJQUMsYUFBUyxFQWxFVzs7QUFvRXBCOzs7OztBQUtBQyxhQUFTLElBekVXOztBQTJFcEI7Ozs7QUFJQUMsVUFBTSxrQkEvRWMsRUErRU07O0FBRTFCOzs7O0FBSUFDLFVBQU0sbUJBckZjLEVBcUZPOztBQUUzQjs7QUFFQUMsVUFBTSxJQXpGYzs7QUEyRnBCOzs7O0FBSUFDLFVBQU0sSUEvRmM7O0FBaUdwQjs7Ozs7OztBQU9BOzs7OztBQUtBQyxrQkFBYyxJQTdHTTs7QUErR3BCOzs7O0FBSUFDLGtCQUFjLElBbkhNOztBQXFIcEI7Ozs7QUFJQUMsaUJBQWEsSUF6SE87O0FBMkhwQjs7O0FBR0FDLFdBQU8sS0E5SGE7O0FBZ0lwQjs7Ozs7Ozs7Ozs7Ozs7QUFjQUMsWUFBUSxHQTlJWTs7QUFnSnBCOzs7Ozs7O0FBT0FDLFVBQU0sSUF2SmM7O0FBeUpwQjs7Ozs7O0FBTUFDLGNBQVUsSUEvSlU7O0FBaUtwQjs7Ozs7O0FBTUE7QUFDQUMsWUFBUSxPQXhLWTs7QUEwS3BCOzs7OztBQUtBQyxXQUFPLE1BL0thOztBQWlMcEI7Ozs7QUFJQUMsV0FBTyxJQXJMYTs7QUF1THBCOzs7O0FBSUFDLGFBQVMsS0EzTFc7O0FBNkxwQjs7Ozs7O0FBTUFDLGVBQVcsSUFuTVM7O0FBcU1wQjs7OztBQUlBQyxtQkFBZSxLQXpNSzs7QUEyTXBCOzs7Ozs7O0FBT0FDLGdCQUFZLElBbE5ROztBQW9OcEI7Ozs7QUFJQUMsV0FBTztBQXhOYSxDQUF4Qjs7QUEyTkE7OztBQUdBLElBQU1DLFVBQVU7QUFDWkMsZUFBZ0IsQ0FESjtBQUVaQyxTQUFnQixDQUZKO0FBR1pDLFdBQWdCLEVBSEo7QUFJWkMsV0FBZ0IsRUFKSjtBQUtaQyxVQUFnQixFQUxKO0FBTVpDLFNBQWdCLEVBTko7QUFPWkMsZ0JBQWdCLEVBUEo7QUFRWkMsY0FBZ0IsRUFSSjtBQVNaQyxTQUFnQixFQVRKO0FBVVpDLFdBQWdCLEVBVko7QUFXWkMsWUFBZ0IsRUFYSjtBQVlaQyxjQUFnQixFQVpKO0FBYVpDLFNBQWdCLEVBYko7QUFjWkMsVUFBZ0IsRUFkSjtBQWVaQyxlQUFnQixFQWZKO0FBZ0JaQyxhQUFnQixFQWhCSjtBQWlCWkMsZ0JBQWdCLEVBakJKO0FBa0JaQyxlQUFnQixFQWxCSjtBQW1CWkMsWUFBZ0IsRUFuQko7QUFvQlpDLFlBQWdCLEVBcEJKO0FBcUJaQyxVQUFnQixFQXJCSjtBQXNCWkMsVUFBZ0IsRUF0Qko7QUF1QlpDLFVBQWdCLEVBdkJKO0FBd0JaQyxVQUFnQixFQXhCSjtBQXlCWkMsVUFBZ0IsRUF6Qko7QUEwQlpDLFVBQWdCLEVBMUJKO0FBMkJaQyxVQUFnQixFQTNCSjtBQTRCWkMsVUFBZ0IsRUE1Qko7QUE2QlpDLFVBQWdCLEVBN0JKO0FBOEJaQyxVQUFnQixFQTlCSjtBQStCWkMsT0FBZ0IsRUEvQko7QUFnQ1pDLE9BQWdCLEVBaENKO0FBaUNaQyxPQUFnQixFQWpDSjtBQWtDWkMsT0FBZ0IsRUFsQ0o7QUFtQ1pDLE9BQWdCLEVBbkNKO0FBb0NaQyxPQUFnQixFQXBDSjtBQXFDWkMsT0FBZ0IsRUFyQ0o7QUFzQ1pDLE9BQWdCLEVBdENKO0FBdUNaQyxPQUFnQixFQXZDSjtBQXdDWkMsT0FBZ0IsRUF4Q0o7QUF5Q1pDLE9BQWdCLEVBekNKO0FBMENaQyxPQUFnQixFQTFDSjtBQTJDWkMsT0FBZ0IsRUEzQ0o7QUE0Q1pDLE9BQWdCLEVBNUNKO0FBNkNaQyxPQUFnQixFQTdDSjtBQThDWkMsT0FBZ0IsRUE5Q0o7QUErQ1pDLE9BQWdCLEVBL0NKO0FBZ0RaQyxPQUFnQixFQWhESjtBQWlEWkMsT0FBZ0IsRUFqREo7QUFrRFpDLE9BQWdCLEVBbERKO0FBbURaQyxPQUFnQixFQW5ESjtBQW9EWkMsT0FBZ0IsRUFwREo7QUFxRFpDLE9BQWdCLEVBckRKO0FBc0RaQyxPQUFnQixFQXRESjtBQXVEWkMsT0FBZ0IsRUF2REo7QUF3RFpDLE9BQWdCLEVBeERKO0FBeURaQyxhQUFnQixFQXpESjtBQTBEWkMsZ0JBQWdCLEVBMURKO0FBMkRaQyxhQUFnQixFQTNESjtBQTREWkMsYUFBZ0IsRUE1REo7QUE2RFpDLGFBQWdCLEVBN0RKO0FBOERaQyxhQUFnQixFQTlESjtBQStEWkMsYUFBZ0IsR0EvREo7QUFnRVpDLGFBQWdCLEdBaEVKO0FBaUVaQyxhQUFnQixHQWpFSjtBQWtFWkMsYUFBZ0IsR0FsRUo7QUFtRVpDLGFBQWdCLEdBbkVKO0FBb0VaQyxhQUFnQixHQXBFSjtBQXFFWkMsb0JBQWdCLEdBckVKO0FBc0VaQyxnQkFBZ0IsR0F0RUo7QUF1RVpDLGlCQUFnQixHQXZFSjtBQXdFWkMsZUFBZ0IsR0F4RUo7QUF5RVpDLGlCQUFnQixHQXpFSjtBQTBFWkMsUUFBZ0IsR0ExRUo7QUEyRVpDLFFBQWdCLEdBM0VKO0FBNEVaQyxRQUFnQixHQTVFSjtBQTZFWkMsUUFBZ0IsR0E3RUo7QUE4RVpDLFFBQWdCLEdBOUVKO0FBK0VaQyxRQUFnQixHQS9FSjtBQWdGWkMsUUFBZ0IsR0FoRko7QUFpRlpDLFFBQWdCLEdBakZKO0FBa0ZaQyxRQUFnQixHQWxGSjtBQW1GWkMsU0FBZ0IsR0FuRko7QUFvRlpDLFNBQWdCLEdBcEZKO0FBcUZaQyxTQUFnQixHQXJGSjtBQXNGWkMsYUFBZ0IsR0F0Rko7QUF1RlpDLGdCQUFnQixHQXZGSjtBQXdGWkMsZ0JBQWdCLEdBeEZKO0FBeUZaQyxrQkFBZ0IsR0F6Rko7QUEwRlpDLGVBQWdCLEdBMUZKO0FBMkZaQyxXQUFnQixHQTNGSjtBQTRGWkMsV0FBZ0IsR0E1Rko7QUE2RlpDLFlBQWdCLEdBN0ZKO0FBOEZaQyxTQUFnQixHQTlGSjtBQStGWkMsV0FBZ0IsR0EvRko7QUFnR1pDLGVBQWdCLEdBaEdKO0FBaUdaQyxpQkFBZ0IsR0FqR0o7QUFrR1pDLGVBQWdCLEdBbEdKO0FBbUdaQyxrQkFBZ0IsR0FuR0o7QUFvR1pDLFdBQWdCLEdBcEdKO0FBcUdaQyxhQUFnQjtBQXJHSixDQUFoQjs7QUF5R0MsV0FBU0MsT0FBVCxFQUFrQjtBQUNmO0FBQ0osUUFBSSxJQUFKLEVBQWdEO0FBQzVDO0FBQ0FDLFFBQUEsaUNBQU8sQ0FBQyxzQkFBRCxDQUFQLG9DQUFtQkQsT0FBbkI7QUFDSCxLQUhELE1BR08sSUFBSSxRQUFPRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxPQUFPQyxPQUF6QyxFQUFrRDtBQUNyRDtBQUNBRCxlQUFPQyxPQUFQLEdBQWlCSCxRQUFRSSxRQUFRLFFBQVIsQ0FBUixDQUFqQjtBQUNILEtBSE0sTUFHQTtBQUNIO0FBQ0FKLGdCQUFRSyxPQUFPQyxNQUFmO0FBQ0g7QUFDQSxDQVpBLEVBWUMsYUFBSztBQUNIOztBQUVBOzs7Ozs7O0FBT0EsYUFBU0MsTUFBVCxDQUFnQkMsS0FBaEIsRUFBdUI7QUFDbkIsZUFBT0EsVUFBVSxJQUFqQjtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0MsV0FBVCxDQUFxQkQsS0FBckIsRUFBNEI7QUFDeEIsZUFBT0EsVUFBVSxLQUFLLENBQXRCO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVNFLHdCQUFULENBQWtDRixLQUFsQyxFQUF5QztBQUNyQyxlQUFPQSxVQUFVLElBQVYsSUFBa0JBLFVBQVUsS0FBSyxDQUFqQyxJQUF1QyxPQUFPQSxLQUFyRDtBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTRyxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNuQixlQUFRLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCQSxlQUFlQyxNQUFsRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0MsU0FBVCxDQUFtQk4sS0FBbkIsRUFBMEI7QUFDdEIsZUFBTyxPQUFPQSxLQUFQLEtBQWtCLFNBQXpCO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTTyxtQkFBVCxDQUE2QlAsS0FBN0IsRUFBb0M7QUFDaEMsWUFBTVEsaUJBQWlCSCxPQUFPTCxLQUFQLEVBQWNTLFdBQWQsRUFBdkI7QUFDQSxlQUFPRCxtQkFBbUIsTUFBbkIsSUFBNkJBLG1CQUFtQixPQUF2RDtBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTRSxRQUFULENBQWtCQyxTQUFsQixFQUE2QjtBQUN6QixlQUFPLFFBQU9BLFNBQVAseUNBQU9BLFNBQVAsT0FBcUIsUUFBckIsSUFBaUNBLGNBQWMsSUFBL0MsSUFBdUQsQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixTQUFkLENBQS9EO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTRyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUNyQixhQUFLLElBQU1DLElBQVgsSUFBbUJELEdBQW5CLEVBQXdCO0FBQ3BCLGdCQUFJQSxJQUFJRSxjQUFKLENBQW1CRCxJQUFuQixDQUFKLEVBQThCO0FBQzFCLHVCQUFPLEtBQVA7QUFDSDtBQUNKO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVNFLFFBQVQsQ0FBa0JwRixDQUFsQixFQUFxQjtBQUNqQixlQUFPLENBQUMrRSxRQUFRL0UsQ0FBUixDQUFELElBQWUsQ0FBQ3FGLE1BQU1DLFdBQVd0RixDQUFYLENBQU4sQ0FBaEIsSUFBd0N1RixTQUFTdkYsQ0FBVCxDQUEvQztBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTd0YsS0FBVCxDQUFleEYsQ0FBZixFQUFrQjtBQUNkLGVBQU8sT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUJzRixXQUFXdEYsQ0FBWCxNQUFrQnlGLFNBQVN6RixDQUFULEVBQVksRUFBWixDQUEzQyxJQUE4RCxDQUFDcUYsTUFBTXJGLENBQU4sQ0FBdEU7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBUzBGLGdCQUFULENBQTBCQyxJQUExQixFQUFnQztBQUM1QixlQUFPQSxTQUFTLEVBQVQsSUFBZSxDQUFDTixNQUFNTSxJQUFOLENBQXZCO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTQyxpQkFBVCxDQUEyQkQsSUFBM0IsRUFBaUNFLE1BQWpDLEVBQXlDO0FBQ3JDLGVBQU9DLFVBQVVILElBQVYsRUFBZ0JFLE9BQU9FLGFBQXZCLEVBQXNDQyxPQUF0QyxDQUE4Q0gsT0FBT0UsYUFBUCxDQUFxQnJLLElBQW5FLEVBQXlFLEdBQXpFLENBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQSxhQUFTdUssUUFBVCxDQUFrQjNCLEdBQWxCLEVBQXVCNEIsTUFBdkIsRUFBK0I7QUFDM0IsWUFBSSxDQUFDN0IsU0FBU0MsR0FBVCxDQUFELElBQWtCLENBQUNELFNBQVM2QixNQUFULENBQW5CLElBQXVDNUIsUUFBUSxFQUEvQyxJQUFxRDRCLFdBQVcsRUFBcEUsRUFBd0U7QUFDcEUsbUJBQU8sS0FBUDtBQUNIOztBQUVELGVBQU81QixJQUFJNkIsT0FBSixDQUFZRCxNQUFaLE1BQXdCLENBQUMsQ0FBaEM7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLGFBQVNFLFNBQVQsQ0FBbUJGLE1BQW5CLEVBQTJCRyxLQUEzQixFQUFrQztBQUM5QixZQUFJLENBQUN0QixRQUFRc0IsS0FBUixDQUFELElBQW1CQSxVQUFVLEVBQTdCLElBQW1DbEMsWUFBWStCLE1BQVosQ0FBdkMsRUFBNEQ7QUFDeEQsbUJBQU8sS0FBUDtBQUNIOztBQUVELGVBQU9HLE1BQU1GLE9BQU4sQ0FBY0QsTUFBZCxNQUEwQixDQUFDLENBQWxDO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTbkIsT0FBVCxDQUFpQnVCLEdBQWpCLEVBQXNCO0FBQ2xCLFlBQUlDLE9BQU9DLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQixFQUEvQixNQUF1QyxnQkFBM0MsRUFBNkQ7QUFBRTtBQUMzRDtBQUNBLG1CQUFPNUIsTUFBTUMsT0FBTixDQUFjdUIsR0FBZCxLQUF1QixRQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBZixJQUEyQkMsT0FBT0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixHQUEvQixNQUF3QyxnQkFBakc7QUFDSCxTQUhELE1BSUs7QUFDRCxrQkFBTSxJQUFJSyxLQUFKLENBQVUsMkNBQVYsQ0FBTixDQURDLENBQzZEO0FBQ2pFO0FBQ0o7O0FBRUQ7Ozs7OztBQU1BLGFBQVNDLFdBQVQsQ0FBcUJ0QyxHQUFyQixFQUEwQjtBQUFBLHlCQUNFQSxJQUFJdUMsS0FBSixDQUFVLEdBQVYsQ0FERjtBQUFBO0FBQUEsWUFDYkMsV0FEYTs7QUFFdEIsZUFBTyxDQUFDM0MsWUFBWTJDLFdBQVosQ0FBUjtBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTQyxhQUFULENBQXVCekMsR0FBdkIsRUFBNEI7QUFBQSwwQkFDQUEsSUFBSXVDLEtBQUosQ0FBVSxHQUFWLENBREE7QUFBQTtBQUFBLFlBQ2ZDLFdBRGU7O0FBRXhCLFlBQUksQ0FBQzNDLFlBQVkyQyxXQUFaLENBQUwsRUFBK0I7QUFDM0IsbUJBQU9BLFlBQVlFLE1BQW5CO0FBQ0g7O0FBRUQsZUFBTyxDQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVNDLEdBQVQsQ0FBYUMsS0FBYixFQUFvQjtBQUNoQixlQUFRLE9BQU9BLE1BQU1DLEtBQWIsS0FBdUIsV0FBeEIsR0FBcUNELE1BQU05SixPQUEzQyxHQUFtRDhKLE1BQU1DLEtBQWhFO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVNDLG1CQUFULENBQTZCQyxJQUE3QixFQUFtQztBQUMvQixZQUFNQyxXQUFXLEVBQWpCO0FBQ0EsWUFBSW5ELFlBQVlrRCxLQUFLRSxjQUFqQixDQUFKLEVBQXNDO0FBQ2xDRixpQkFBS0csS0FBTDtBQUNBLGdCQUFNQyxTQUFTQyxTQUFTQyxTQUFULENBQW1CQyxXQUFuQixFQUFmO0FBQ0FOLHFCQUFTTixNQUFULEdBQWtCUyxPQUFPOUIsSUFBUCxDQUFZcUIsTUFBOUI7QUFDQVMsbUJBQU9JLFNBQVAsQ0FBaUIsV0FBakIsRUFBOEIsQ0FBQ1IsS0FBS25ELEtBQUwsQ0FBVzhDLE1BQTFDO0FBQ0FNLHFCQUFTUSxHQUFULEdBQWVMLE9BQU85QixJQUFQLENBQVlxQixNQUEzQjtBQUNBTSxxQkFBU1MsS0FBVCxHQUFpQlQsU0FBU1EsR0FBVCxHQUFlUixTQUFTTixNQUF6QztBQUNILFNBUEQsTUFPTztBQUNITSxxQkFBU1MsS0FBVCxHQUFpQlYsS0FBS0UsY0FBdEI7QUFDQUQscUJBQVNRLEdBQVQsR0FBZVQsS0FBS1csWUFBcEI7QUFDQVYscUJBQVNOLE1BQVQsR0FBa0JNLFNBQVNRLEdBQVQsR0FBZVIsU0FBU1MsS0FBMUM7QUFDSDs7QUFFRCxlQUFPVCxRQUFQO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVNXLG1CQUFULENBQTZCWixJQUE3QixFQUFtQ1UsS0FBbkMsRUFBMENELEdBQTFDLEVBQStDO0FBQzNDLFlBQUkzRCxZQUFZa0QsS0FBS0UsY0FBakIsQ0FBSixFQUFzQztBQUNsQ0YsaUJBQUtHLEtBQUw7QUFDQSxnQkFBTVUsUUFBUWIsS0FBS2MsZUFBTCxFQUFkO0FBQ0FELGtCQUFNRSxRQUFOLENBQWUsSUFBZjtBQUNBRixrQkFBTUcsT0FBTixDQUFjLFdBQWQsRUFBMkJQLEdBQTNCO0FBQ0FJLGtCQUFNTCxTQUFOLENBQWdCLFdBQWhCLEVBQTZCRSxLQUE3QjtBQUNBRyxrQkFBTVQsTUFBTjtBQUNILFNBUEQsTUFPTztBQUNISixpQkFBS0UsY0FBTCxHQUFzQlEsS0FBdEI7QUFDQVYsaUJBQUtXLFlBQUwsR0FBb0JGLEdBQXBCO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7QUFLQSxhQUFTUSxVQUFULENBQW9CQyxPQUFwQixFQUE2QjtBQUN6QixjQUFNLElBQUk1QixLQUFKLENBQVU0QixPQUFWLENBQU47QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBU0MsT0FBVCxDQUFpQkQsT0FBakIsRUFBb0Q7QUFBQSxZQUExQkUsZ0JBQTBCLHVFQUFQLEtBQU87O0FBQ2hELFlBQUlBLGdCQUFKLEVBQXNCO0FBQ2xCO0FBQ0FDLG9CQUFRQyxJQUFSLGVBQXlCSixPQUF6QjtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7Ozs7Ozs7O0FBUUEsYUFBU0ssb0NBQVQsQ0FBOENDLEtBQTlDLEVBQXFEQyxRQUFyRCxFQUErRDtBQUMzRDtBQUNBQyxVQUFFQyxJQUFGLENBQU9GLFFBQVAsRUFBaUIsVUFBQ2pKLENBQUQsRUFBSW9KLEdBQUosRUFBWTtBQUN6QixnQkFBSSxPQUFPQSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDM0JILHlCQUFTakosQ0FBVCxJQUFjb0osSUFBSUosS0FBSixFQUFXQyxRQUFYLEVBQXFCakosQ0FBckIsQ0FBZDtBQUNILGFBRkQsTUFFTyxJQUFJLE9BQU9nSixNQUFNSyxXQUFOLENBQWtCRCxHQUFsQixDQUFQLEtBQWtDLFVBQXRDLEVBQWtEO0FBQ3JEO0FBQ0FILHlCQUFTakosQ0FBVCxJQUFjZ0osTUFBTUssV0FBTixDQUFrQkQsR0FBbEIsRUFBdUJKLEtBQXZCLEVBQThCQyxRQUE5QixFQUF3Q2pKLENBQXhDLENBQWQ7QUFDSDtBQUNKLFNBUEQ7QUFRSDs7QUFFRDs7O0FBR0EsYUFBU3NKLCtCQUFULENBQXlDak4sSUFBekMsRUFBK0NELElBQS9DLEVBQXFEO0FBQ2pELGVBQU9tTixLQUFLQyxHQUFMLENBQVN0QyxjQUFjN0ssSUFBZCxDQUFULEVBQThCNkssY0FBYzlLLElBQWQsQ0FBOUIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBUzZKLFNBQVQsQ0FBbUJ6RixDQUFuQixFQUFzQnlJLFFBQXRCLEVBQWdDO0FBQzVCLFlBQUlBLFNBQVNsTixLQUFULEtBQW1CLEVBQXZCLEVBQTJCO0FBQ3ZCO0FBQ0F5RSxnQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVThDLFNBQVNsTixLQUFuQixFQUEwQixFQUExQixDQUFKO0FBQ0g7QUFDRCxZQUFJa04sU0FBUy9NLE9BQWIsRUFBc0I7QUFDbEI7QUFDQSxtQkFBT2tLLFNBQVM1RixDQUFULEVBQVl5SSxTQUFTL00sT0FBckIsQ0FBUCxFQUFzQztBQUNsQ3NFLG9CQUFJQSxFQUFFMkYsT0FBRixDQUFVOEMsU0FBUy9NLE9BQW5CLEVBQTRCLEVBQTVCLENBQUo7QUFDSDtBQUNKOztBQUVEO0FBQ0FzRSxZQUFJQSxFQUFFMkYsT0FBRixDQUFVOEMsU0FBU1Esa0JBQW5CLEVBQXVDLE1BQXZDLENBQUo7O0FBRUEsWUFBSSxDQUFDUixTQUFTaE4sSUFBVCxLQUFrQixHQUFsQixJQUEwQmdOLFNBQVNqTixLQUFULEtBQW1CLEdBQW5CLElBQTBCaU4sU0FBU2hOLElBQVQsS0FBa0IsR0FBdkUsS0FBZ0ZtSyxTQUFTNUYsQ0FBVCxFQUFZLEdBQVosQ0FBaEYsSUFBb0dBLE1BQU0sRUFBOUcsRUFBa0g7QUFDOUd5SSxxQkFBU1MsZ0JBQVQsR0FBNEIsSUFBNUI7QUFDSDs7QUFFRDtBQUNBbEosWUFBSUEsRUFBRTJGLE9BQUYsQ0FBVThDLFNBQVNVLGlCQUFuQixFQUFzQyxJQUF0QyxDQUFKOztBQUVBO0FBQ0FuSixZQUFJQSxFQUFFMkYsT0FBRixDQUFVOEMsU0FBU1csZ0JBQW5CLEVBQXFDLEVBQXJDLENBQUo7QUFDQSxZQUFJWCxTQUFTbk4sTUFBYixFQUFxQjtBQUNqQjBFLGdCQUFJQSxFQUFFMkYsT0FBRixDQUFVOEMsU0FBU25OLE1BQW5CLEVBQTJCbU4sU0FBU3BOLElBQXBDLENBQUo7QUFDSDs7QUFFRDtBQUNBLFlBQU1xRSxJQUFJTSxFQUFFcUosS0FBRixDQUFRWixTQUFTYSxlQUFqQixDQUFWO0FBQ0F0SixZQUFJTixJQUFJLENBQUNBLEVBQUUsQ0FBRixDQUFELEVBQU9BLEVBQUUsQ0FBRixDQUFQLEVBQWFBLEVBQUUsQ0FBRixDQUFiLEVBQW1CNkosSUFBbkIsQ0FBd0IsRUFBeEIsQ0FBSixHQUFrQyxFQUF0Qzs7QUFFQSxZQUFJZCxTQUFTak0sS0FBVCxLQUFtQixPQUFuQixJQUE4QmlNLFNBQVNqTSxLQUFULEtBQW1CLE1BQXJELEVBQTZEO0FBQ3pELGdCQUFJZ04sUUFBUSxFQUFaOztBQUR5RCwyQkFFdEJ4SixFQUFFd0csS0FBRixDQUFRaUMsU0FBU3BOLElBQWpCLENBRnNCO0FBQUE7QUFBQSxnQkFFbERvTyxXQUZrRDtBQUFBLGdCQUVyQ2hELFdBRnFDOztBQUd6RCxnQkFBSWlELHNCQUFzQkQsV0FBMUI7QUFDQSxnQkFBSTdELFNBQVM4RCxtQkFBVCxFQUE4QmpCLFNBQVNrQixJQUF2QyxDQUFKLEVBQWtEO0FBQzlDSCx3QkFBUWYsU0FBU2tCLElBQWpCO0FBQ0FELHNDQUFzQkEsb0JBQW9CL0QsT0FBcEIsQ0FBNEI4QyxTQUFTa0IsSUFBckMsRUFBMkMsRUFBM0MsQ0FBdEI7QUFDSDs7QUFFRDtBQUNBLGdCQUFJSCxVQUFVLEVBQVYsSUFBZ0JFLG9CQUFvQi9DLE1BQXBCLEdBQTZCOEIsU0FBU21CLE9BQXRELElBQWlFRixvQkFBb0JHLE1BQXBCLENBQTJCLENBQTNCLE1BQWtDLEdBQXZHLEVBQTRHO0FBQ3hHSCxzQ0FBc0JBLG9CQUFvQkksS0FBcEIsQ0FBMEIsQ0FBMUIsQ0FBdEI7QUFDSDs7QUFFRDtBQUNBLGdCQUFJTixVQUFVLEVBQVYsSUFBZ0JFLG9CQUFvQi9DLE1BQXBCLEdBQTZCOEIsU0FBU3NCLE9BQXRELElBQWlFTCxvQkFBb0JHLE1BQXBCLENBQTJCLENBQTNCLE1BQWtDLEdBQXZHLEVBQTRHO0FBQ3hHSCxzQ0FBc0JBLG9CQUFvQkksS0FBcEIsQ0FBMEIsQ0FBMUIsQ0FBdEI7QUFDSDs7QUFFRDlKLHFCQUFPd0osS0FBUCxHQUFlRSxtQkFBZixJQUFxQzVGLFlBQVkyQyxXQUFaLElBQXlCLEVBQXpCLEdBQTRCZ0MsU0FBU3BOLElBQVQsR0FBZ0JvTCxXQUFqRjtBQUNIOztBQUVELFlBQUtnQyxTQUFTdUIsS0FBVCxJQUFrQnZCLFNBQVNqTSxLQUFULEtBQW1CLE1BQXRDLElBQ0MsQ0FBQ2lNLFNBQVN1QixLQUFWLElBQW1CdkIsU0FBU2pNLEtBQVQsS0FBbUIsT0FEM0MsRUFDcUQ7QUFDakR3RCxnQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVThDLFNBQVN3QixRQUFuQixFQUE2QixNQUE3QixDQUFKO0FBQ0g7O0FBRUQsZUFBT2pLLENBQVA7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLGFBQVNrSyxlQUFULENBQXlCbEssQ0FBekIsRUFBNEJ5SSxRQUE1QixFQUFzQztBQUNsQyxZQUFLQSxTQUFTak4sS0FBVCxLQUFtQixHQUFuQixJQUEwQmlOLFNBQVNoTixJQUFULEtBQWtCLEdBQTdDLElBQXNEZ04sU0FBU2pOLEtBQVQsS0FBbUIsR0FBbkIsSUFBMEJpTixTQUFTaE4sSUFBVCxLQUFrQixHQUF0RyxFQUE0RztBQUFBLHdDQUNwRWdOLFNBQVNuTSxRQUFULENBQWtCa0ssS0FBbEIsQ0FBd0IsR0FBeEIsQ0FEb0U7QUFBQTtBQUFBLGdCQUNqRzJELFlBRGlHO0FBQUEsZ0JBQ25GQyxXQURtRjs7QUFFeEcsZ0JBQUksQ0FBQzNCLFNBQVN1QixLQUFkLEVBQXFCO0FBQ2pCaEssb0JBQUlBLEVBQUUyRixPQUFGLENBQVU4QyxTQUFTa0IsSUFBbkIsRUFBeUIsRUFBekIsQ0FBSjtBQUNBM0osb0JBQUltSyxlQUFlbkssQ0FBZixHQUFtQm9LLFdBQXZCO0FBQ0gsYUFIRCxNQUdPLElBQUkzQixTQUFTdUIsS0FBVCxJQUFrQmhLLEVBQUU2SixNQUFGLENBQVMsQ0FBVCxNQUFnQk0sWUFBdEMsRUFBb0Q7QUFDdkRuSyxvQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVXdFLFlBQVYsRUFBd0IxQixTQUFTa0IsSUFBakMsQ0FBSjtBQUNBM0osb0JBQUlBLEVBQUUyRixPQUFGLENBQVV5RSxXQUFWLEVBQXVCLEVBQXZCLENBQUo7QUFDSDtBQUNKOztBQUVELGVBQU9wSyxDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxhQUFTcUssVUFBVCxDQUFvQnJLLENBQXBCLEVBQXVCO0FBQ25CQSxZQUFJQSxFQUFFMkYsT0FBRixDQUFVLEdBQVYsRUFBZSxHQUFmLENBQUo7QUFDQSxZQUFJQyxTQUFTNUYsQ0FBVCxFQUFZLEdBQVosS0FBb0JBLEVBQUVzSyxXQUFGLENBQWMsR0FBZCxNQUF1QnRLLEVBQUUyRyxNQUFGLEdBQVcsQ0FBMUQsRUFBNkQ7QUFDekQzRyxnQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVSxHQUFWLEVBQWUsRUFBZixDQUFKO0FBQ0EzRixnQkFBSSxNQUFNQSxDQUFWO0FBQ0g7O0FBRUQsZUFBT0EsQ0FBUDtBQUNIOztBQUVEOzs7O0FBSUEsYUFBU3VLLFFBQVQsQ0FBa0IxRyxLQUFsQixFQUF5QjJHLE1BQXpCLEVBQWlDO0FBQzdCLFlBQUk1RyxPQUFPNEcsTUFBUCxLQUFrQkEsV0FBVyxRQUFqQyxFQUEyQztBQUN2QyxtQkFBTzNHLEtBQVA7QUFDSDs7QUFFRCxZQUFJNEcsZUFBSjtBQUNBLGdCQUFRRCxNQUFSO0FBQ0ksaUJBQUssUUFBTDtBQUNJQyx5QkFBU0MsT0FBTzdHLEtBQVAsQ0FBVDtBQUNBO0FBQ0osaUJBQUssSUFBTDtBQUNJNEcseUJBQVM3RSxTQUFTL0IsS0FBVCxFQUFnQixHQUFoQixJQUF1QkEsTUFBTThCLE9BQU4sQ0FBYyxHQUFkLEVBQW1CLEVBQW5CLElBQXlCLEdBQWhELEdBQXNEOUIsS0FBL0Q7QUFDQTtBQUNKLGlCQUFLLEdBQUw7QUFDQSxpQkFBSyxJQUFMO0FBQ0k0Ryx5QkFBUzVHLE1BQU04QixPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFUO0FBQ0E7QUFDSixpQkFBSyxJQUFMO0FBQ0k4RSx5QkFBUzVHLE1BQU04QixPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFUO0FBQ0E4RSx5QkFBUzdFLFNBQVM2RSxNQUFULEVBQWlCLEdBQWpCLElBQXdCQSxPQUFPOUUsT0FBUCxDQUFlLEdBQWYsRUFBb0IsRUFBcEIsSUFBMEIsR0FBbEQsR0FBd0Q4RSxNQUFqRTtBQUNBO0FBQ0o7QUFDQSxpQkFBSyxHQUFMO0FBQ0EsaUJBQUssSUFBTDtBQUNJQSx5QkFBUzVHLEtBQVQ7QUFDQTtBQUNKO0FBQ0lvRSxzREFBb0N1QyxNQUFwQztBQXJCUjs7QUF3QkEsZUFBT0MsTUFBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0UsU0FBVCxDQUFtQjNLLENBQW5CLEVBQXNCeUksUUFBdEIsRUFBZ0M7QUFDNUIsWUFBSUEsU0FBU3BOLElBQVQsS0FBa0IsR0FBdEIsRUFBMkI7QUFDdkIyRSxnQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVThDLFNBQVNwTixJQUFuQixFQUF5QixHQUF6QixDQUFKO0FBQ0g7QUFDRCxZQUFJb04sU0FBU2tCLElBQVQsS0FBa0IsR0FBbEIsSUFBeUJsQixTQUFTa0IsSUFBVCxLQUFrQixFQUEvQyxFQUFtRDtBQUMvQzNKLGdCQUFJQSxFQUFFMkYsT0FBRixDQUFVOEMsU0FBU2tCLElBQW5CLEVBQXlCLEdBQXpCLENBQUo7QUFDSDtBQUNELFlBQUksQ0FBQzNKLEVBQUVxSixLQUFGLENBQVEsSUFBUixDQUFMLEVBQW9CO0FBQ2hCO0FBQ0FySixpQkFBSyxNQUFMO0FBQ0g7O0FBRUQsZUFBT0EsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBUzRLLGFBQVQsQ0FBdUI1SyxDQUF2QixFQUEwQnlJLFFBQTFCLEVBQW9DO0FBQ2hDLFlBQUlBLFNBQVNrQixJQUFULEtBQWtCLEdBQWxCLElBQXlCbEIsU0FBU2tCLElBQVQsS0FBa0IsRUFBL0MsRUFBbUQ7QUFDL0MzSixnQkFBSUEsRUFBRTJGLE9BQUYsQ0FBVSxHQUFWLEVBQWU4QyxTQUFTa0IsSUFBeEIsQ0FBSjtBQUNIO0FBQ0QsWUFBSWxCLFNBQVNwTixJQUFULEtBQWtCLEdBQXRCLEVBQTJCO0FBQ3ZCMkUsZ0JBQUlBLEVBQUUyRixPQUFGLENBQVUsR0FBVixFQUFlOEMsU0FBU3BOLElBQXhCLENBQUo7QUFDSDs7QUFFRCxlQUFPMkUsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBLGFBQVM2SyxVQUFULENBQW9CQyxVQUFwQixFQUFnQ3JDLFFBQWhDLEVBQTBDc0MsV0FBMUMsRUFBdUQ7QUFDbkQsWUFBSUQsZUFBZSxFQUFmLElBQXFCQSxlQUFlckMsU0FBU2tCLElBQWpELEVBQXVEO0FBQ25ELGdCQUFJbEIsU0FBU2xNLE1BQVQsS0FBb0IsUUFBcEIsSUFBZ0N3TyxXQUFwQyxFQUFpRDtBQUM3Qyx1QkFBUXRDLFNBQVNoTixJQUFULEtBQWtCLEdBQW5CLEdBQTBCcVAsYUFBYXJDLFNBQVNsTixLQUF0QixHQUE4QmtOLFNBQVMvTSxPQUFqRSxHQUEyRStNLFNBQVNsTixLQUFULEdBQWlCdVAsVUFBakIsR0FBOEJyQyxTQUFTL00sT0FBekg7QUFDSDs7QUFFRCxtQkFBT29QLFVBQVA7QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLGFBQVNFLFNBQVQsQ0FBbUJGLFVBQW5CLEVBQStCckMsUUFBL0IsRUFBeUM7QUFDckMsWUFBSUEsU0FBU3dDLEtBQWIsRUFBb0I7QUFDaEJILHlCQUFhckYsVUFBVXFGLFVBQVYsRUFBc0JyQyxRQUF0QixDQUFiO0FBQ0g7O0FBRUQsWUFBSUEsU0FBU1MsZ0JBQVQsSUFBNkIsQ0FBQ3RELFNBQVNrRixVQUFULEVBQXFCLEdBQXJCLENBQWxDLEVBQTZEO0FBQ3pEQSx5QkFBYSxNQUFNQSxVQUFuQjtBQUNIOztBQUVELFlBQU1JLFFBQVFMLFdBQVdDLFVBQVgsRUFBdUJyQyxRQUF2QixFQUFpQyxJQUFqQyxDQUFkO0FBQ0EsWUFBTTBDLGFBQWF2RixTQUFTa0YsVUFBVCxFQUFxQixHQUFyQixDQUFuQjtBQUNBLFlBQUlLLFVBQUosRUFBZ0I7QUFDWkwseUJBQWFBLFdBQVduRixPQUFYLENBQW1CLEdBQW5CLEVBQXdCLEVBQXhCLENBQWI7QUFDSDs7QUFFRCxZQUFJLENBQUMvQixPQUFPc0gsS0FBUCxDQUFMLEVBQW9CO0FBQ2hCLG1CQUFPQSxLQUFQO0FBQ0g7O0FBRUR6QyxpQkFBU3JOLE1BQVQsR0FBa0JxTixTQUFTck4sTUFBVCxDQUFnQmdMLFFBQWhCLEVBQWxCO0FBQ0EsWUFBSWdGLHFCQUFKO0FBQ0EsZ0JBQVEzQyxTQUFTck4sTUFBakI7QUFDSSxpQkFBSyxHQUFMO0FBQ0lnUSwrQkFBZSxzQkFBZjtBQUNBO0FBQ0osaUJBQUssSUFBTDtBQUNJQSwrQkFBZSxtREFBZjtBQUNBO0FBQ0osaUJBQUssR0FBTDtBQUNJQSwrQkFBZSxrQkFBZjtBQUNBO0FBQ0o7QUFDSUEsK0JBQWUsa0JBQWY7QUFYUjs7QUFjQTs7QUFuQ3FDLGdDQW9DSk4sV0FBV3RFLEtBQVgsQ0FBaUJpQyxTQUFTcE4sSUFBMUIsQ0FwQ0k7QUFBQTtBQUFBLFlBb0NoQ29PLFdBcENnQztBQUFBLFlBb0NuQmhELFdBcENtQjs7QUFxQ3JDLFlBQUlnQyxTQUFTbk4sTUFBVCxJQUFtQndJLFlBQVkyQyxXQUFaLENBQXZCLEVBQWlEO0FBQUEscUNBQ2hCcUUsV0FBV3RFLEtBQVgsQ0FBaUJpQyxTQUFTbk4sTUFBMUIsQ0FEZ0I7O0FBQUE7O0FBQzVDbU8sdUJBRDRDO0FBQy9CaEQsdUJBRCtCO0FBRWhEOztBQUVELFlBQUlnQyxTQUFTdk4sSUFBVCxLQUFrQixFQUF0QixFQUEwQjtBQUN0QjtBQUNBLG1CQUFPa1EsYUFBYUMsSUFBYixDQUFrQjVCLFdBQWxCLENBQVAsRUFBdUM7QUFDbkNBLDhCQUFjQSxZQUFZOUQsT0FBWixDQUFvQnlGLFlBQXBCLFNBQXVDM0MsU0FBU3ZOLElBQWhELFFBQWQ7QUFDSDtBQUNKOztBQUVELFlBQUl1TixTQUFTM00sSUFBVCxLQUFrQixDQUFsQixJQUF1QixDQUFDZ0ksWUFBWTJDLFdBQVosQ0FBNUIsRUFBc0Q7QUFDbEQsZ0JBQUlBLFlBQVlFLE1BQVosR0FBcUI4QixTQUFTM00sSUFBbEMsRUFBd0M7QUFDcEMySyw4QkFBY0EsWUFBWTZFLFNBQVosQ0FBc0IsQ0FBdEIsRUFBeUI3QyxTQUFTM00sSUFBbEMsQ0FBZDtBQUNIOztBQUVEO0FBQ0FnUCx5QkFBYXJCLGNBQWNoQixTQUFTcE4sSUFBdkIsR0FBOEJvTCxXQUEzQztBQUNILFNBUEQsTUFPTztBQUNIO0FBQ0FxRSx5QkFBYXJCLFdBQWI7QUFDSDs7QUFFRCxZQUFJaEIsU0FBU2pOLEtBQVQsS0FBbUIsR0FBdkIsRUFBNEI7QUFDeEIsZ0JBQUkyUCxVQUFKLEVBQWdCO0FBQ1osd0JBQVExQyxTQUFTaE4sSUFBakI7QUFDSSx5QkFBSyxHQUFMO0FBQ0lxUCxxQ0FBYXJDLFNBQVNrQixJQUFULEdBQWdCbEIsU0FBU2xOLEtBQXpCLEdBQWlDdVAsVUFBOUM7QUFDQTtBQUNKLHlCQUFLLEdBQUw7QUFDSUEscUNBQWFyQyxTQUFTbE4sS0FBVCxHQUFpQmtOLFNBQVNrQixJQUExQixHQUFpQ21CLFVBQTlDO0FBQ0E7QUFDSix5QkFBSyxHQUFMO0FBQ0lBLHFDQUFhckMsU0FBU2xOLEtBQVQsR0FBaUJ1UCxVQUFqQixHQUE4QnJDLFNBQVNrQixJQUFwRDtBQUNBO0FBQ0o7QUFDSTtBQVhSO0FBYUgsYUFkRCxNQWNPO0FBQ0htQiw2QkFBYXJDLFNBQVNsTixLQUFULEdBQWlCdVAsVUFBOUI7QUFDSDtBQUNKOztBQUVELFlBQUlyQyxTQUFTak4sS0FBVCxLQUFtQixHQUF2QixFQUE0QjtBQUN4QixnQkFBSTJQLFVBQUosRUFBZ0I7QUFDWix3QkFBUTFDLFNBQVNoTixJQUFqQjtBQUNJLHlCQUFLLEdBQUw7QUFDSXFQLHFDQUFhQSxhQUFhckMsU0FBU2xOLEtBQXRCLEdBQThCa04sU0FBU2tCLElBQXBEO0FBQ0E7QUFDSix5QkFBSyxHQUFMO0FBQ0ltQixxQ0FBYUEsYUFBYXJDLFNBQVNrQixJQUF0QixHQUE2QmxCLFNBQVNsTixLQUFuRDtBQUNBO0FBQ0oseUJBQUssR0FBTDtBQUNJdVAscUNBQWFyQyxTQUFTa0IsSUFBVCxHQUFnQm1CLFVBQWhCLEdBQTZCckMsU0FBU2xOLEtBQW5EO0FBQ0E7QUFDSjtBQUNBO0FBWEo7QUFhSCxhQWRELE1BY087QUFDSHVQLDZCQUFhQSxhQUFhckMsU0FBU2xOLEtBQW5DO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFlBQUlrTixTQUFTbk0sUUFBVCxLQUFzQixJQUF0QixLQUErQm1NLFNBQVM4QyxRQUFULEdBQW9CLENBQXBCLElBQXlCVCxXQUFXakIsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUFqRixDQUFKLEVBQTJGO0FBQ3ZGaUIseUJBQWFaLGdCQUFnQlksVUFBaEIsRUFBNEJyQyxRQUE1QixDQUFiO0FBQ0g7QUFDREEsaUJBQVNTLGdCQUFULEdBQTRCLEtBQTVCOztBQUVBLGVBQU80QixhQUFhckMsU0FBUy9NLE9BQTdCO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTOFAsYUFBVCxDQUF1QkMsaUJBQXZCLEVBQTBDQyxJQUExQyxFQUFnRDtBQUM1QyxZQUFJQyxjQUFKO0FBQ0EsZ0JBQVFELElBQVI7QUFDSSxpQkFBSyxDQUFMO0FBQ0k7QUFDQUMsd0JBQVEsc0JBQVI7QUFDQTtBQUNKLGlCQUFLLENBQUw7QUFDSTtBQUNBQSx3QkFBUSx3QkFBUjtBQUNBO0FBQ0o7QUFDSTtBQUNBQSx3QkFBUSxJQUFJQyxNQUFKLGNBQXNCRixJQUF0Qix3QkFBUjtBQVhSOztBQWNBO0FBQ0FELDRCQUFvQkEsa0JBQWtCOUYsT0FBbEIsQ0FBMEJnRyxLQUExQixFQUFpQyxJQUFqQyxDQUFwQjtBQUNBLFlBQUlELFNBQVMsQ0FBYixFQUFnQjtBQUNaRCxnQ0FBb0JBLGtCQUFrQjlGLE9BQWxCLENBQTBCLEtBQTFCLEVBQWlDLEVBQWpDLENBQXBCO0FBQ0g7O0FBRUQsZUFBTzhGLGlCQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxhQUFTSSxTQUFULENBQW1CZixVQUFuQixFQUErQnJDLFFBQS9CLEVBQXlDO0FBQUU7QUFDdkNxQyxxQkFBY0EsZUFBZSxFQUFoQixHQUFzQixHQUF0QixHQUE0QkEsV0FBVzFFLFFBQVgsRUFBekM7QUFDQSxZQUFJcUMsU0FBU3JNLE1BQVQsS0FBb0IsS0FBcEIsSUFBNkJxTSxTQUFTck0sTUFBVCxLQUFvQixLQUFqRCxJQUEwRHFNLFNBQVNyTSxNQUFULEtBQW9CLEtBQTlFLElBQXVGcU0sU0FBU3JNLE1BQVQsS0FBb0IsS0FBL0csRUFBc0g7QUFDbEgsb0JBQVFxTSxTQUFTck0sTUFBakI7QUFDSSxxQkFBSyxLQUFMO0FBQ0kwTyxpQ0FBYSxDQUFDL0IsS0FBSytDLEtBQUwsQ0FBV2hCLGFBQWEsRUFBeEIsSUFBOEIsRUFBL0IsRUFBbUMxRSxRQUFuQyxFQUFiO0FBQ0E7QUFDSixxQkFBSyxLQUFMO0FBQ0kwRSxpQ0FBYSxDQUFDL0IsS0FBS2dELElBQUwsQ0FBVWpCLGFBQWEsRUFBdkIsSUFBNkIsRUFBOUIsRUFBa0MxRSxRQUFsQyxFQUFiO0FBQ0E7QUFDSjtBQUNJMEUsaUNBQWEsQ0FBQy9CLEtBQUtpRCxLQUFMLENBQVdsQixhQUFhLEVBQXhCLElBQThCLEVBQS9CLEVBQW1DMUUsUUFBbkMsRUFBYjtBQVJSOztBQVdBLGdCQUFJcUUsZUFBSjtBQUNBLGdCQUFJLENBQUM3RSxTQUFTa0YsVUFBVCxFQUFxQixHQUFyQixDQUFMLEVBQWdDO0FBQzVCTCx5QkFBU0ssYUFBYSxLQUF0QjtBQUNILGFBRkQsTUFFTyxJQUFJQSxXQUFXbkUsTUFBWCxHQUFvQm1FLFdBQVdoRixPQUFYLENBQW1CLEdBQW5CLENBQXBCLEdBQThDLENBQWxELEVBQXFEO0FBQ3hEMkUseUJBQVNLLGFBQWEsR0FBdEI7QUFDSCxhQUZNLE1BRUE7QUFDSEwseUJBQVNLLFVBQVQ7QUFDSDtBQUNELG1CQUFPTCxNQUFQO0FBQ0g7O0FBRUQsWUFBSXdCLFlBQVksRUFBaEI7QUFDQSxZQUFJM00sSUFBSSxDQUFSO0FBQ0EsWUFBSWtLLFFBQVEsRUFBWjtBQUNBLFlBQUlrQyxhQUFKOztBQUVBO0FBQ0EsWUFBSWpELFNBQVNwTSxJQUFiLEVBQW1CO0FBQ2ZxUCxtQkFBT2pELFNBQVMzTSxJQUFoQjtBQUNILFNBRkQsTUFFTztBQUNINFAsbUJBQU8sQ0FBUDtBQUNIOztBQUVEO0FBQ0EsWUFBSVosV0FBV2pCLE1BQVgsQ0FBa0IsQ0FBbEIsTUFBeUIsR0FBN0IsRUFBa0M7QUFDOUJMLG9CQUFRLEdBQVI7O0FBRUE7QUFDQXNCLHlCQUFhQSxXQUFXbkYsT0FBWCxDQUFtQixHQUFuQixFQUF3QixFQUF4QixDQUFiO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLENBQUNtRixXQUFXekIsS0FBWCxDQUFpQixLQUFqQixDQUFMLEVBQThCO0FBQzFCeUIseUJBQWEsTUFBTUEsVUFBbkI7QUFDSDs7QUFFRDtBQUNBLFlBQUl0QixVQUFVLEdBQVYsSUFBaUJrQixPQUFPSSxVQUFQLE1BQXVCLENBQTVDLEVBQStDO0FBQzNDdEIsb0JBQVEsRUFBUjtBQUNIOztBQUVEO0FBQ0EsWUFBS2tCLE9BQU9JLFVBQVAsSUFBcUIsQ0FBckIsSUFBMEJyQyxTQUFTak0sS0FBVCxLQUFtQixNQUE5QyxJQUEwRHNPLFdBQVduRSxNQUFYLEdBQW9CLENBQXBCLElBQXlCOEIsU0FBU2pNLEtBQVQsS0FBbUIsT0FBMUcsRUFBb0g7QUFDaEhzTyx5QkFBYUEsV0FBV25GLE9BQVgsQ0FBbUIsU0FBbkIsRUFBOEIsSUFBOUIsQ0FBYjtBQUNIOztBQUVELFlBQU11RyxPQUFPcEIsV0FBV1IsV0FBWCxDQUF1QixHQUF2QixDQUFiO0FBQ0EsWUFBTTZCLG9CQUFvQkQsU0FBUyxDQUFDLENBQXBDOztBQUVBO0FBQ0EsWUFBTUUsUUFBUUQsb0JBQW9CckIsV0FBV25FLE1BQVgsR0FBb0IsQ0FBeEMsR0FBNEN1RixJQUExRDs7QUFFQTtBQUNBO0FBQ0EsWUFBSUcsT0FBUXZCLFdBQVduRSxNQUFYLEdBQW9CLENBQXJCLEdBQTBCeUYsS0FBckM7O0FBRUEsWUFBSUMsUUFBUTVELFNBQVMzTSxJQUFyQixFQUEyQjtBQUN2QjtBQUNBbVEsd0JBQVluQixVQUFaO0FBQ0EsZ0JBQUl1QixPQUFPWCxJQUFYLEVBQWlCO0FBQ2Isb0JBQUlTLGlCQUFKLEVBQXVCO0FBQ25CRixpQ0FBYXhELFNBQVNwTixJQUF0QjtBQUNIOztBQUVELG9CQUFJaVIsUUFBUSxRQUFaO0FBQ0EsdUJBQU9ELE9BQU9YLElBQWQsRUFBb0I7QUFDaEJZLDRCQUFRQSxNQUFNaEIsU0FBTixDQUFnQixDQUFoQixFQUFtQkksT0FBT1csSUFBMUIsQ0FBUjtBQUNBSixpQ0FBYUssS0FBYjtBQUNBRCw0QkFBUUMsTUFBTTNGLE1BQWQ7QUFDSDtBQUNKLGFBWEQsTUFXTyxJQUFJMEYsT0FBT1gsSUFBWCxFQUFpQjtBQUNwQk8sNEJBQVlULGNBQWNTLFNBQWQsRUFBeUJQLElBQXpCLENBQVo7QUFDSCxhQUZNLE1BRUEsSUFBSVcsU0FBUyxDQUFULElBQWNYLFNBQVMsQ0FBM0IsRUFBOEI7QUFDakNPLDRCQUFZQSxVQUFVdEcsT0FBVixDQUFrQixLQUFsQixFQUF5QixFQUF6QixDQUFaO0FBQ0g7O0FBRUQsbUJBQVErRSxPQUFPdUIsU0FBUCxNQUFzQixDQUF2QixHQUE0QkEsU0FBNUIsR0FBd0N6QyxRQUFReUMsU0FBdkQ7QUFDSDs7QUFFRDtBQUNBLFlBQUlNLGdCQUFKO0FBQ0EsWUFBSUosaUJBQUosRUFBdUI7QUFDbkJJLHNCQUFVOUQsU0FBUzNNLElBQVQsR0FBZ0IsQ0FBMUI7QUFDSCxTQUZELE1BRU87QUFDSHlRLHNCQUFVOUQsU0FBUzNNLElBQVQsR0FBZ0JvUSxJQUExQjtBQUNIOztBQUVELFlBQU1NLFNBQVM5QixPQUFPSSxXQUFXakIsTUFBWCxDQUFrQjBDLFVBQVUsQ0FBNUIsQ0FBUCxDQUFmO0FBQ0EsWUFBTUUsTUFBTzNCLFdBQVdqQixNQUFYLENBQWtCMEMsT0FBbEIsTUFBK0IsR0FBaEMsR0FBd0N6QixXQUFXakIsTUFBWCxDQUFrQjBDLFVBQVUsQ0FBNUIsSUFBaUMsQ0FBekUsR0FBK0V6QixXQUFXakIsTUFBWCxDQUFrQjBDLE9BQWxCLElBQTZCLENBQXhIO0FBQ0EsWUFBSUcsVUFBVTVCLFdBQVdRLFNBQVgsQ0FBcUIsQ0FBckIsRUFBd0JpQixVQUFVLENBQWxDLEVBQXFDL0YsS0FBckMsQ0FBMkMsRUFBM0MsQ0FBZDs7QUFFQSxZQUFLZ0csU0FBUyxDQUFULElBQWMvRCxTQUFTck0sTUFBVCxLQUFvQixHQUFuQyxJQUE0RDtBQUMzRG9RLGlCQUFTLENBQVQsSUFBYy9ELFNBQVNyTSxNQUFULEtBQW9CLEdBQWxDLElBQXlDb04sVUFBVSxFQURwRCxJQUM0RDtBQUMzRGdELGlCQUFTLENBQVQsSUFBYy9ELFNBQVNyTSxNQUFULEtBQW9CLEdBQWxDLElBQXlDb04sVUFBVSxHQUZwRCxJQUU0RDtBQUMzRGdELGlCQUFTLENBQVQsSUFBYy9ELFNBQVNyTSxNQUFULEtBQW9CLEdBSG5DLElBRzREO0FBQzNEb1EsaUJBQVMsQ0FBVCxJQUFjL0QsU0FBU3JNLE1BQVQsS0FBb0IsR0FBbEMsSUFBeUNvTixVQUFVLEVBSnBELElBSTREO0FBQzNEZ0QsaUJBQVMsQ0FBVCxJQUFjL0QsU0FBU3JNLE1BQVQsS0FBb0IsR0FBbEMsSUFBeUNvTixVQUFVLEdBTHBELElBSzREO0FBQzNEZ0QsaUJBQVMsQ0FBVCxJQUFjL0QsU0FBU3JNLE1BQVQsS0FBb0IsR0FObkMsSUFNNEQ7QUFDM0RvUSxtQkFBVyxDQUFYLElBQWdCL0QsU0FBU3JNLE1BQVQsS0FBb0IsR0FBcEMsSUFBMkNxUSxRQUFRLENBUHBELElBTzREO0FBQzNERCxpQkFBUyxDQUFULElBQWMvRCxTQUFTck0sTUFBVCxLQUFvQixHQUFsQyxJQUF5Q29OLFVBQVUsRUFScEQsSUFRNEQ7QUFDM0RnRCxpQkFBUyxDQUFULElBQWMvRCxTQUFTck0sTUFBVCxLQUFvQixHQUFsQyxJQUF5Q29OLFVBQVUsR0FUcEQsSUFTNEQ7QUFDM0RnRCxpQkFBUyxDQUFULElBQWMvRCxTQUFTck0sTUFBVCxLQUFvQixHQVZ2QyxFQVU2QztBQUFtQjtBQUM1RDtBQUNBLGlCQUFLa0QsSUFBS29OLFFBQVEvRixNQUFSLEdBQWlCLENBQTNCLEVBQStCckgsS0FBSyxDQUFwQyxFQUF1Q0EsS0FBSyxDQUE1QyxFQUErQztBQUMzQyxvQkFBSW9OLFFBQVFwTixDQUFSLE1BQWUsR0FBbkIsRUFBd0I7QUFDcEJvTiw0QkFBUXBOLENBQVIsSUFBYSxDQUFDb04sUUFBUXBOLENBQVIsQ0FBRCxHQUFjLENBQTNCO0FBQ0Esd0JBQUlvTixRQUFRcE4sQ0FBUixJQUFhLEVBQWpCLEVBQXFCO0FBQ2pCO0FBQ0g7O0FBRUQsd0JBQUlBLElBQUksQ0FBUixFQUFXO0FBQ1BvTixnQ0FBUXBOLENBQVIsSUFBYSxHQUFiO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQ7QUFDQW9OLGtCQUFVQSxRQUFRNUMsS0FBUixDQUFjLENBQWQsRUFBaUJ5QyxVQUFVLENBQTNCLENBQVY7O0FBRUE7QUFDQU4sb0JBQVlULGNBQWNrQixRQUFRbkQsSUFBUixDQUFhLEVBQWIsQ0FBZCxFQUFnQ21DLElBQWhDLENBQVo7O0FBRUEsZUFBUWhCLE9BQU91QixTQUFQLE1BQXNCLENBQXZCLEdBQTRCQSxTQUE1QixHQUF3Q3pDLFFBQVF5QyxTQUF2RDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBLGFBQVNVLGVBQVQsQ0FBeUIzTSxDQUF6QixFQUE0QnlJLFFBQTVCLEVBQXNDbUUsS0FBdEMsRUFBNkM7QUFDekMsWUFBTXZSLE9BQU9vTixTQUFTcE4sSUFBdEI7QUFDQSxZQUFNUyxPQUFPMk0sU0FBUzNNLElBQXRCO0FBQ0FrRSxZQUFLNE0sVUFBVSxPQUFYLEdBQXNCZixVQUFVN0wsQ0FBVixFQUFheUksUUFBYixDQUF0QixHQUErQ3pJLENBQW5EOztBQUVBLFlBQUkzRSxRQUFRUyxJQUFaLEVBQWtCO0FBQUEsNEJBQ3FCa0UsRUFBRXdHLEtBQUYsQ0FBUW5MLElBQVIsQ0FEckI7QUFBQTtBQUFBLGdCQUNQb08sV0FETztBQUFBLGdCQUNNaEQsV0FETjs7QUFHZDs7O0FBQ0EsZ0JBQUlBLGVBQWVBLFlBQVlFLE1BQVosR0FBcUI3SyxJQUF4QyxFQUE4QztBQUMxQyxvQkFBSUEsT0FBTyxDQUFYLEVBQWM7QUFDVix3QkFBTStRLHNCQUFzQnBHLFlBQVk2RSxTQUFaLENBQXNCLENBQXRCLEVBQXlCeFAsSUFBekIsQ0FBNUI7QUFDQWtFLDZCQUFPeUosV0FBUCxHQUFxQnBPLElBQXJCLEdBQTRCd1IsbUJBQTVCO0FBQ0gsaUJBSEQsTUFHTztBQUNIN00sd0JBQUl5SixXQUFKO0FBQ0g7QUFDSjtBQUNKOztBQUVELGVBQU96SixDQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVM4TSxRQUFULENBQWtCbk4sQ0FBbEIsRUFBcUI7QUFDakIsWUFBTVUsSUFBSSxFQUFWO0FBQ0EsWUFBSW5CLFVBQUo7QUFDQSxZQUFJSSxVQUFKO0FBQ0EsWUFBSXlOLFdBQUo7QUFDQSxZQUFJeE4sVUFBSjs7QUFFQTtBQUNBLFlBQUlJLE1BQU0sQ0FBTixJQUFXLElBQUlBLENBQUosR0FBUSxDQUF2QixFQUEwQjtBQUN0QkEsZ0JBQUksSUFBSjtBQUNIOztBQUVEO0FBQ0FBLFlBQUlBLEVBQUV5RyxRQUFGLEVBQUo7QUFDQSxZQUFJekcsRUFBRWtLLE1BQUYsQ0FBUyxDQUFULE1BQWdCLEdBQXBCLEVBQXlCO0FBQ3JCbEssZ0JBQUlBLEVBQUVtSyxLQUFGLENBQVEsQ0FBUixDQUFKO0FBQ0F6SixjQUFFTCxDQUFGLEdBQU0sQ0FBQyxDQUFQO0FBQ0gsU0FIRCxNQUdPO0FBQ0hLLGNBQUVMLENBQUYsR0FBTSxDQUFOO0FBQ0g7O0FBRUQ7QUFDQWQsWUFBSVMsRUFBRW1HLE9BQUYsQ0FBVSxHQUFWLENBQUo7QUFDQSxZQUFJNUcsSUFBSSxDQUFDLENBQVQsRUFBWTtBQUNSUyxnQkFBSUEsRUFBRWdHLE9BQUYsQ0FBVSxHQUFWLEVBQWUsRUFBZixDQUFKO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJekcsSUFBSSxDQUFSLEVBQVc7QUFDUDtBQUNBQSxnQkFBSVMsRUFBRWdILE1BQU47QUFDSDs7QUFFRDtBQUNBckgsWUFBS0ssRUFBRXFOLE1BQUYsQ0FBUyxRQUFULE1BQXVCLENBQUMsQ0FBekIsR0FBOEJyTixFQUFFZ0gsTUFBaEMsR0FBeUNoSCxFQUFFcU4sTUFBRixDQUFTLFFBQVQsQ0FBN0M7QUFDQUQsYUFBS3BOLEVBQUVnSCxNQUFQO0FBQ0EsWUFBSXJILE1BQU15TixFQUFWLEVBQWM7QUFDVjtBQUNBMU0sY0FBRW5CLENBQUYsR0FBTSxDQUFOO0FBQ0FtQixjQUFFckIsQ0FBRixHQUFNLENBQUMsQ0FBRCxDQUFOO0FBQ0gsU0FKRCxNQUlPO0FBQ0g7QUFDQSxpQkFBS08sSUFBSXdOLEtBQUssQ0FBZCxFQUFpQnBOLEVBQUVrSyxNQUFGLENBQVN0SyxDQUFULE1BQWdCLEdBQWpDLEVBQXNDQSxLQUFLLENBQTNDLEVBQThDO0FBQzFDd04sc0JBQU0sQ0FBTjtBQUNIO0FBQ0RBLGtCQUFNLENBQU47O0FBRUE7QUFDQTFNLGNBQUVuQixDQUFGLEdBQU1BLElBQUlJLENBQUosR0FBUSxDQUFkO0FBQ0FlLGNBQUVyQixDQUFGLEdBQU0sRUFBTjs7QUFFQTtBQUNBLGlCQUFLRSxJQUFJLENBQVQsRUFBWUksS0FBS3lOLEVBQWpCLEVBQXFCek4sS0FBSyxDQUExQixFQUE2QjtBQUN6QmUsa0JBQUVyQixDQUFGLENBQUlFLENBQUosSUFBUyxDQUFDUyxFQUFFa0ssTUFBRixDQUFTdkssQ0FBVCxDQUFWO0FBQ0FKLHFCQUFLLENBQUw7QUFDSDtBQUNKOztBQUVELGVBQU9tQixDQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVM0TSxVQUFULENBQW9CM00sQ0FBcEIsRUFBdUJELENBQXZCLEVBQTBCO0FBQ3RCLFlBQU02TSxLQUFLN00sRUFBRXJCLENBQWI7QUFDQSxZQUFNbU8sS0FBSzdNLEVBQUV0QixDQUFiO0FBQ0EsWUFBSU0sSUFBSWUsRUFBRUwsQ0FBVjtBQUNBLFlBQUlULElBQUllLEVBQUVOLENBQVY7QUFDQSxZQUFJUixJQUFJYSxFQUFFbkIsQ0FBVjtBQUNBLFlBQUlPLElBQUlhLEVBQUVwQixDQUFWOztBQUVBO0FBQ0EsWUFBSSxDQUFDZ08sR0FBRyxDQUFILENBQUQsSUFBVSxDQUFDQyxHQUFHLENBQUgsQ0FBZixFQUFzQjtBQUNsQixnQkFBSTFDLGdCQUFKO0FBQ0EsZ0JBQUksQ0FBQ3lDLEdBQUcsQ0FBSCxDQUFMLEVBQVk7QUFDUnpDLDBCQUFTLENBQUMwQyxHQUFHLENBQUgsQ0FBRCxHQUFPLENBQVAsR0FBUyxDQUFDNU4sQ0FBbkI7QUFDSCxhQUZELE1BRU87QUFDSGtMLDBCQUFTbkwsQ0FBVDtBQUNIO0FBQ0QsbUJBQU9tTCxPQUFQO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJbkwsTUFBTUMsQ0FBVixFQUFhO0FBQ1QsbUJBQU9ELENBQVA7QUFDSDtBQUNELFlBQU04TixPQUFPOU4sSUFBSSxDQUFqQjs7QUFFQTtBQUNBLFlBQUlFLE1BQU1DLENBQVYsRUFBYTtBQUNULG1CQUFRRCxJQUFJQyxDQUFKLEdBQVEyTixJQUFULEdBQWUsQ0FBZixHQUFpQixDQUFDLENBQXpCO0FBQ0g7QUFDRDlOLFlBQUksQ0FBQyxDQUFMO0FBQ0FFLFlBQUkwTixHQUFHdkcsTUFBUDtBQUNBbEgsWUFBSTBOLEdBQUd4RyxNQUFQO0FBQ0FwSCxZQUFLQyxJQUFJQyxDQUFMLEdBQVVELENBQVYsR0FBY0MsQ0FBbEI7O0FBRUE7QUFDQSxhQUFLSCxLQUFLLENBQVYsRUFBYUEsSUFBSUMsQ0FBakIsRUFBb0JELEtBQUssQ0FBekIsRUFBNEI7QUFDeEIsZ0JBQUk0TixHQUFHNU4sQ0FBSCxNQUFVNk4sR0FBRzdOLENBQUgsQ0FBZCxFQUFxQjtBQUNqQix1QkFBUTROLEdBQUc1TixDQUFILElBQVE2TixHQUFHN04sQ0FBSCxDQUFSLEdBQWdCOE4sSUFBakIsR0FBdUIsQ0FBdkIsR0FBeUIsQ0FBQyxDQUFqQztBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxZQUFJM0MsZUFBSjtBQUNBLFlBQUlqTCxNQUFNQyxDQUFWLEVBQWE7QUFDVGdMLHFCQUFTLENBQVQ7QUFDSCxTQUZELE1BRU87QUFDSEEscUJBQVVqTCxJQUFJQyxDQUFKLEdBQVEyTixJQUFULEdBQWUsQ0FBZixHQUFpQixDQUFDLENBQTNCO0FBQ0g7O0FBRUQsZUFBTzNDLE1BQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0EsYUFBUzRDLFNBQVQsQ0FBbUJyTixDQUFuQixFQUFzQnlJLFFBQXRCLEVBQWdDO0FBQzVCekksWUFBSUEsRUFBRW9HLFFBQUYsRUFBSjtBQUNBcEcsWUFBSUEsRUFBRTJGLE9BQUYsQ0FBVSxHQUFWLEVBQWUsR0FBZixDQUFKO0FBQ0EsWUFBTTJILFdBQVdSLFNBQVNyRSxTQUFTNU0sSUFBbEIsQ0FBakI7QUFDQSxZQUFNMFIsV0FBV1QsU0FBU3JFLFNBQVM3TSxJQUFsQixDQUFqQjtBQUNBLFlBQU00UixXQUFXVixTQUFTOU0sQ0FBVCxDQUFqQjs7QUFFQSxZQUFJeUssZUFBSjtBQUNBLGdCQUFRaEMsU0FBUzlNLE9BQWpCO0FBQ0ksaUJBQUssT0FBTDtBQUNJOE8seUJBQVMsQ0FBQ3dDLFdBQVdLLFFBQVgsRUFBcUJFLFFBQXJCLElBQWlDLENBQUMsQ0FBbkMsRUFBc0MsSUFBdEMsQ0FBVDtBQUNBO0FBQ0osaUJBQUssU0FBTDtBQUNJL0MseUJBQVMsQ0FBQyxJQUFELEVBQU93QyxXQUFXTSxRQUFYLEVBQXFCQyxRQUFyQixJQUFpQyxDQUF4QyxDQUFUO0FBQ0E7QUFDSixpQkFBSyxRQUFMO0FBQ0kvQyx5QkFBUyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQVQ7QUFDQTtBQUNKO0FBQ0lBLHlCQUFTLENBQUN3QyxXQUFXSyxRQUFYLEVBQXFCRSxRQUFyQixJQUFpQyxDQUFDLENBQW5DLEVBQXNDUCxXQUFXTSxRQUFYLEVBQXFCQyxRQUFyQixJQUFpQyxDQUF2RSxDQUFUO0FBWFI7O0FBY0EsZUFBTy9DLE1BQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBU2dELE9BQVQsQ0FBaUI3SSxHQUFqQixFQUFzQjtBQUNsQjs7Ozs7QUFLQSxZQUFJWixTQUFTWSxHQUFULENBQUosRUFBbUI7QUFDZjtBQUNBQSx3QkFBVUEsSUFBSWUsT0FBSixDQUFZLGtCQUFaLEVBQWdDLE1BQWhDLENBQVY7QUFDSDs7QUFFRCxlQUFPK0MsRUFBRTlELEdBQUYsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBLGFBQVM4SSxTQUFULENBQW1CQyxLQUFuQixFQUEwQmxGLFFBQTFCLEVBQW9EO0FBQUEsWUFBaEJtRixNQUFnQix1RUFBUCxLQUFPOztBQUNoRCxZQUFJQyxPQUFPRixNQUFNRSxJQUFOLENBQVcsYUFBWCxDQUFYO0FBQ0EsWUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFDUEEsbUJBQU8sRUFBUDtBQUNBRixrQkFBTUUsSUFBTixDQUFXLGFBQVgsRUFBMEJBLElBQTFCO0FBQ0g7O0FBRUQsWUFBSXJJLFNBQVNxSSxLQUFLckksTUFBbEI7QUFDQSxZQUFJb0ksVUFBVzlKLFlBQVkwQixNQUFaLEtBQXVCaUQsUUFBdEMsRUFBaUQ7QUFDN0NqRCxxQkFBUyxJQUFJc0ksaUJBQUosQ0FBc0JILE1BQU1JLEdBQU4sQ0FBVSxDQUFWLENBQXRCLEVBQW9DdEYsUUFBcEMsQ0FBVDtBQUNBb0YsaUJBQUtySSxNQUFMLEdBQWNBLE1BQWQ7QUFDSDs7QUFFRCxlQUFPQSxNQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVN3SSwwQkFBVCxDQUFvQ3ZGLFFBQXBDLEVBQThDO0FBQzFDQSxpQkFBU3dGLElBQVQsR0FBb0J4RixTQUFTM00sSUFBN0I7QUFDQTJNLGlCQUFTeUYsSUFBVCxHQUFvQnpGLFNBQVNwTSxJQUE3QjtBQUNBb00saUJBQVMwRixRQUFULEdBQW9CMUYsU0FBU25NLFFBQTdCO0FBQ0FtTSxpQkFBUzJGLElBQVQsR0FBb0IzRixTQUFTdk4sSUFBN0I7QUFDQXVOLGlCQUFTNEYsS0FBVCxHQUFvQjVGLFNBQVNsTixLQUE3QjtBQUNBa04saUJBQVM2RixPQUFULEdBQW9CN0YsU0FBUy9NLE9BQTdCO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxhQUFTNlMsVUFBVCxDQUFvQkMsSUFBcEIsRUFBMEI7QUFDdEIsWUFBTUMsU0FBU0QsT0FBTyxHQUF0QjtBQUNBLFlBQU1FLEtBQUtySCxTQUFTc0gsTUFBVCxDQUFnQm5JLEtBQWhCLENBQXNCLEdBQXRCLENBQVg7QUFDQSxZQUFJeEgsSUFBSSxFQUFSO0FBQ0EsYUFBSyxJQUFJTSxJQUFJLENBQWIsRUFBZ0JBLElBQUlvUCxHQUFHL0gsTUFBdkIsRUFBK0JySCxLQUFLLENBQXBDLEVBQXVDO0FBQ25DTixnQkFBSTBQLEdBQUdwUCxDQUFILENBQUo7QUFDQSxtQkFBT04sRUFBRTZLLE1BQUYsQ0FBUyxDQUFULE1BQWdCLEdBQXZCLEVBQTRCO0FBQ3hCN0ssb0JBQUlBLEVBQUVzTSxTQUFGLENBQVksQ0FBWixFQUFldE0sRUFBRTJILE1BQWpCLENBQUo7QUFDSDtBQUNELGdCQUFJM0gsRUFBRThHLE9BQUYsQ0FBVTJJLE1BQVYsTUFBc0IsQ0FBMUIsRUFBNkI7QUFDekIsdUJBQU96UCxFQUFFc00sU0FBRixDQUFZbUQsT0FBTzlILE1BQW5CLEVBQTJCM0gsRUFBRTJILE1BQTdCLENBQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sSUFBUDtBQUNIOztBQUVEOzs7QUFHQSxhQUFTaUksV0FBVCxHQUF1QjtBQUNuQixZQUFNQyxNQUFNLFdBQVo7QUFDQSxZQUFJO0FBQ0FDLDJCQUFlQyxPQUFmLENBQXVCRixHQUF2QixFQUE0QkEsR0FBNUI7QUFDQUMsMkJBQWVFLFVBQWYsQ0FBMEJILEdBQTFCO0FBQ0EsbUJBQU8sSUFBUDtBQUNILFNBSkQsQ0FJRSxPQUFPM1AsQ0FBUCxFQUFVO0FBQ1IsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQ7OztBQUdBLGFBQVMrUCxRQUFULENBQWtCQyxPQUFsQixFQUEyQnpHLFFBQTNCLEVBQXFDMEcsSUFBckMsRUFBMkM7QUFDdkMsWUFBSTFHLFNBQVN0TSxLQUFiLEVBQW9CO0FBQ2hCLGdCQUFNaVQsYUFBY0YsUUFBUVYsSUFBUixLQUFpQixFQUFqQixJQUF1QixDQUFDMUssWUFBWW9MLFFBQVFWLElBQXBCLENBQXpCLGFBQTZEYSxtQkFBbUJILFFBQVFWLElBQTNCLENBQTdELGFBQXlHVSxRQUFRSSxFQUFwSTtBQUNBLGdCQUFJQyxhQUFKO0FBQ0EsZ0JBQUlDLGdCQUFKOztBQUVBO0FBQ0EsZ0JBQUlaLGtCQUFrQixLQUF0QixFQUE2QjtBQUN6Qix3QkFBUU8sSUFBUjtBQUNJLHlCQUFLLEtBQUw7QUFDSTlILGlDQUFTc0gsTUFBVCxHQUFxQlMsVUFBckIsU0FBbUMzRyxTQUFTOEMsUUFBNUM7QUFDQTtBQUNKLHlCQUFLLE1BQUw7QUFDSWdFLCtCQUFPLElBQUlFLElBQUosRUFBUDtBQUNBRiw2QkFBS0csT0FBTCxDQUFhSCxLQUFLSSxPQUFMLEtBQWtCLENBQUMsQ0FBRCxHQUFLLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBZixHQUFvQixJQUFuRDtBQUNBSCxrQ0FBVSxlQUFlRCxLQUFLSyxXQUFMLEVBQXpCLENBSEosQ0FHaUQ7QUFDN0N2SSxpQ0FBU3NILE1BQVQsR0FBcUJTLFVBQXJCLGVBQXVDSSxPQUF2QztBQUNBO0FBQ0oseUJBQUssS0FBTDtBQUNJLCtCQUFPakIsV0FBV2EsVUFBWCxDQUFQO0FBWFI7QUFhSCxhQWRELE1BY087QUFDSCx3QkFBUUQsSUFBUjtBQUNJLHlCQUFLLEtBQUw7QUFDSUwsdUNBQWVDLE9BQWYsQ0FBdUJLLFVBQXZCLEVBQW1DM0csU0FBUzhDLFFBQTVDO0FBQ0E7QUFDSix5QkFBSyxNQUFMO0FBQ0l1RCx1Q0FBZUUsVUFBZixDQUEwQkksVUFBMUI7QUFDQTtBQUNKLHlCQUFLLEtBQUw7QUFDSSwrQkFBT04sZUFBZWUsT0FBZixDQUF1QlQsVUFBdkIsQ0FBUDtBQVJSO0FBVUg7QUFDSjtBQUNKOztBQUVEOzs7O0FBN21DRyxRQWduQ0d0QixpQkFobkNIO0FBaW5DQzs7Ozs7O0FBTUEsbUNBQVk5RyxJQUFaLEVBQWtCeUIsUUFBbEIsRUFBNEI7QUFBQTs7QUFDeEIsaUJBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsaUJBQUt6QixJQUFMLEdBQVlBLElBQVo7QUFDQSxpQkFBSzJHLEtBQUwsR0FBYWpGLEVBQUUxQixJQUFGLENBQWI7QUFDQSxpQkFBSzhJLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxpQkFBS3BLLGFBQUwsR0FBcUIrQyxRQUFyQjtBQUNBLGlCQUFLNUUsS0FBTCxHQUFhbUQsS0FBS25ELEtBQWxCO0FBQ0g7O0FBOW5DRjtBQUFBO0FBQUEsbURBZ29Dd0IzRSxDQWhvQ3hCLEVBZ29DMkI7QUFDdEIscUJBQUsyRSxLQUFMLEdBQWEsS0FBS21ELElBQUwsQ0FBVW5ELEtBQXZCO0FBQ0EscUJBQUtrTSxPQUFMLEdBQWU3USxFQUFFNlEsT0FBakI7QUFDQSxxQkFBS0MsTUFBTCxHQUFjOVEsRUFBRStRLE9BQWhCO0FBQ0EscUJBQUtDLFFBQUwsR0FBZ0JoUixFQUFFZ1IsUUFBbEI7O0FBRUE7QUFDQSxxQkFBSzVJLFNBQUwsR0FBaUJQLG9CQUFvQixLQUFLQyxJQUF6QixDQUFqQjtBQUNBLG9CQUFJOUgsRUFBRWlSLElBQUYsS0FBVyxTQUFYLElBQXdCalIsRUFBRWlSLElBQUYsS0FBVyxPQUF2QyxFQUFnRDtBQUM1Qyx5QkFBS0MsTUFBTCxHQUFjbFIsRUFBRW5DLE9BQWhCO0FBQ0g7QUFDRCxxQkFBSytKLEtBQUwsR0FBYTVILEVBQUU0SCxLQUFmO0FBQ0g7QUE1b0NGO0FBQUE7QUFBQSwwQ0E4b0NlWSxLQTlvQ2YsRUE4b0NzQkQsR0E5b0N0QixFQThvQzJCNEksT0E5b0MzQixFQThvQ29DO0FBQy9CM0ksd0JBQVFxQixLQUFLQyxHQUFMLENBQVN0QixLQUFULEVBQWdCLENBQWhCLENBQVI7QUFDQUQsc0JBQU1zQixLQUFLdUgsR0FBTCxDQUFTN0ksR0FBVCxFQUFjLEtBQUtULElBQUwsQ0FBVW5ELEtBQVYsQ0FBZ0I4QyxNQUE5QixDQUFOO0FBQ0EscUJBQUtXLFNBQUwsR0FBaUI7QUFDYkksZ0NBRGE7QUFFYkQsNEJBRmE7QUFHYmQsNEJBQVFjLE1BQU1DO0FBSEQsaUJBQWpCO0FBS0Esb0JBQUk1RCxZQUFZdU0sT0FBWixLQUF3QkEsT0FBNUIsRUFBcUM7QUFDakN6SSx3Q0FBb0IsS0FBS1osSUFBekIsRUFBK0JVLEtBQS9CLEVBQXNDRCxHQUF0QztBQUNIO0FBQ0o7QUF6cENGO0FBQUE7QUFBQSx5Q0EycENjOEksR0EzcENkLEVBMnBDbUJGLE9BM3BDbkIsRUEycEM0QjtBQUN2QixxQkFBS0csYUFBTCxDQUFtQkQsR0FBbkIsRUFBd0JBLEdBQXhCLEVBQTZCRixPQUE3QjtBQUNIO0FBN3BDRjtBQUFBO0FBQUEsOENBK3BDbUI7QUFDZCxvQkFBTXhNLFFBQVEsS0FBS0EsS0FBbkI7QUFDQTtBQUNBLG9CQUFNNE0sT0FBTzVNLE1BQU15SCxTQUFOLENBQWdCLENBQWhCLEVBQW1CLEtBQUtoRSxTQUFMLENBQWVJLEtBQWxDLENBQWI7QUFDQSxvQkFBTWdKLFFBQVE3TSxNQUFNeUgsU0FBTixDQUFnQixLQUFLaEUsU0FBTCxDQUFlRyxHQUEvQixFQUFvQzVELE1BQU04QyxNQUExQyxDQUFkOztBQUVBLHVCQUFPLENBQUM4SixJQUFELEVBQU9DLEtBQVAsQ0FBUDtBQUNIO0FBdHFDRjtBQUFBO0FBQUEsc0RBd3FDMkI7QUFDdEIsb0JBQU1oTCxnQkFBZ0IsS0FBS0EsYUFBM0I7O0FBRHNCLHVDQUVGLEtBQUtpTCxlQUFMLEVBRkU7QUFBQTtBQUFBLG9CQUVqQkYsSUFGaUI7QUFBQSxvQkFFWEMsS0FGVzs7QUFHdEJELHVCQUFPaEwsVUFBVWdMLElBQVYsRUFBZ0IsS0FBSy9LLGFBQXJCLENBQVA7QUFDQWdMLHdCQUFRakwsVUFBVWlMLEtBQVYsRUFBaUIsS0FBS2hMLGFBQXRCLENBQVI7O0FBRUEsb0JBQUlBLGNBQWN3RCxnQkFBZCxJQUFrQyxDQUFDdEQsU0FBUzZLLElBQVQsRUFBZSxHQUFmLENBQXZDLEVBQTREO0FBQ3hEQSwyQkFBTyxNQUFNQSxJQUFiO0FBQ0FDLDRCQUFTQSxVQUFVLEdBQVgsR0FBa0IsRUFBbEIsR0FBdUJBLEtBQS9CO0FBQ0g7O0FBRURoTCw4QkFBY3dELGdCQUFkLEdBQWlDLEtBQWpDOztBQUVBLHVCQUFPLENBQUN1SCxJQUFELEVBQU9DLEtBQVAsQ0FBUDtBQUNIOztBQUVEOzs7O0FBeHJDRDtBQUFBO0FBQUEsNENBMnJDaUJELElBM3JDakIsRUEyckN1QkMsS0EzckN2QixFQTJyQzhCO0FBQ3pCLG9CQUFNaEwsZ0JBQWdCLEtBQUtBLGFBQTNCOztBQUVBO0FBQ0ErSyx1QkFBT2hMLFVBQVVnTCxJQUFWLEVBQWdCL0ssYUFBaEIsQ0FBUDs7QUFFQTtBQUNBZ0wsd0JBQVFqTCxVQUFVaUwsS0FBVixFQUFpQmhMLGFBQWpCLENBQVI7QUFDQSxvQkFBSUEsY0FBY3dELGdCQUFkLElBQWtDLENBQUN0RCxTQUFTNkssSUFBVCxFQUFlLEdBQWYsQ0FBdkMsRUFBNEQ7QUFDeERBLDJCQUFPLE1BQU1BLElBQWI7QUFDQS9LLGtDQUFjd0QsZ0JBQWQsR0FBaUMsS0FBakM7QUFDSDtBQUNELG9CQUFJLENBQUN1SCxTQUFTLEVBQVQsSUFBZUEsU0FBUy9LLGNBQWNpRSxJQUF2QyxLQUFnRGpFLGNBQWNsSixLQUFkLEtBQXdCLE1BQTVFLEVBQW9GO0FBQ2hGLHdCQUFJa1UsUUFBUSxFQUFaLEVBQWdCO0FBQ1pBLGdDQUFRQSxNQUFNL0ssT0FBTixDQUFjLFNBQWQsRUFBeUIsSUFBekIsQ0FBUjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxxQkFBS2lMLFFBQUwsR0FBZ0JILE9BQU9DLEtBQXZCO0FBQ0Esb0JBQUloTCxjQUFjckssSUFBbEIsRUFBd0I7QUFDcEIsd0JBQU1xRSxJQUFJLEtBQUtrUixRQUFMLENBQWN2SCxLQUFkLENBQW9CLElBQUl1QyxNQUFKLE9BQWVsRyxjQUFjbUwsZ0JBQTdCLFVBQWtEbkwsY0FBY3JLLElBQWhFLENBQXBCLENBQVY7QUFDQSx3QkFBSXFFLENBQUosRUFBTztBQUNIK1EsK0JBQU9BLEtBQUs5SyxPQUFMLENBQWFqRyxFQUFFLENBQUYsQ0FBYixFQUFtQkEsRUFBRSxDQUFGLElBQU8sR0FBMUIsQ0FBUDtBQUNBLDZCQUFLa1IsUUFBTCxHQUFnQkgsT0FBT0MsS0FBdkI7QUFDSDtBQUNKOztBQUVELHVCQUFPLENBQUNELElBQUQsRUFBT0MsS0FBUCxDQUFQO0FBQ0g7O0FBRUQ7Ozs7QUExdENEO0FBQUE7QUFBQSwyQ0E2dENnQkQsSUE3dENoQixFQTZ0Q3NCQyxLQTd0Q3RCLEVBNnRDNkJJLE1BN3RDN0IsRUE2dENxQztBQUNoQyxvQkFBTXBMLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLG9CQUFNcUwsUUFBUSxLQUFLQyxlQUFMLENBQXFCUCxJQUFyQixFQUEyQkMsS0FBM0IsQ0FBZDs7QUFGZ0MsaUNBR0xyRCxVQUFVLEtBQUt1RCxRQUFmLEVBQXlCbEwsYUFBekIsQ0FISztBQUFBO0FBQUEsb0JBR3pCdUwsT0FIeUI7QUFBQSxvQkFHaEJDLE9BSGdCOztBQUloQyxvQkFBSWpLLFdBQVc4SixNQUFNLENBQU4sRUFBU3BLLE1BQXhCO0FBQ0EscUJBQUtpSyxRQUFMLEdBQWdCRyxNQUFNeEgsSUFBTixDQUFXLEVBQVgsQ0FBaEI7O0FBRUEsb0JBQUkwSCxXQUFXQyxPQUFmLEVBQXdCO0FBQ3BCLHlCQUFLTixRQUFMLEdBQWdCakUsZ0JBQWdCLEtBQUtpRSxRQUFyQixFQUErQmxMLGFBQS9CLEVBQThDb0wsTUFBOUMsQ0FBaEI7QUFDQSx3QkFBTUssWUFBYXZMLFNBQVMsS0FBS2dMLFFBQWQsRUFBd0IsR0FBeEIsQ0FBRCxHQUFpQyxLQUFLQSxRQUFMLENBQWNqTCxPQUFkLENBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLENBQWpDLEdBQW1FLEtBQUtpTCxRQUExRjtBQUNBLHdCQUFJTyxjQUFjLEVBQWQsSUFBb0JBLGNBQWN6TCxjQUFjaUUsSUFBcEQsRUFBMEQ7QUFDdERqRSxzQ0FBYzZGLFFBQWQsR0FBeUIsRUFBekI7QUFDSCxxQkFGRCxNQUVPO0FBQ0g3RixzQ0FBYzZGLFFBQWQsR0FBeUI0RixTQUF6QjtBQUNIOztBQUVELHdCQUFJbEssV0FBVyxLQUFLMkosUUFBTCxDQUFjakssTUFBN0IsRUFBcUM7QUFDakNNLG1DQUFXLEtBQUsySixRQUFMLENBQWNqSyxNQUF6QjtBQUNIOztBQUVEO0FBQ0Esd0JBQUlNLGFBQWEsQ0FBYixJQUFrQjhKLE1BQU0sQ0FBTixNQUFhLEdBQS9CLElBQXNDckwsY0FBY2xKLEtBQWQsS0FBd0IsTUFBbEUsRUFBMEU7QUFDdEV5SyxtQ0FBVyxDQUFYO0FBQ0g7O0FBRUQseUJBQUtwRCxLQUFMLEdBQWEsS0FBSytNLFFBQWxCO0FBQ0EseUJBQUtRLFlBQUwsQ0FBa0JuSyxRQUFsQixFQUE0QixLQUE1Qjs7QUFFQSwyQkFBTyxJQUFQO0FBQ0g7O0FBRUQsb0JBQUksQ0FBQ2dLLE9BQUwsRUFBYztBQUNWLHlCQUFLdEQsS0FBTCxDQUFXMEQsT0FBWCxDQUFtQix5QkFBbkI7QUFDSCxpQkFGRCxNQUVPLElBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ2pCLHlCQUFLdkQsS0FBTCxDQUFXMEQsT0FBWCxDQUFtQix5QkFBbkI7QUFDSDs7QUFFRCx1QkFBTyxLQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBcndDRDtBQUFBO0FBQUEsNENBeXdDaUI7QUFDWixvQkFBTTNMLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLG9CQUFNbkssUUFBUW1LLGNBQWNuSyxLQUE1QjtBQUNBLG9CQUFNeUwsT0FBTyxLQUFLQSxJQUFsQjs7QUFFQSxvQkFBSXpMLEtBQUosRUFBVztBQUNQLHdCQUFNK1YsV0FBVy9WLE1BQU1vTCxNQUF2QjtBQUNBLHdCQUFJakIsY0FBY2xLLEtBQWQsS0FBd0IsR0FBNUIsRUFBaUM7QUFDN0IsNEJBQU0rVixTQUFTN0wsY0FBY2lFLElBQWQsSUFBc0IzQyxLQUFLbkQsS0FBM0IsSUFBb0NtRCxLQUFLbkQsS0FBTCxDQUFXZ0csTUFBWCxDQUFrQixDQUFsQixNQUF5Qm5FLGNBQWNpRSxJQUExRjtBQUNBLCtCQUFPNEgsU0FBUyxDQUFDLENBQUQsRUFBSUQsV0FBVyxDQUFmLENBQVQsR0FBNkIsQ0FBQyxDQUFELEVBQUlBLFFBQUosQ0FBcEM7QUFDSDtBQUNELHdCQUFNRSxXQUFXeEssS0FBS25ELEtBQUwsQ0FBVzhDLE1BQTVCO0FBQ0EsMkJBQU8sQ0FBQzZLLFdBQVdGLFFBQVosRUFBc0JFLFFBQXRCLENBQVA7QUFDSDs7QUFFRCx1QkFBTyxDQUFDLElBQUQsRUFBTyxDQUFDLENBQVIsQ0FBUDtBQUNIOztBQUVEOzs7OztBQTN4Q0Q7QUFBQTtBQUFBLG1EQSt4Q3dCbkIsT0EveEN4QixFQSt4Q2lDO0FBQzVCLG9CQUFNb0IsZUFBZSxLQUFLQyxhQUFMLEVBQXJCO0FBQ0Esb0JBQU1wSyxZQUFZLEtBQUtBLFNBQXZCOztBQUVBO0FBQ0Esb0JBQUlBLFVBQVVJLEtBQVYsR0FBa0IrSixhQUFhLENBQWIsQ0FBbEIsSUFBcUNuSyxVQUFVRyxHQUFWLEdBQWdCZ0ssYUFBYSxDQUFiLENBQXpELEVBQTBFO0FBQ3RFO0FBQ0Esd0JBQUksQ0FBQ25LLFVBQVVJLEtBQVYsR0FBa0IrSixhQUFhLENBQWIsQ0FBbEIsSUFBcUNuSyxVQUFVRyxHQUFWLEdBQWdCZ0ssYUFBYSxDQUFiLENBQXRELEtBQTBFLEtBQUs1TixLQUFMLENBQVd5SCxTQUFYLENBQXFCdkMsS0FBS0MsR0FBTCxDQUFTMUIsVUFBVUksS0FBbkIsRUFBMEIrSixhQUFhLENBQWIsQ0FBMUIsQ0FBckIsRUFBaUUxSSxLQUFLdUgsR0FBTCxDQUFTaEosVUFBVUcsR0FBbkIsRUFBd0JnSyxhQUFhLENBQWIsQ0FBeEIsQ0FBakUsRUFBMkdwSSxLQUEzRyxDQUFpSCxPQUFqSCxDQUE5RSxFQUF5TTtBQUNyTSw0QkFBSS9CLFVBQVVJLEtBQVYsR0FBa0IrSixhQUFhLENBQWIsQ0FBdEIsRUFBdUM7QUFDbkMsaUNBQUtqQixhQUFMLENBQW1CbEosVUFBVUksS0FBN0IsRUFBb0MrSixhQUFhLENBQWIsQ0FBcEMsRUFBcURwQixPQUFyRDtBQUNILHlCQUZELE1BRU87QUFDSCxpQ0FBS0csYUFBTCxDQUFtQmlCLGFBQWEsQ0FBYixDQUFuQixFQUFvQ25LLFVBQVVHLEdBQTlDLEVBQW1ENEksT0FBbkQ7QUFDSDtBQUNKLHFCQU5ELE1BTU87QUFDSDtBQUNBLDZCQUFLRyxhQUFMLENBQW1CekgsS0FBS3VILEdBQUwsQ0FBU2hKLFVBQVVJLEtBQW5CLEVBQTBCK0osYUFBYSxDQUFiLENBQTFCLENBQW5CLEVBQStEMUksS0FBS0MsR0FBTCxDQUFTMUIsVUFBVUcsR0FBbkIsRUFBd0JnSyxhQUFhLENBQWIsQ0FBeEIsQ0FBL0QsRUFBeUdwQixPQUF6RztBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7OztBQW56Q0Q7QUFBQTtBQUFBLDBDQXN6Q2U7QUFDVixvQkFBSSxDQUFDdk0sWUFBWSxLQUFLNk4scUJBQWpCLENBQUwsRUFBOEM7QUFDMUMsd0JBQU1DLFdBQVcsS0FBS0QscUJBQXRCOztBQUQwQywyQ0FFcEIsS0FBS2hCLGVBQUwsRUFGb0I7QUFBQTtBQUFBLHdCQUVuQ0YsSUFGbUM7QUFBQSx3QkFFN0JDLEtBRjZCOztBQUkxQzs7O0FBQ0EsMkJBQU8sS0FBS2lCLHFCQUFaO0FBQ0Esd0JBQU1FLG1CQUFtQnBCLEtBQUtxQixNQUFMLENBQVksQ0FBWixFQUFlRixTQUFTLENBQVQsRUFBWWpMLE1BQTNCLElBQXFDbEIsVUFBVWdMLEtBQUtxQixNQUFMLENBQVlGLFNBQVMsQ0FBVCxFQUFZakwsTUFBeEIsQ0FBVixFQUEyQyxLQUFLakIsYUFBaEQsQ0FBOUQ7QUFDQSx3QkFBSSxDQUFDLEtBQUtxTSxjQUFMLENBQW9CRixnQkFBcEIsRUFBc0NuQixLQUF0QyxFQUE2QyxPQUE3QyxDQUFMLEVBQTREO0FBQ3hELDZCQUFLN00sS0FBTCxHQUFhK04sU0FBU3JJLElBQVQsQ0FBYyxFQUFkLENBQWI7QUFDQSw2QkFBSzZILFlBQUwsQ0FBa0JRLFNBQVMsQ0FBVCxFQUFZakwsTUFBOUIsRUFBc0MsS0FBdEM7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7O0FBcjBDRDtBQUFBO0FBQUEsd0NBeTBDYXpILENBejBDYixFQXkwQ2dCO0FBQ1gsb0JBQU1rUixTQUFTLEtBQUtBLE1BQXBCO0FBQ0Esb0JBQU10SixRQUFRLEtBQUtBLEtBQW5CO0FBQ0Esb0JBQU1pSixVQUFVLEtBQUtBLE9BQXJCO0FBQ0Esb0JBQU1DLFNBQVMsS0FBS0EsTUFBcEI7O0FBRUE7QUFDQSxvQkFBTUUsV0FBVyxLQUFLQSxRQUF0QjtBQUNBLG9CQUFLLENBQUNILFdBQVdDLE1BQVosS0FBdUI5USxFQUFFaVIsSUFBRixLQUFXLE9BQWxDLElBQTZDLENBQUNyTSxZQUFZLEtBQUs2TixxQkFBakIsQ0FBL0MsSUFBNEZ6QixZQUFZRSxXQUFXclQsUUFBUW1CLE1BQS9ILEVBQXdJO0FBQ3BJLHlCQUFLOFQsV0FBTDtBQUNBLDJCQUFPLEtBQVA7QUFDSDs7QUFFRDtBQUNBLG9CQUFLNUIsVUFBVXJULFFBQVEwRSxFQUFsQixJQUF3QjJPLFVBQVVyVCxRQUFRcUYsR0FBM0MsSUFDQ2dPLFVBQVVyVCxRQUFReUQsT0FBbEIsSUFBNkI0UCxVQUFVclQsUUFBUTBELFVBRGhELElBRUMyUCxVQUFVclQsUUFBUUUsR0FBbEIsSUFBeUJtVCxTQUFTclQsUUFBUVUsS0FGM0MsSUFHQzJTLFNBQVNyVCxRQUFRQyxTQUFqQixLQUNBOEosVUFBVSxDQUFWLElBQWVBLFVBQVVzSixNQUR6QixDQUhELElBS0FBLFdBQVdyVCxRQUFRc0YsT0FMbkIsSUFNQStOLFdBQVdyVCxRQUFRdUYsVUFObkIsSUFPQThOLFdBQVdyVCxRQUFRbUIsTUFQbkIsSUFRQWtTLFdBQVdyVCxRQUFRcUcsT0FSdkIsRUFRZ0M7QUFDNUIsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksQ0FBQzJNLFdBQVdDLE1BQVosS0FBdUJJLFdBQVdyVCxRQUFRK0IsQ0FBOUMsRUFBaUQ7QUFDN0Msd0JBQUksS0FBSzJKLFFBQUwsQ0FBYy9MLE9BQWxCLEVBQTJCO0FBQ3ZCO0FBQ0F3QywwQkFBRStTLGNBQUY7QUFDQSw0QkFBTVQsV0FBVyxLQUFLeEssSUFBTCxDQUFVbkQsS0FBVixDQUFnQjhDLE1BQWpDO0FBQ0EsNEJBQU0ySyxXQUFXLEtBQUs3SSxRQUFMLENBQWNsTixLQUFkLENBQW9Cb0wsTUFBckM7QUFDQSw0QkFBTXVMLFNBQVUsQ0FBQ3RNLFNBQVMsS0FBS29CLElBQUwsQ0FBVW5ELEtBQW5CLEVBQTBCLEdBQTFCLENBQUYsR0FBa0MsQ0FBbEMsR0FBb0MsQ0FBbkQ7QUFDQSw0QkFBTXNPLGFBQWEsS0FBSzFKLFFBQUwsQ0FBYy9NLE9BQWQsQ0FBc0JpTCxNQUF6QztBQUNBLDRCQUFNbkwsUUFBUSxLQUFLaU4sUUFBTCxDQUFjak4sS0FBNUI7QUFDQSw0QkFBTUMsT0FBTyxLQUFLZ04sUUFBTCxDQUFjaE4sSUFBM0I7O0FBRUEsNEJBQUlpTSxjQUFKO0FBQ0EsNEJBQUlsTSxVQUFVLEdBQWQsRUFBbUI7QUFDZmtNLG9DQUFRLENBQVI7QUFDSCx5QkFGRCxNQUVPO0FBQ0hBLG9DQUFTak0sU0FBUyxHQUFULElBQWdCeVcsV0FBVyxDQUEzQixJQUFnQ1osV0FBVyxDQUE1QyxHQUErQ0EsV0FBVyxDQUExRCxHQUE0REEsUUFBcEU7QUFDSDs7QUFFRCw0QkFBSTdKLFlBQUo7QUFDQSw0QkFBSWpNLFVBQVUsR0FBZCxFQUFtQjtBQUNmaU0sa0NBQU0rSixXQUFXVyxVQUFqQjtBQUNILHlCQUZELE1BRU87QUFDSCxvQ0FBUTFXLElBQVI7QUFDSSxxQ0FBSyxHQUFMO0FBQ0lnTSwwQ0FBTStKLFlBQVlXLGFBQWFiLFFBQXpCLENBQU47QUFDQTtBQUNKLHFDQUFLLEdBQUw7QUFDSTdKLDBDQUFPNkosV0FBVyxDQUFaLEdBQWVFLFlBQVlGLFdBQVdZLE1BQVgsR0FBb0JDLFVBQWhDLENBQWYsR0FBMkRYLFlBQVlGLFdBQVdhLFVBQXZCLENBQWpFO0FBQ0E7QUFDSjtBQUNJMUssMENBQU0rSixZQUFZRixXQUFXYSxVQUF2QixDQUFOO0FBUlI7QUFVSDs7QUFFRHZLLDRDQUFvQixLQUFLWixJQUF6QixFQUErQlUsS0FBL0IsRUFBc0NELEdBQXRDO0FBQ0g7O0FBRUQsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksQ0FBQ3NJLFdBQVdDLE1BQVosTUFBd0JJLFdBQVdyVCxRQUFRaUMsQ0FBbkIsSUFBd0JvUixXQUFXclQsUUFBUW9ELENBQTNDLElBQWdEaVEsV0FBV3JULFFBQVFzRCxDQUEzRixDQUFKLEVBQW1HO0FBQy9GLHdCQUFJbkIsRUFBRWlSLElBQUYsS0FBVyxTQUFmLEVBQTBCO0FBQ3RCLDZCQUFLaUMsc0JBQUw7QUFDSDs7QUFFRDtBQUNBLHdCQUFJaEMsV0FBV3JULFFBQVFvRCxDQUFuQixJQUF3QmlRLFdBQVdyVCxRQUFRbUIsTUFBL0MsRUFBdUQ7QUFDbkQsNEJBQUlnQixFQUFFaVIsSUFBRixLQUFXLFNBQVgsSUFBd0JqUixFQUFFaVIsSUFBRixLQUFXLFVBQXZDLEVBQW1EO0FBQy9DLGdDQUFJck0sWUFBWSxLQUFLNk4scUJBQWpCLENBQUosRUFBNkM7QUFDekMscUNBQUtBLHFCQUFMLEdBQTZCLEtBQUtoQixlQUFMLEVBQTdCO0FBQ0g7QUFDSix5QkFKRCxNQUlPO0FBQ0gsaUNBQUtxQixXQUFMO0FBQ0g7QUFDSjs7QUFFRCwyQkFBTzlTLEVBQUVpUixJQUFGLEtBQVcsU0FBWCxJQUF3QmpSLEVBQUVpUixJQUFGLEtBQVcsVUFBbkMsSUFBaURDLFdBQVdyVCxRQUFRaUMsQ0FBM0U7QUFDSDs7QUFFRCxvQkFBSStRLFdBQVdDLE1BQWYsRUFBdUI7QUFDbkIsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUlJLFdBQVdyVCxRQUFRZSxTQUFuQixJQUFnQ3NTLFdBQVdyVCxRQUFRaUIsVUFBdkQsRUFBbUU7QUFDL0Qsd0JBQU05QyxPQUFPLEtBQUt3SyxhQUFMLENBQW1CeEssSUFBaEM7QUFDQSx3QkFBTUcsT0FBTyxLQUFLcUssYUFBTCxDQUFtQnJLLElBQWhDO0FBQ0Esd0JBQU1nWCxZQUFZLEtBQUsvSyxTQUFMLENBQWVJLEtBQWpDO0FBQ0Esd0JBQU03RCxRQUFRLEtBQUttRCxJQUFMLENBQVVuRCxLQUF4QjtBQUNBLHdCQUFJM0UsRUFBRWlSLElBQUYsS0FBVyxTQUFYLElBQXdCLENBQUMsS0FBS0QsUUFBbEMsRUFBNEM7QUFDeEMsNEJBQUlFLFdBQVdyVCxRQUFRZSxTQUFuQixLQUFpQytGLE1BQU1nRyxNQUFOLENBQWF3SSxZQUFZLENBQXpCLE1BQWdDblgsSUFBaEMsSUFBd0MySSxNQUFNZ0csTUFBTixDQUFhd0ksWUFBWSxDQUF6QixNQUFnQ2hYLElBQXpHLENBQUosRUFBb0g7QUFDaEgsaUNBQUsrVixZQUFMLENBQWtCaUIsWUFBWSxDQUE5QjtBQUNILHlCQUZELE1BRU8sSUFBSWpDLFdBQVdyVCxRQUFRaUIsVUFBbkIsS0FBa0M2RixNQUFNZ0csTUFBTixDQUFhd0ksWUFBWSxDQUF6QixNQUFnQ25YLElBQWhDLElBQXdDMkksTUFBTWdHLE1BQU4sQ0FBYXdJLFlBQVksQ0FBekIsTUFBZ0NoWCxJQUExRyxDQUFKLEVBQXFIO0FBQ3hILGlDQUFLK1YsWUFBTCxDQUFrQmlCLFlBQVksQ0FBOUI7QUFDSDtBQUNKO0FBQ0QsMkJBQU8sSUFBUDtBQUNIOztBQUVELHVCQUFPakMsVUFBVXJULFFBQVFZLFFBQWxCLElBQThCeVMsVUFBVXJULFFBQVFrQixTQUF2RDtBQUNIOztBQUVEOzs7O0FBdjdDRDtBQUFBO0FBQUEsbURBMDdDaUM7QUFBQTtBQUFBLG9CQUFkd1MsSUFBYztBQUFBLG9CQUFSQyxLQUFROztBQUM1QixvQkFBTWhMLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLG9CQUFJQSxjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQTFELEVBQStEO0FBQzNELHdCQUFJLEtBQUsyVSxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CMUssc0NBQWM0TSxRQUFkLEdBQTBCLEtBQUtoTCxTQUFMLENBQWVJLEtBQWYsSUFBd0IsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNoSyxPQUFqQyxDQUF4QixJQUFxRWdLLGNBQWNoSyxPQUFkLEtBQTBCLEVBQXpIO0FBQ0EsNEJBQUksS0FBS21JLEtBQUwsQ0FBV2dHLE1BQVgsQ0FBa0IsS0FBS3ZDLFNBQUwsQ0FBZUksS0FBZixHQUF1QixDQUF6QyxNQUFnRCxHQUFwRCxFQUF5RDtBQUNyRCtJLG1DQUFPQSxLQUFLbkYsU0FBTCxDQUFlLENBQWYsQ0FBUDtBQUNILHlCQUZELE1BRU8sSUFBSSxLQUFLaEUsU0FBTCxDQUFlSSxLQUFmLElBQXdCLEtBQUs3RCxLQUFMLENBQVc4QyxNQUFYLEdBQW9CakIsY0FBY2hLLE9BQWQsQ0FBc0JpTCxNQUF0RSxFQUE4RTtBQUNqRjhKLG1DQUFPQSxLQUFLbkYsU0FBTCxDQUFlLENBQWYsRUFBa0JtRixLQUFLOUosTUFBTCxHQUFjLENBQWhDLENBQVA7QUFDSDtBQUNKLHFCQVBELE1BT087QUFDSGpCLHNDQUFjNE0sUUFBZCxHQUEwQixLQUFLaEwsU0FBTCxDQUFlSSxLQUFmLElBQXdCLEtBQUs3RCxLQUFMLENBQVdpQyxPQUFYLENBQW1CSixjQUFjaEssT0FBakMsQ0FBeEIsSUFBcUVnSyxjQUFjaEssT0FBZCxLQUEwQixFQUF6SDtBQUNBLDRCQUFJLEtBQUs0TCxTQUFMLENBQWVJLEtBQWYsSUFBd0IsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNuSyxLQUFqQyxJQUEwQ21LLGNBQWNuSyxLQUFkLENBQW9Cb0wsTUFBMUYsRUFBa0c7QUFDOUYrSixvQ0FBUUEsTUFBTXBGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUJvRixNQUFNL0osTUFBekIsQ0FBUjtBQUNIO0FBQ0QsNEJBQUlmLFNBQVM2SyxJQUFULEVBQWUsR0FBZixLQUF1QixLQUFLNU0sS0FBTCxDQUFXZ0csTUFBWCxDQUFrQixLQUFLdkMsU0FBTCxDQUFlSSxLQUFqQyxNQUE0QyxHQUF2RSxFQUE0RTtBQUN4RStJLG1DQUFPQSxLQUFLbkYsU0FBTCxDQUFlLENBQWYsQ0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxvQkFBSTVGLGNBQWNsSyxLQUFkLEtBQXdCLEdBQXhCLElBQStCa0ssY0FBY2pLLElBQWQsS0FBdUIsR0FBMUQsRUFBK0Q7QUFDM0RpSyxrQ0FBYzRNLFFBQWQsR0FBMEIsS0FBS2hMLFNBQUwsQ0FBZUksS0FBZixJQUF3QixLQUFLN0QsS0FBTCxDQUFXaUMsT0FBWCxDQUFtQkosY0FBY2lFLElBQWpDLElBQXlDakUsY0FBY2lFLElBQWQsQ0FBbUJoRCxNQUE5RztBQUNBLHdCQUFJLEtBQUt5SixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLDRCQUFJLEtBQUs5SSxTQUFMLENBQWVJLEtBQWYsS0FBMEIsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNpRSxJQUFqQyxJQUF5Q2pFLGNBQWNpRSxJQUFkLENBQW1CaEQsTUFBdEYsSUFBaUdmLFNBQVMsS0FBSy9CLEtBQWQsRUFBcUI2QixjQUFjaUUsSUFBbkMsQ0FBckcsRUFBK0k7QUFDM0k4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSCx5QkFGRCxNQUVPLElBQUltRixTQUFTLEdBQVQsS0FBa0IsS0FBS25KLFNBQUwsQ0FBZUksS0FBZixJQUF3QixLQUFLN0QsS0FBTCxDQUFXaUMsT0FBWCxDQUFtQkosY0FBY2lFLElBQWpDLENBQXpCLElBQW9FLENBQUMvRCxTQUFTLEtBQUsvQixLQUFkLEVBQXFCNkIsY0FBY2lFLElBQW5DLENBQXRGLENBQUosRUFBcUk7QUFDeEk4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLEVBQWtCbUYsS0FBSzlKLE1BQUwsR0FBYyxDQUFoQyxDQUFQO0FBQ0g7QUFDSixxQkFORCxNQU1PO0FBQ0gsNEJBQUk4SixLQUFLLENBQUwsTUFBWSxHQUFoQixFQUFxQjtBQUNqQkMsb0NBQVFBLE1BQU1wRixTQUFOLENBQWdCLENBQWhCLENBQVI7QUFDSDtBQUNELDRCQUFJLEtBQUtoRSxTQUFMLENBQWVJLEtBQWYsS0FBeUIsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNpRSxJQUFqQyxDQUF6QixJQUFtRS9ELFNBQVMsS0FBSy9CLEtBQWQsRUFBcUI2QixjQUFjaUUsSUFBbkMsQ0FBdkUsRUFBaUg7QUFDN0c4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsb0JBQUk1RixjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQTFELEVBQStEO0FBQzNEaUssa0NBQWM0TSxRQUFkLEdBQTBCLEtBQUtoTCxTQUFMLENBQWVJLEtBQWYsSUFBd0IsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNpRSxJQUFqQyxJQUF5Q2pFLGNBQWNpRSxJQUFkLENBQW1CaEQsTUFBOUc7QUFDQSx3QkFBSSxLQUFLeUosTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQiw0QkFBSSxLQUFLOUksU0FBTCxDQUFlSSxLQUFmLEtBQTBCLEtBQUs3RCxLQUFMLENBQVdpQyxPQUFYLENBQW1CSixjQUFjaUUsSUFBakMsSUFBeUNqRSxjQUFjaUUsSUFBZCxDQUFtQmhELE1BQTFGLEVBQW1HO0FBQy9GOEosbUNBQU9BLEtBQUtuRixTQUFMLENBQWUsQ0FBZixDQUFQO0FBQ0gseUJBRkQsTUFFTyxJQUFJbUYsU0FBUyxHQUFULElBQWdCLEtBQUtuSixTQUFMLENBQWVJLEtBQWYsSUFBeUIsS0FBSzdELEtBQUwsQ0FBV2lDLE9BQVgsQ0FBbUJKLGNBQWNpRSxJQUFqQyxJQUF5Q2pFLGNBQWNuSyxLQUFkLENBQW9Cb0wsTUFBMUcsRUFBbUg7QUFDdEg4SixtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLEVBQWtCbUYsS0FBSzlKLE1BQUwsR0FBYyxDQUFoQyxDQUFQO0FBQ0gseUJBRk0sTUFFQSxJQUFJOEosU0FBUyxFQUFULElBQWUsQ0FBQzdLLFNBQVMsS0FBSy9CLEtBQWQsRUFBcUI2QixjQUFjaUUsSUFBbkMsQ0FBcEIsRUFBOEQ7QUFDakU4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLEVBQWtCbUYsS0FBSzlKLE1BQUwsR0FBYyxDQUFoQyxDQUFQO0FBQ0g7QUFDSixxQkFSRCxNQVFPO0FBQ0hqQixzQ0FBYzRNLFFBQWQsR0FBMEIsS0FBS2hMLFNBQUwsQ0FBZUksS0FBZixJQUF3QixLQUFLN0QsS0FBTCxDQUFXaUMsT0FBWCxDQUFtQkosY0FBY25LLEtBQWpDLENBQXhCLElBQW1FbUssY0FBY25LLEtBQWQsS0FBd0IsRUFBckg7QUFDQSw0QkFBSSxLQUFLK0wsU0FBTCxDQUFlSSxLQUFmLEtBQXlCLEtBQUs3RCxLQUFMLENBQVdpQyxPQUFYLENBQW1CSixjQUFjaUUsSUFBakMsQ0FBN0IsRUFBcUU7QUFDakU4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSDtBQUNEb0YsZ0NBQVFBLE1BQU1wRixTQUFOLENBQWdCLENBQWhCLENBQVI7QUFDSDtBQUNKOztBQUVELHVCQUFPLENBQUNtRixJQUFELEVBQU9DLEtBQVAsQ0FBUDtBQUNIOztBQUVEOzs7O0FBdi9DRDtBQUFBO0FBQUEsd0RBMC9DNkI7QUFDeEIsb0JBQU1oTCxnQkFBZ0IsS0FBS0EsYUFBM0I7O0FBRUEsb0JBQUkrSyxhQUFKO0FBQ0Esb0JBQUlDLGNBQUo7O0FBRUEsb0JBQUksQ0FBQyxLQUFLcEosU0FBTCxDQUFlWCxNQUFwQixFQUE0QjtBQUFBLGdEQUNSLEtBQUs0TCx1QkFBTCxFQURROztBQUFBOztBQUN2QjlCLHdCQUR1QjtBQUNqQkMseUJBRGlCOztBQUV4Qix3QkFBSUQsU0FBUyxFQUFULElBQWVDLFVBQVUsRUFBN0IsRUFBaUM7QUFDN0JoTCxzQ0FBYzhNLFVBQWQsR0FBMkIsS0FBM0I7QUFDSDs7QUFFRCx3QkFBSSxDQUFFOU0sY0FBY2xLLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0JrSyxjQUFjakssSUFBZCxLQUF1QixHQUF2RCxJQUNDaUssY0FBY2xLLEtBQWQsS0FBd0IsR0FBeEIsS0FBZ0NrSyxjQUFjakssSUFBZCxLQUF1QixHQUF2QixJQUE4QmlLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQXJGLENBREYsS0FFQ21LLFNBQVMsS0FBSy9CLEtBQWQsRUFBcUIsR0FBckIsQ0FGTCxFQUVnQztBQUFBLGdEQUNaLEtBQUs0TyxnQkFBTCxDQUFzQixDQUFDaEMsSUFBRCxFQUFPQyxLQUFQLENBQXRCLENBRFk7O0FBQUE7O0FBQzNCRCw0QkFEMkI7QUFDckJDLDZCQURxQjtBQUUvQixxQkFKRCxNQUlPO0FBQ0gsNEJBQUksS0FBS04sTUFBTCxLQUFnQnJULFFBQVFDLFNBQTVCLEVBQXVDO0FBQ25DeVQsbUNBQU9BLEtBQUtuRixTQUFMLENBQWUsQ0FBZixFQUFrQm1GLEtBQUs5SixNQUFMLEdBQWMsQ0FBaEMsQ0FBUDtBQUNILHlCQUZELE1BRU87QUFDSCtKLG9DQUFRQSxNQUFNcEYsU0FBTixDQUFnQixDQUFoQixFQUFtQm9GLE1BQU0vSixNQUF6QixDQUFSO0FBQ0g7QUFDSjtBQUNKLGlCQWpCRCxNQWlCTztBQUNILHlCQUFLeUwsc0JBQUwsQ0FBNEIsS0FBNUI7O0FBREcsaURBRWEsS0FBS0csdUJBQUwsRUFGYjs7QUFBQTs7QUFFRjlCLHdCQUZFO0FBRUlDLHlCQUZKO0FBR047O0FBRUQscUJBQUtxQixjQUFMLENBQW9CdEIsSUFBcEIsRUFBMEJDLEtBQTFCO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUF6aEREO0FBQUE7QUFBQSx5REEraEQ4QjtBQUN6QixvQkFBTWhMLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLG9CQUFNZ04sUUFBUXhPLE9BQU95TyxZQUFQLENBQW9CLEtBQUs3TCxLQUF6QixDQUFkOztBQUZ5Qiw2Q0FHTCxLQUFLeUwsdUJBQUwsRUFISztBQUFBO0FBQUEsb0JBR3BCOUIsSUFIb0I7QUFBQSxvQkFHZEMsS0FIYzs7QUFJekJoTCw4QkFBYzhNLFVBQWQsR0FBMkIsSUFBM0I7O0FBRUE7QUFDQTtBQUNBLG9CQUFJRSxVQUFVaE4sY0FBY3JLLElBQXhCLElBQ0NxSyxjQUFjcEssTUFBZCxJQUF3Qm9YLFVBQVVoTixjQUFjcEssTUFEakQsSUFFQyxDQUFDb1gsVUFBVSxHQUFWLElBQWlCQSxVQUFVLEdBQTVCLEtBQW9DLEtBQUt0QyxNQUFMLEtBQWdCclQsUUFBUXdFLFNBRmpFLEVBRTZFO0FBQ3pFLHdCQUFJLENBQUNtRSxjQUFjNUosSUFBZixJQUF1QixDQUFDNEosY0FBY3JLLElBQTFDLEVBQWdEO0FBQzVDLCtCQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLHdCQUFJcUssY0FBY2lFLElBQWQsSUFBc0IvRCxTQUFTOEssS0FBVCxFQUFnQmhMLGNBQWNpRSxJQUE5QixDQUExQixFQUErRDtBQUMzRCwrQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQSx3QkFBSS9ELFNBQVM2SyxJQUFULEVBQWUvSyxjQUFjckssSUFBN0IsQ0FBSixFQUF3QztBQUNwQywrQkFBTyxJQUFQO0FBQ0g7O0FBRUQsd0JBQUlxVixNQUFNNUssT0FBTixDQUFjSixjQUFjckssSUFBNUIsSUFBb0MsQ0FBeEMsRUFBMkM7QUFDdkMsK0JBQU8sSUFBUDtBQUNIOztBQUVELHdCQUFJcVYsTUFBTTVLLE9BQU4sQ0FBY0osY0FBY3JLLElBQTVCLE1BQXNDLENBQTFDLEVBQTZDO0FBQ3pDcVYsZ0NBQVFBLE1BQU1vQixNQUFOLENBQWEsQ0FBYixDQUFSO0FBQ0g7O0FBRUQseUJBQUtDLGNBQUwsQ0FBb0J0QixPQUFPL0ssY0FBY3JLLElBQXpDLEVBQStDcVYsS0FBL0MsRUFBc0QsSUFBdEQ7O0FBRUEsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUksQ0FBQ2dDLFVBQVUsR0FBVixJQUFpQkEsVUFBVSxHQUE1QixLQUFvQ2hOLGNBQWNpRSxJQUFkLEtBQXVCLEdBQS9ELEVBQW9FO0FBQ2hFLHdCQUFJLENBQUNqRSxhQUFMLEVBQW9CO0FBQ2hCLCtCQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLHdCQUFLQSxjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQXZELElBQWdFaUssY0FBY2xLLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0JrSyxjQUFjakssSUFBZCxLQUF1QixHQUExSCxFQUFnSTtBQUM1SCw0QkFBSWdWLFNBQVMsRUFBVCxJQUFlN0ssU0FBUzhLLEtBQVQsRUFBZ0JoTCxjQUFjaUUsSUFBOUIsQ0FBbkIsRUFBd0Q7QUFDcEQ4RyxtQ0FBTy9LLGNBQWNpRSxJQUFyQjtBQUNBK0csb0NBQVFBLE1BQU1wRixTQUFOLENBQWdCLENBQWhCLEVBQW1Cb0YsTUFBTS9KLE1BQXpCLENBQVI7QUFDSDs7QUFFRDtBQUNBLDRCQUFJOEosS0FBSzVHLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLElBQTBCakUsU0FBUzZLLElBQVQsRUFBZS9LLGNBQWNpRSxJQUE3QixDQUE5QixFQUFrRTtBQUM5RDhHLG1DQUFPQSxLQUFLbkYsU0FBTCxDQUFlLENBQWYsRUFBa0JtRixLQUFLOUosTUFBdkIsQ0FBUDtBQUNILHlCQUZELE1BRU87QUFDSDhKLG1DQUFRaUMsVUFBVSxHQUFYLEdBQWtCaE4sY0FBY2lFLElBQWQsR0FBcUI4RyxJQUF2QyxHQUE4Q0EsSUFBckQ7QUFDSDtBQUNKLHFCQVpELE1BWU87QUFDSCw0QkFBSUEsU0FBUyxFQUFULElBQWU3SyxTQUFTOEssS0FBVCxFQUFnQmhMLGNBQWNpRSxJQUE5QixDQUFuQixFQUF3RDtBQUNwRDhHLG1DQUFPL0ssY0FBY2lFLElBQXJCO0FBQ0ErRyxvQ0FBUUEsTUFBTXBGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUJvRixNQUFNL0osTUFBekIsQ0FBUjtBQUNIOztBQUVEO0FBQ0EsNEJBQUk4SixLQUFLNUcsTUFBTCxDQUFZLENBQVosTUFBbUJuRSxjQUFjaUUsSUFBckMsRUFBMkM7QUFDdkM4RyxtQ0FBT0EsS0FBS25GLFNBQUwsQ0FBZSxDQUFmLEVBQWtCbUYsS0FBSzlKLE1BQXZCLENBQVA7QUFDSCx5QkFGRCxNQUVPO0FBQ0g4SixtQ0FBUWlDLFVBQVUsR0FBWCxHQUFrQmhOLGNBQWNpRSxJQUFkLEdBQXFCOEcsSUFBdkMsR0FBOENBLElBQXJEO0FBQ0g7QUFDSjs7QUFFRCx5QkFBS3NCLGNBQUwsQ0FBb0J0QixJQUFwQixFQUEwQkMsS0FBMUIsRUFBaUMsSUFBakM7O0FBRUEsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUlnQyxTQUFTLEdBQVQsSUFBZ0JBLFNBQVMsR0FBN0IsRUFBa0M7QUFDOUIsd0JBQUloTixjQUFjaUUsSUFBZCxJQUFzQjhHLFNBQVMsRUFBL0IsSUFBcUM3SyxTQUFTOEssS0FBVCxFQUFnQmhMLGNBQWNpRSxJQUE5QixDQUF6QyxFQUE4RTtBQUMxRThHLCtCQUFPL0ssY0FBY2lFLElBQXJCO0FBQ0ErRyxnQ0FBUUEsTUFBTXBGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUJvRixNQUFNL0osTUFBekIsQ0FBUjtBQUNIOztBQUVELHdCQUFJakIsY0FBYzlKLElBQWQsSUFBc0IsQ0FBdEIsSUFBMkI4SixjQUFjN0osSUFBZCxHQUFxQjZKLGNBQWM5SixJQUE5RCxJQUFzRSxDQUFDZ0ssU0FBUyxLQUFLL0IsS0FBZCxFQUFxQjZCLGNBQWNpRSxJQUFuQyxDQUF2RSxJQUFtSCtJLFVBQVUsR0FBakksRUFBc0k7QUFDbElqQywrQkFBTy9LLGNBQWNpRSxJQUFkLEdBQXFCOEcsSUFBNUI7QUFDSDs7QUFFRCx5QkFBS3NCLGNBQUwsQ0FBb0J0QixPQUFPaUMsS0FBM0IsRUFBa0NoQyxLQUFsQyxFQUF5QyxJQUF6Qzs7QUFFQSwyQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQWhMLDhCQUFjOE0sVUFBZCxHQUEyQixLQUEzQjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7QUFqb0REO0FBQUE7QUFBQSx5Q0Fvb0RjdFQsQ0Fwb0RkLEVBb29EaUI7QUFBQTs7QUFDWixvQkFBTXdHLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLG9CQUFNa04sYUFBYSxLQUFLL08sS0FBeEI7QUFDQSxvQkFBTWdQLGVBQWUzVCxFQUFFbkMsT0FBdkI7O0FBSFksNkNBSUMsS0FBS3dWLHVCQUFMLEVBSkQ7QUFBQTtBQUFBLG9CQUlQOUIsSUFKTzs7QUFNWjs7O0FBQ0Esb0JBQUksQ0FBQy9LLGNBQWN4SyxJQUFkLEtBQXdCLEVBQXhCLElBQStCd0ssY0FBY3hLLElBQWQsS0FBdUIsRUFBdkIsSUFBOEIsQ0FBQzBLLFNBQVNnTixVQUFULEVBQXFCbE4sY0FBY3hLLElBQW5DLENBQS9ELE1BQ0N3SyxjQUFjbkssS0FBZCxLQUF3QixFQUF4QixJQUErQm1LLGNBQWNuSyxLQUFkLEtBQXdCLEVBQXhCLElBQThCLENBQUNxSyxTQUFTZ04sVUFBVCxFQUFxQmxOLGNBQWNuSyxLQUFuQyxDQUQvRCxDQUFKLEVBQ2dIO0FBQUEsNENBQzNGcVgsV0FBV3BNLEtBQVgsQ0FBaUJkLGNBQWNySyxJQUEvQixDQUQyRjtBQUFBO0FBQUEsd0JBQ3ZHeVgsUUFEdUc7O0FBRTVHLHdCQUFJdEosUUFBUSxFQUFaO0FBQ0Esd0JBQUk1RCxTQUFTa04sUUFBVCxFQUFtQixHQUFuQixDQUFKLEVBQTZCO0FBQ3pCdEosZ0NBQVEsR0FBUjtBQUNBc0osbUNBQVdBLFNBQVNuTixPQUFULENBQWlCLEdBQWpCLEVBQXNCLEVBQXRCLENBQVg7QUFDQThLLCtCQUFPQSxLQUFLOUssT0FBTCxDQUFhLEdBQWIsRUFBa0IsRUFBbEIsQ0FBUDtBQUNIOztBQUVEO0FBQ0Esd0JBQUk2RCxVQUFVLEVBQVYsSUFBZ0JzSixTQUFTbk0sTUFBVCxHQUFrQmpCLGNBQWNrRSxPQUFoRCxJQUEyRDZHLEtBQUs1RyxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFsRixFQUF1RjtBQUNuRjRHLCtCQUFPQSxLQUFLM0csS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNIOztBQUVEO0FBQ0Esd0JBQUlOLFVBQVUsR0FBVixJQUFpQnNKLFNBQVNuTSxNQUFULEdBQWtCakIsY0FBY3FFLE9BQWpELElBQTREMEcsS0FBSzVHLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5GLEVBQXdGO0FBQ3BGNEcsK0JBQU9BLEtBQUszRyxLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0g7O0FBRUQyRywyQkFBT2pILFFBQVFpSCxJQUFmO0FBQ0g7O0FBRUQsb0JBQU01TSxRQUFRbUgsVUFBVSxLQUFLbkgsS0FBZixFQUFzQixLQUFLNkIsYUFBM0IsQ0FBZDtBQUNBLG9CQUFJdUIsV0FBV3BELE1BQU04QyxNQUFyQjtBQUNBLG9CQUFJOUMsS0FBSixFQUFXO0FBQ1A7QUFDQSx3QkFBTWtQLFNBQVN0QyxLQUFLakssS0FBTCxDQUFXLEVBQVgsQ0FBZjs7QUFFQTtBQUNBLHdCQUFJLENBQUNkLGNBQWNqSyxJQUFkLEtBQXVCLEdBQXZCLElBQStCaUssY0FBY2xLLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0JrSyxjQUFjakssSUFBZCxLQUF1QixHQUF0RixLQUNBc1gsT0FBTyxDQUFQLE1BQWMsR0FEZCxJQUNxQnJOLGNBQWNpRSxJQUFkLEtBQXVCLEVBRGhELEVBQ29EO0FBQ2hEb0osK0JBQU9DLEtBQVA7O0FBRUEsNEJBQUksQ0FBQ0gsaUJBQWlCOVYsUUFBUUMsU0FBekIsSUFBc0MsS0FBS29ULE1BQUwsS0FBZ0JyVCxRQUFRQyxTQUE5RCxJQUNENlYsaUJBQWlCOVYsUUFBUW9CLE1BRHhCLElBQ2tDLEtBQUtpUyxNQUFMLEtBQWdCclQsUUFBUW9CLE1BRDNELEtBRUF1SCxjQUFjNE0sUUFGbEIsRUFFNEI7QUFDeEIsZ0NBQUk1TSxjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQTFELEVBQStEO0FBQzNEc1gsdUNBQU9FLElBQVAsQ0FBWSxHQUFaO0FBQ0F2Tiw4Q0FBYzRNLFFBQWQsR0FBeUJwVCxFQUFFaVIsSUFBRixLQUFXLFNBQXBDO0FBQ0g7O0FBRUQsZ0NBQUl6SyxjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQTFELEVBQStEO0FBQzNEc1gsdUNBQU9FLElBQVAsQ0FBWSxHQUFaO0FBQ0F2Tiw4Q0FBYzRNLFFBQWQsR0FBeUJwVCxFQUFFaVIsSUFBRixLQUFXLFNBQXBDO0FBQ0g7O0FBRUQsZ0NBQUl6SyxjQUFjbEssS0FBZCxLQUF3QixHQUF4QixJQUErQmtLLGNBQWNqSyxJQUFkLEtBQXVCLEdBQTFELEVBQStEO0FBQUE7QUFDM0Qsd0NBQU15WCxZQUFZeE4sY0FBY25LLEtBQWQsQ0FBb0JpTCxLQUFwQixDQUEwQixFQUExQixDQUFsQjtBQUNBLHdDQUFNMk0sWUFBWSxDQUFDLElBQUQsRUFBTyxHQUFQLEVBQVksR0FBWixFQUFpQixHQUFqQixFQUFzQixHQUF0QixFQUEyQixHQUEzQixFQUFnQyxHQUFoQyxFQUFxQyxHQUFyQyxFQUEwQyxHQUExQyxFQUErQyxHQUEvQyxFQUFvRCxHQUFwRCxDQUFsQjtBQUNBLHdDQUFNQyxlQUFlLEVBQXJCO0FBQ0ExSyxzQ0FBRUMsSUFBRixDQUFPdUssU0FBUCxFQUFrQixVQUFDNVQsQ0FBRCxFQUFJK1QsU0FBSixFQUFrQjtBQUNoQ0Esb0RBQVlILFVBQVU1VCxDQUFWLENBQVo7QUFDQSw0Q0FBSXlHLFVBQVVzTixTQUFWLEVBQXFCRixTQUFyQixDQUFKLEVBQXFDO0FBQ2pDQyx5REFBYUgsSUFBYixDQUFrQixPQUFPSSxTQUF6QjtBQUNILHlDQUZELE1BRU87QUFDSEQseURBQWFILElBQWIsQ0FBa0JJLFNBQWxCO0FBQ0g7QUFDSixxQ0FQRDs7QUFTQSx3Q0FBSVIsaUJBQWlCOVYsUUFBUUMsU0FBekIsSUFBc0MsTUFBS29ULE1BQUwsS0FBZ0JyVCxRQUFRQyxTQUFsRSxFQUE2RTtBQUN6RW9XLHFEQUFhSCxJQUFiLENBQWtCLEdBQWxCO0FBQ0g7O0FBRUQ7QUFDQUYsMkNBQU9FLElBQVAsQ0FBWUcsYUFBYTdKLElBQWIsQ0FBa0IsRUFBbEIsQ0FBWjtBQUNBN0Qsa0RBQWM0TSxRQUFkLEdBQXlCcFQsRUFBRWlSLElBQUYsS0FBVyxTQUFwQztBQW5CMkQ7QUFvQjlEO0FBQ0o7QUFDSjs7QUFFRCx5QkFBSyxJQUFJN1EsSUFBSSxDQUFiLEVBQWdCQSxJQUFJeVQsT0FBT3BNLE1BQTNCLEVBQW1DckgsR0FBbkMsRUFBd0M7QUFDcEMsNEJBQUksQ0FBQ3lULE9BQU96VCxDQUFQLEVBQVUrSixLQUFWLENBQWdCLEtBQWhCLENBQUwsRUFBNkI7QUFDekIwSixtQ0FBT3pULENBQVAsSUFBWSxPQUFPeVQsT0FBT3pULENBQVAsQ0FBbkI7QUFDSDtBQUNKOztBQUVELHdCQUFNZ1UsVUFBVSxJQUFJMUgsTUFBSixDQUFXLFNBQVNtSCxPQUFPeEosSUFBUCxDQUFZLEtBQVosQ0FBcEIsQ0FBaEI7O0FBRUE7QUFDQSx3QkFBTWdLLFVBQVUxUCxNQUFNd0YsS0FBTixDQUFZaUssT0FBWixDQUFoQjtBQUNBLHdCQUFJQyxPQUFKLEVBQWE7QUFDVHRNLG1DQUFXc00sUUFBUSxDQUFSLEVBQVc1TSxNQUF0Qjs7QUFFQTtBQUNBLDRCQUFJLENBQUVNLGFBQWEsQ0FBYixJQUFrQnBELE1BQU1nRyxNQUFOLENBQWEsQ0FBYixNQUFvQm5FLGNBQWNpRSxJQUFyRCxJQUErRDFDLGFBQWEsQ0FBYixJQUFrQnBELE1BQU1nRyxNQUFOLENBQWEsQ0FBYixNQUFvQm5FLGNBQWNpRSxJQUFwSCxLQUE4SGpFLGNBQWNuSyxLQUE1SSxJQUFxSm1LLGNBQWNsSyxLQUFkLEtBQXdCLEdBQWpMLEVBQXNMO0FBQ2xMO0FBQ0F5TCx1Q0FBVyxLQUFLdkIsYUFBTCxDQUFtQm5LLEtBQW5CLENBQXlCb0wsTUFBekIsSUFBbUM5QyxNQUFNZ0csTUFBTixDQUFhLENBQWIsTUFBb0IsR0FBcEIsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBakUsQ0FBWDtBQUNIO0FBQ0oscUJBUkQsTUFRTztBQUNILDRCQUFJbkUsY0FBY25LLEtBQWQsSUFBdUJtSyxjQUFjbEssS0FBZCxLQUF3QixHQUFuRCxFQUF3RDtBQUNwRDtBQUNBO0FBQ0F5TCx3Q0FBWXZCLGNBQWNuSyxLQUFkLENBQW9Cb0wsTUFBaEM7QUFDSDs7QUFFRCw0QkFBSWpCLGNBQWNoSyxPQUFsQixFQUEyQjtBQUN2QjtBQUNBO0FBQ0F1TCx3Q0FBWXZCLGNBQWNoSyxPQUFkLENBQXNCaUwsTUFBbEM7QUFDSDtBQUNKO0FBQ0o7O0FBRUQscUJBQUtLLElBQUwsQ0FBVW5ELEtBQVYsR0FBa0JBLEtBQWxCO0FBQ0EscUJBQUt1TixZQUFMLENBQWtCbkssUUFBbEI7QUFDQSxxQkFBSzZJLFNBQUwsR0FBaUIsSUFBakI7QUFDSDtBQXR2REY7O0FBQUE7QUFBQTs7QUF5dkRIOzs7Ozs7Ozs7Ozs7Ozs7OztBQWVBLGFBQVMwRCxpQkFBVCxHQUEwRDtBQUFBLFlBQS9CQyxnQkFBK0IsdUVBQVosSUFBWTtBQUFBLFlBQU56TSxJQUFNOztBQUN0RCxZQUFNd0IsUUFBUWlGLFFBQVF6RyxJQUFSLENBQWQ7QUFDQSxZQUFNME0sWUFBWWhMLEVBQUUsTUFBRixFQUFVaUwsS0FBVixDQUFnQm5MLEtBQWhCLENBQWxCO0FBQ0EsWUFBTW9MLGtCQUFrQmxMLGVBQWFnTCxTQUFiLFFBQTJCLENBQTNCLENBQXhCO0FBQ0EsWUFBTUcsVUFBVSxFQUFoQjs7QUFFQTtBQUNBLFlBQU1DLFVBQVUsRUFBaEI7O0FBRUE7QUFDQSxZQUFNQyxrQkFBa0IsdUNBQXhCOztBQUVBO0FBQ0EsWUFBTUMsZUFBZSxvQ0FBckI7O0FBRUE7QUFDQSxZQUFNQyxpQkFBaUIsdUJBQXZCO0FBQ0EsWUFBTUMsdUJBQXVCLCtJQUE3Qjs7QUFFQSxZQUFJQyxRQUFRLENBQVo7O0FBRUE7QUFDQXpMLFVBQUVDLElBQUYsQ0FBT2lMLGVBQVAsRUFBd0IsVUFBQ3RVLENBQUQsRUFBSThVLEtBQUosRUFBYztBQUNsQyxnQkFBSUEsTUFBTTVGLElBQU4sS0FBZSxFQUFmLElBQXFCd0YsYUFBYTNJLElBQWIsQ0FBa0IrSSxNQUFNQyxTQUF4QixDQUFyQixJQUEyRCxDQUFDTixnQkFBZ0IxSSxJQUFoQixDQUFxQitJLE1BQU1qRSxJQUEzQixDQUE1RCxJQUFnRyxDQUFDaUUsTUFBTUUsUUFBdkcsS0FBb0hGLE1BQU1HLE9BQU4sSUFBaUIsQ0FBQ04sZUFBZTVJLElBQWYsQ0FBb0IrSSxNQUFNakUsSUFBMUIsQ0FBdEksQ0FBSixFQUE0SztBQUN4SzJELHdCQUFRYixJQUFSLENBQWFrQixLQUFiO0FBQ0FBO0FBQ0gsYUFIRCxNQUdPO0FBQ0hMLHdCQUFRYixJQUFSLENBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDSixTQVBEOztBQVNBO0FBQ0FrQixnQkFBUSxDQUFSO0FBQ0F6TCxVQUFFQyxJQUFGLENBQU9pTCxlQUFQLEVBQXdCLFVBQUN0VSxDQUFELEVBQUk4VSxLQUFKLEVBQWM7QUFDbEMsZ0JBQUlBLE1BQU1DLFNBQU4sS0FBb0IsT0FBcEIsS0FBZ0NELE1BQU1qRSxJQUFOLEtBQWUsRUFBZixJQUFxQmlFLE1BQU1qRSxJQUFOLEtBQWUsTUFBcEMsSUFBOENpRSxNQUFNakUsSUFBTixLQUFlLFFBQTdELElBQXlFaUUsTUFBTWpFLElBQU4sS0FBZSxLQUF4SCxDQUFKLEVBQW9JO0FBQ2hJMEQsd0JBQVFaLElBQVIsQ0FBYWtCLEtBQWI7QUFDQUE7QUFDSCxhQUhELE1BR087QUFDSE4sd0JBQVFaLElBQVIsQ0FBYSxDQUFDLENBQWQ7QUFDQSxvQkFBSW1CLE1BQU1DLFNBQU4sS0FBb0IsT0FBcEIsSUFBK0JILHFCQUFxQjdJLElBQXJCLENBQTBCK0ksTUFBTWpFLElBQWhDLENBQW5DLEVBQTBFO0FBQ3RFZ0U7QUFDSDtBQUNKO0FBQ0osU0FWRDs7QUFZQSxZQUFJVixnQkFBSixFQUFzQjtBQUNsQixnQkFBTWUsYUFBYWhNLE1BQU1pTSxjQUFOLEVBQW5COztBQUVBL0wsY0FBRUMsSUFBRixDQUFPNkwsVUFBUCxFQUFtQixVQUFDbFYsQ0FBRCxFQUFJOFUsS0FBSixFQUFjO0FBQzdCLG9CQUFNTSxZQUFZaE0sRUFBRWlNLE9BQUYsQ0FBVXJWLENBQVYsRUFBYXdVLE9BQWIsQ0FBbEI7O0FBRUEsb0JBQUlZLFlBQVksQ0FBQyxDQUFiLElBQWtCYixRQUFRYSxTQUFSLElBQXFCLENBQUMsQ0FBNUMsRUFBK0M7QUFDM0Msd0JBQU1FLFlBQVlsTSxlQUFhZ0wsU0FBYixtQkFBb0NHLFFBQVFhLFNBQVIsQ0FBcEMsT0FBbEI7QUFDQSx3QkFBTWpNLFdBQVdtTSxVQUFVL0csSUFBVixDQUFlLGFBQWYsQ0FBakI7O0FBRUEsd0JBQUksUUFBT3BGLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUIyTCw4QkFBTXZRLEtBQU4sR0FBYytRLFVBQVUvTCxXQUFWLENBQXNCLGNBQXRCLEVBQXNDekMsUUFBdEMsRUFBZDtBQUNIO0FBQ0o7QUFDSixhQVhEOztBQWFBLG1CQUFPb08sVUFBUDtBQUNILFNBakJELE1Ba0JLO0FBQUE7QUFDRDtBQUNBLG9CQUFNQSxhQUFhaE0sTUFBTXFNLFNBQU4sRUFBbkI7QUFDQSxvQkFBTUMsWUFBWU4sV0FBV2hPLEtBQVgsQ0FBaUIsR0FBakIsQ0FBbEI7O0FBRUFrQyxrQkFBRUMsSUFBRixDQUFPbU0sU0FBUCxFQUFrQixhQUFLO0FBQUEsNkNBQ2FBLFVBQVV4VixDQUFWLEVBQWFrSCxLQUFiLENBQW1CLEdBQW5CLENBRGI7QUFBQTtBQUFBLHdCQUNadU8sU0FEWTtBQUFBLHdCQUNEakssVUFEQzs7QUFFbkIsd0JBQU00SixZQUFZaE0sRUFBRWlNLE9BQUYsQ0FBVXJWLENBQVYsRUFBYXdVLE9BQWIsQ0FBbEI7O0FBRUE7QUFDQSx3QkFBSVksWUFBWSxDQUFDLENBQWIsSUFBa0JiLFFBQVFhLFNBQVIsSUFBcUIsQ0FBQyxDQUE1QyxFQUErQztBQUMzQyw0QkFBTUUsWUFBWWxNLGVBQWFnTCxTQUFiLG1CQUFvQ0csUUFBUWEsU0FBUixDQUFwQyxPQUFsQjtBQUNBLDRCQUFNak0sV0FBV21NLFVBQVUvRyxJQUFWLENBQWUsYUFBZixDQUFqQjs7QUFFQSw0QkFBSSxRQUFPcEYsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUM5QixnQ0FBSXFDLGVBQWUsSUFBbkIsRUFBeUI7QUFDckIsb0NBQU1rSyxxQkFBcUJKLFVBQVUvTCxXQUFWLENBQXNCLGNBQXRCLEVBQXNDekMsUUFBdEMsRUFBM0I7QUFDQTBPLDBDQUFVeFYsQ0FBVixJQUFrQnlWLFNBQWxCLFNBQStCQyxrQkFBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSixpQkFoQkQ7O0FBa0JBO0FBQUEsdUJBQU9GLFVBQVV2TCxJQUFWLENBQWUsR0FBZjtBQUFQO0FBdkJDOztBQUFBO0FBd0JKO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUEsYUFBUzBMLHNCQUFULENBQWdDek0sS0FBaEMsRUFBdUNoRCxNQUF2QyxFQUErQ3RHLENBQS9DLEVBQWtEO0FBQzlDLFlBQU11SixXQUFXakQsT0FBT0UsYUFBeEI7O0FBRUEsWUFBSXhHLEVBQUVpUixJQUFGLEtBQVcsU0FBWCxJQUF3QmpSLEVBQUVpUixJQUFGLEtBQVcsWUFBWCxJQUEyQixDQUFDM0gsTUFBTTBNLEVBQU4sQ0FBUyxRQUFULENBQTVCLElBQWtEek0sU0FBU2xNLE1BQVQsS0FBb0IsT0FBbEcsRUFBMkc7QUFDdkdrTSxxQkFBU3VCLEtBQVQsR0FBaUIsSUFBakI7O0FBRUEsZ0JBQUl2QixTQUFTbk0sUUFBVCxLQUFzQixJQUF0QixJQUE4Qm1NLFNBQVNrQixJQUFULEtBQWtCLEVBQXBELEVBQXdEO0FBQ3BEbkIsc0JBQU1JLEdBQU4sQ0FBVXNCLGdCQUFnQmhMLEVBQUVpVyxNQUFGLENBQVN0UixLQUF6QixFQUFnQzRFLFFBQWhDLENBQVY7QUFDSDs7QUFFRCxnQkFBSWdDLGVBQUo7QUFDQSxnQkFBSWhDLFNBQVMxTSxJQUFiLEVBQW1CO0FBQ2YwTSx5QkFBUzNNLElBQVQsR0FBZ0IyTSxTQUFTMU0sSUFBekI7QUFDQXlNLHNCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCSixTQUFTOEMsUUFBbEM7QUFDSCxhQUhELE1BR08sSUFBSTlDLFNBQVN6TSxZQUFiLEVBQTJCO0FBQzlCeU0seUJBQVMzTSxJQUFULEdBQWdCMk0sU0FBU3dGLElBQXpCO0FBQ0F6RixzQkFBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QkosU0FBUzhDLFFBQWxDO0FBQ0gsYUFITSxNQUdBLElBQUk5QyxTQUFTdE4sSUFBYixFQUFtQjtBQUN0QnNOLHlCQUFTdk4sSUFBVCxHQUFnQixFQUFoQjtBQUNBdU4seUJBQVNsTixLQUFULEdBQWlCLEVBQWpCO0FBQ0FrTix5QkFBUy9NLE9BQVQsR0FBbUIsRUFBbkI7QUFDQThNLHNCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCSixTQUFTOEMsUUFBbEM7QUFDSCxhQUxNLE1BS0EsSUFBSSxDQUFDZCxTQUFTaEYsVUFBVXZHLEVBQUVpVyxNQUFGLENBQVN0UixLQUFuQixFQUEwQjRFLFFBQTFCLENBQVYsTUFBbURBLFNBQVM4QyxRQUFoRSxFQUEwRTtBQUM3RS9DLHNCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCNEIsTUFBekI7QUFDSDs7QUFFRDtBQUNBakYsbUJBQU80UCxZQUFQLEdBQXNCbFcsRUFBRWlXLE1BQUYsQ0FBU3RSLEtBQS9CO0FBQ0EyQixtQkFBTzZQLE9BQVAsR0FBaUI3UCxPQUFPNFAsWUFBeEI7QUFDQSxnQkFBTUUsVUFBVXpLLFdBQVdyRixPQUFPNFAsWUFBbEIsRUFBZ0MzTSxRQUFoQyxFQUEwQyxJQUExQyxDQUFoQjtBQUNBLGdCQUFLNk0sWUFBWSxJQUFaLElBQW9CQSxZQUFZLEVBQWpDLElBQXdDN00sU0FBU2xNLE1BQVQsS0FBb0IsT0FBaEUsRUFBeUU7QUFDckVpTSxzQkFBTUksR0FBTixDQUFVME0sT0FBVjtBQUNIO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0EsYUFBU0MsU0FBVCxDQUFtQi9QLE1BQW5CLEVBQTJCdEcsQ0FBM0IsRUFBOEI7QUFDMUI7QUFDQSxZQUFNc1csaUJBQWlCNU8sSUFBSTFILENBQUosQ0FBdkIsQ0FGMEIsQ0FFSzs7QUFFL0IsWUFBSXNHLE9BQU93QixJQUFQLENBQVl5TyxRQUFoQixFQUEwQjtBQUN0QmpRLG1CQUFPa1EsU0FBUCxHQUFtQixJQUFuQjs7QUFFQTtBQUNIOztBQUVEO0FBQ0EsWUFBSXhXLEVBQUVuQyxPQUFGLEtBQWNBLFFBQVFHLEtBQXRCLElBQStCc0ksT0FBTzRQLFlBQVAsS0FBd0JsVyxFQUFFaVcsTUFBRixDQUFTdFIsS0FBcEUsRUFBMkU7QUFDdkU4Uix5QkFBYSxRQUFiLEVBQXVCelcsRUFBRWlXLE1BQXpCO0FBQ0EzUCxtQkFBTzRQLFlBQVAsR0FBc0JsVyxFQUFFaVcsTUFBRixDQUFTdFIsS0FBL0I7QUFDSDs7QUFFRDJCLGVBQU9vUSxzQkFBUCxDQUE4QjFXLENBQTlCLEVBaEIwQixDQWdCUTtBQUNsQ3NHLGVBQU9rUSxTQUFQLEdBQW1CLEtBQW5CO0FBQ0FsUSxlQUFPc0ssU0FBUCxHQUFtQixLQUFuQjs7QUFFQSxZQUFJdEssT0FBT3FRLFdBQVAsQ0FBbUIzVyxDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCc0csbUJBQU9rUSxTQUFQLEdBQW1CLElBQW5COztBQUVBO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJRixtQkFBbUJ6WSxRQUFRQyxTQUEzQixJQUF3Q3dZLG1CQUFtQnpZLFFBQVFvQixNQUF2RSxFQUErRTtBQUMzRXFILG1CQUFPc1EseUJBQVAsR0FEMkUsQ0FDdkM7QUFDcEN0USxtQkFBT2tRLFNBQVAsR0FBbUIsSUFBbkI7QUFDQWxRLG1CQUFPdVEsWUFBUCxDQUFvQjdXLENBQXBCOztBQUVBO0FBQ0EsZ0JBQUtBLEVBQUVpVyxNQUFGLENBQVN0UixLQUFULEtBQW1CMkIsT0FBTzZQLE9BQTNCLElBQXVDN1AsT0FBT0UsYUFBUCxDQUFxQjhNLFVBQWhFLEVBQTRFO0FBQ3hFO0FBQ0FtRCw2QkFBYSxPQUFiLEVBQXNCelcsRUFBRWlXLE1BQXhCO0FBQ0FqVyxrQkFBRStTLGNBQUYsR0FId0UsQ0FHcEQ7QUFDdkI7O0FBRUR6TSxtQkFBTzZQLE9BQVAsR0FBaUJuVyxFQUFFaVcsTUFBRixDQUFTdFIsS0FBMUI7QUFDQTJCLG1CQUFPRSxhQUFQLENBQXFCOE0sVUFBckIsR0FBa0MsSUFBbEM7O0FBRUE7QUFDSDs7QUFFRGhOLGVBQU9zSyxTQUFQLEdBQW1CLEtBQW5CLENBN0MwQixDQTZDQTtBQUM3Qjs7QUFFRDs7Ozs7Ozs7O0FBU0EsYUFBU2tHLFVBQVQsQ0FBb0J4USxNQUFwQixFQUE0QnRHLENBQTVCLEVBQStCO0FBQzNCLFlBQU1zVyxpQkFBaUI1TyxJQUFJMUgsQ0FBSixDQUF2QixDQUQyQixDQUNJOztBQUUvQjtBQUNBLFlBQUlBLEVBQUVnUixRQUFGLElBQWNzRixtQkFBbUJ6WSxRQUFRbUIsTUFBN0MsRUFBcUQ7QUFDakQ7QUFDSDs7QUFFRCxZQUFNd1gsWUFBWWxRLE9BQU9rUSxTQUF6QjtBQUNBbFEsZUFBT29RLHNCQUFQLENBQThCMVcsQ0FBOUIsRUFUMkIsQ0FTTztBQUNsQ3NHLGVBQU9rUSxTQUFQLEdBQW1CLEtBQW5CO0FBQ0FsUSxlQUFPc0ssU0FBUCxHQUFtQixLQUFuQjs7QUFFQSxZQUFJdEssT0FBT3FRLFdBQVAsQ0FBbUIzVyxDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCO0FBQ0g7O0FBRUQsWUFBSXdXLFNBQUosRUFBZTtBQUNYeFcsY0FBRStTLGNBQUY7O0FBRUE7QUFDSDs7QUFFRDtBQUNBLFlBQUl6TSxPQUFPeVEsMEJBQVAsRUFBSixFQUF5QztBQUNyQ3pRLG1CQUFPdVEsWUFBUCxDQUFvQjdXLENBQXBCO0FBQ0EsZ0JBQUtBLEVBQUVpVyxNQUFGLENBQVN0UixLQUFULEtBQW1CMkIsT0FBTzZQLE9BQTNCLElBQXVDN1AsT0FBT0UsYUFBUCxDQUFxQjhNLFVBQWhFLEVBQTRFO0FBQ3hFO0FBQ0FtRCw2QkFBYSxPQUFiLEVBQXNCelcsRUFBRWlXLE1BQXhCO0FBQ0FqVyxrQkFBRStTLGNBQUYsR0FId0UsQ0FHcEQ7QUFDdkIsYUFKRCxNQUtLO0FBQ0Q7QUFDQS9TLGtCQUFFK1MsY0FBRjtBQUNIOztBQUVEek0sbUJBQU82UCxPQUFQLEdBQWlCblcsRUFBRWlXLE1BQUYsQ0FBU3RSLEtBQTFCO0FBQ0EyQixtQkFBT0UsYUFBUCxDQUFxQjhNLFVBQXJCLEdBQWtDLElBQWxDOztBQUVBO0FBQ0g7O0FBRURoTixlQUFPc0ssU0FBUCxHQUFtQixLQUFuQjtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQSxhQUFTb0csT0FBVCxDQUFpQjFRLE1BQWpCLEVBQXlCaUQsUUFBekIsRUFBbUN2SixDQUFuQyxFQUFzQztBQUNsQyxZQUFNc1csaUJBQWlCNU8sSUFBSTFILENBQUosQ0FBdkIsQ0FEa0MsQ0FDSDs7QUFFL0JzRyxlQUFPb1Esc0JBQVAsQ0FBOEIxVyxDQUE5QixFQUhrQyxDQUdBO0FBQ2xDc0csZUFBT2tRLFNBQVAsR0FBbUIsS0FBbkI7QUFDQWxRLGVBQU9zSyxTQUFQLEdBQW1CLEtBQW5COztBQUVBLFlBQU1xRyxPQUFPM1EsT0FBT3FRLFdBQVAsQ0FBbUIzVyxDQUFuQixDQUFiO0FBQ0EsZUFBT3NHLE9BQU9tTSxxQkFBZDtBQUNBLFlBQUl3RSxRQUFRalgsRUFBRWlXLE1BQUYsQ0FBU3RSLEtBQVQsS0FBbUIsRUFBL0IsRUFBbUM7QUFDL0I7QUFDSDs7QUFFRDtBQUNBLFlBQUkzRSxFQUFFaVcsTUFBRixDQUFTdFIsS0FBVCxLQUFtQjJCLE9BQU9FLGFBQVAsQ0FBcUJuSyxLQUE1QyxFQUFtRDtBQUMvQyxnQkFBSWlLLE9BQU9FLGFBQVAsQ0FBcUJsSyxLQUFyQixLQUErQixHQUFuQyxFQUF3QztBQUNwQ29NLG9DQUFvQjFJLEVBQUVpVyxNQUF0QixFQUE4QixDQUE5QixFQUFpQyxDQUFqQztBQUNILGFBRkQsTUFFTztBQUNIdk4sb0NBQW9CMUksRUFBRWlXLE1BQXRCLEVBQThCM1AsT0FBT0UsYUFBUCxDQUFxQm5LLEtBQXJCLENBQTJCb0wsTUFBekQsRUFBaUVuQixPQUFPRSxhQUFQLENBQXFCbkssS0FBckIsQ0FBMkJvTCxNQUE1RjtBQUNIO0FBQ0osU0FORCxNQU1PLElBQUk2TyxtQkFBbUJ6WSxRQUFRRSxHQUEvQixFQUFvQztBQUN2QzJLLGdDQUFvQjFJLEVBQUVpVyxNQUF0QixFQUE4QixDQUE5QixFQUFpQ2pXLEVBQUVpVyxNQUFGLENBQVN0UixLQUFULENBQWU4QyxNQUFoRDtBQUNIOztBQUVELFlBQUt6SCxFQUFFaVcsTUFBRixDQUFTdFIsS0FBVCxLQUFtQjJCLE9BQU9FLGFBQVAsQ0FBcUJoSyxPQUF6QyxJQUNDOEosT0FBT0UsYUFBUCxDQUFxQjZGLFFBQXJCLEtBQWtDLEVBQWxDLElBQXdDL0YsT0FBT0UsYUFBUCxDQUFxQm5LLEtBQXJCLEtBQStCLEVBQXZFLElBQTZFaUssT0FBT0UsYUFBUCxDQUFxQmhLLE9BQXJCLEtBQWlDLEVBRG5ILEVBQ3dIO0FBQ3BIa00sZ0NBQW9CMUksRUFBRWlXLE1BQXRCLEVBQThCLENBQTlCLEVBQWlDLENBQWpDO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJM1AsT0FBT0UsYUFBUCxDQUFxQjNKLElBQXJCLEtBQThCLElBQTlCLElBQXNDeUosT0FBT0UsYUFBUCxDQUFxQnZKLEtBQS9ELEVBQXNFO0FBQ2xFOFMscUJBQVMvUCxFQUFFaVcsTUFBWCxFQUFtQjFNLFFBQW5CLEVBQTZCLEtBQTdCO0FBQ0g7O0FBRUQsWUFBSSxDQUFDakQsT0FBT3NLLFNBQVosRUFBdUI7QUFDbkJ0SyxtQkFBT3VRLFlBQVAsQ0FBb0I3VyxDQUFwQjtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUEsYUFBU2tYLHVCQUFULENBQWlDNU4sS0FBakMsRUFBd0NoRCxNQUF4QyxFQUFnRHRHLENBQWhELEVBQW1EO0FBQy9DLFlBQUksQ0FBQ3NKLE1BQU0wTSxFQUFOLENBQVMsUUFBVCxDQUFMLEVBQXlCO0FBQ3JCLGdCQUFJclIsUUFBUTNFLEVBQUVpVyxNQUFGLENBQVN0UixLQUFyQjtBQUNBLGdCQUFNd1MsWUFBWXhTLEtBQWxCO0FBQ0EsZ0JBQU00RSxXQUFXakQsT0FBT0UsYUFBeEI7QUFDQStDLHFCQUFTdUIsS0FBVCxHQUFpQixLQUFqQjs7QUFFQSxnQkFBSXZCLFNBQVN0TSxLQUFiLEVBQW9CO0FBQ2hCOFMseUJBQVMvUCxFQUFFaVcsTUFBWCxFQUFtQjFNLFFBQW5CLEVBQTZCLEtBQTdCO0FBQ0g7O0FBRUQsZ0JBQUlBLFNBQVN0TixJQUFULEtBQWtCLElBQXRCLEVBQTRCO0FBQ3hCc04seUJBQVN2TixJQUFULEdBQWdCdU4sU0FBUzJGLElBQXpCO0FBQ0EzRix5QkFBU2xOLEtBQVQsR0FBaUJrTixTQUFTNEYsS0FBMUI7QUFDQTVGLHlCQUFTL00sT0FBVCxHQUFtQitNLFNBQVM2RixPQUE1QjtBQUNIOztBQUVELGdCQUFJN0YsU0FBUzFNLElBQVQsS0FBa0IsSUFBdEIsRUFBNEI7QUFDeEIwTSx5QkFBUzNNLElBQVQsR0FBZ0IyTSxTQUFTd0YsSUFBekI7QUFDQXhGLHlCQUFTcE0sSUFBVCxHQUFnQm9NLFNBQVN5RixJQUF6QjtBQUNBekYseUJBQVNuTSxRQUFULEdBQW9CbU0sU0FBUzBGLFFBQTdCO0FBQ0g7O0FBRUR0SyxvQkFBUTRCLFVBQVU1QixLQUFWLEVBQWlCNEUsUUFBakIsQ0FBUjtBQUNBLGdCQUFJNUUsVUFBVSxFQUFkLEVBQWtCO0FBQ2Qsb0JBQUk0RSxTQUFTUyxnQkFBYixFQUErQjtBQUMzQnJGLDRCQUFRLE1BQU1BLEtBQWQ7QUFDQTRFLDZCQUFTUyxnQkFBVCxHQUE0QixLQUE1QjtBQUNIOztBQUphLGtDQU1hbUUsVUFBVXhKLEtBQVYsRUFBaUI0RSxRQUFqQixDQU5iO0FBQUE7QUFBQSxvQkFNUHdJLE9BTk87QUFBQSxvQkFNRUMsT0FORjs7QUFPZCxvQkFBSXJHLFdBQVdoSCxLQUFYLEVBQWtCNEUsUUFBbEIsRUFBNEIsS0FBNUIsTUFBdUMsSUFBdkMsSUFBK0N3SSxPQUEvQyxJQUEwREMsT0FBOUQsRUFBdUU7QUFDbkVyTiw0QkFBUThHLFVBQVU5RyxLQUFWLEVBQWlCNEUsUUFBakIsQ0FBUjtBQUNBQSw2QkFBUzhDLFFBQVQsR0FBb0IxSCxLQUFwQjs7QUFFQSx3QkFBSTRFLFNBQVN6TSxZQUFiLEVBQTJCO0FBQ3ZCNkgsZ0NBQVFBLFFBQVE0RSxTQUFTek0sWUFBekI7QUFDQTZILGdDQUFRQSxNQUFNdUMsUUFBTixFQUFSO0FBQ0g7O0FBRURxQyw2QkFBUzNNLElBQVQsR0FBaUIyTSxTQUFTek0sWUFBVCxJQUF5QnlNLFNBQVN4TSxZQUFuQyxHQUFtRCxDQUFDd00sU0FBU3hNLFlBQTdELEdBQTRFd00sU0FBUzNNLElBQXJHO0FBQ0ErSCw0QkFBUWdJLFVBQVVoSSxLQUFWLEVBQWlCNEUsUUFBakIsQ0FBUjtBQUNBNUUsNEJBQVErRyxjQUFjL0csS0FBZCxFQUFxQjRFLFFBQXJCLENBQVI7QUFDSCxpQkFaRCxNQVlPO0FBQ0gsd0JBQUksQ0FBQ3dJLE9BQUwsRUFBYztBQUNWekksOEJBQU02SSxPQUFOLENBQWMseUJBQWQ7QUFDSDtBQUNELHdCQUFJLENBQUNILE9BQUwsRUFBYztBQUNWMUksOEJBQU02SSxPQUFOLENBQWMseUJBQWQ7QUFDSDs7QUFFRHhOLDRCQUFRNEUsU0FBUzhDLFFBQWpCO0FBQ0g7QUFDSixhQTdCRCxNQTZCTztBQUNILG9CQUFJOUMsU0FBU2xNLE1BQVQsS0FBb0IsTUFBeEIsRUFBZ0M7QUFDNUJrTSw2QkFBUzhDLFFBQVQsR0FBb0IsR0FBcEI7QUFDQTFILDRCQUFRZ0ksVUFBVSxHQUFWLEVBQWVwRCxRQUFmLENBQVI7QUFDSCxpQkFIRCxNQUdPO0FBQ0hBLDZCQUFTOEMsUUFBVCxHQUFvQixFQUFwQjtBQUNIO0FBQ0o7O0FBRUQsZ0JBQUkrSyxlQUFlekwsV0FBV2hILEtBQVgsRUFBa0I0RSxRQUFsQixFQUE0QixLQUE1QixDQUFuQjtBQUNBLGdCQUFJNk4saUJBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCQSwrQkFBZXRMLFVBQVVuSCxLQUFWLEVBQWlCNEUsUUFBakIsQ0FBZjtBQUNIOztBQUVELGdCQUFJNk4saUJBQWlCRCxTQUFyQixFQUFnQztBQUM1QkMsK0JBQWdCN04sU0FBU3ZNLFdBQVYsR0FBeUJvYSxlQUFlN04sU0FBU3ZNLFdBQWpELEdBQStEb2EsWUFBOUU7QUFDQTlOLHNCQUFNSSxHQUFOLENBQVUwTixZQUFWO0FBQ0g7O0FBRUQsZ0JBQUlBLGlCQUFpQjlRLE9BQU80UCxZQUE1QixFQUEwQztBQUN0QzVNLHNCQUFNK04sTUFBTjtBQUNBLHVCQUFPL1EsT0FBTzRQLFlBQWQ7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUEsYUFBU29CLE9BQVQsQ0FBaUJoTyxLQUFqQixFQUF3QmhELE1BQXhCLEVBQWdDdEcsQ0FBaEMsRUFBbUM7QUFDL0I7QUFDQTtBQUNBQSxVQUFFK1MsY0FBRjs7QUFFQSxZQUFNd0UsY0FBY2pPLE1BQU1LLFdBQU4sQ0FBa0IsS0FBbEIsQ0FBcEI7QUFDQSxZQUFNNk4sZUFBZXhYLEVBQUVpVyxNQUFGLENBQVN0UixLQUFULElBQWtCLEVBQXZDO0FBQ0EsWUFBTXFELGlCQUFpQmhJLEVBQUVpVyxNQUFGLENBQVNqTyxjQUFULElBQTJCLENBQWxEO0FBQ0EsWUFBTVMsZUFBZXpJLEVBQUVpVyxNQUFGLENBQVN4TixZQUFULElBQXlCLENBQTlDO0FBQ0EsWUFBTWdQLFNBQVNELGFBQWFwTCxTQUFiLENBQXVCLENBQXZCLEVBQTBCcEUsY0FBMUIsQ0FBZjtBQUNBLFlBQU0wUCxTQUFTRixhQUFhcEwsU0FBYixDQUF1QjNELFlBQXZCLEVBQXFDK08sYUFBYS9QLE1BQWxELENBQWY7QUFDQSxZQUFNa1EsYUFBYXRSLGtCQUFrQnJHLEVBQUU0WCxhQUFGLENBQWdCQyxPQUFoQixDQUF3QixZQUF4QixDQUFsQixFQUF5RHZSLE1BQXpELENBQW5COztBQUVBLFlBQUlILGlCQUFpQndSLFVBQWpCLENBQUosRUFBa0M7QUFDOUIsZ0JBQU1qRyxXQUFXckwsa0JBQWtCb1IsU0FBU2pNLE9BQU9tTSxVQUFQLEVBQW1CRyxPQUFuQixFQUFULEdBQXdDSixNQUExRCxFQUFrRXBSLE1BQWxFLENBQWpCOztBQUVBLGdCQUFJSCxpQkFBaUJ1TCxRQUFqQixLQUE4QmxHLE9BQU8rTCxXQUFQLEVBQW9CTyxPQUFwQixPQUFrQ3RNLE9BQU9rRyxRQUFQLEVBQWlCb0csT0FBakIsRUFBcEUsRUFBZ0c7QUFDNUZ4TyxzQkFBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QitILFFBQXpCO0FBQ0E7QUFDQStFLDZCQUFhLE9BQWIsRUFBc0J6VyxFQUFFaVcsTUFBeEI7QUFDQTtBQUNIO0FBQ0osU0FURCxNQVNPO0FBQ0hqVyxjQUFFaVcsTUFBRixDQUFTak8sY0FBVCxHQUEwQlMsWUFBMUI7QUFDSDtBQUNKOztBQUVEOzs7Ozs7QUFNQSxhQUFTc1AsTUFBVCxDQUFnQnpSLE1BQWhCLEVBQXdCdEcsQ0FBeEIsRUFBMkI7QUFDdkIsWUFBSUEsRUFBRWlXLE1BQUYsQ0FBU3RSLEtBQVQsS0FBbUIyQixPQUFPNFAsWUFBOUIsRUFBNEM7QUFDeENPLHlCQUFhLFFBQWIsRUFBdUJ6VyxFQUFFaVcsTUFBekI7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTK0IsUUFBVCxDQUFrQjFPLEtBQWxCLEVBQXlCaEQsTUFBekIsRUFBaUM7QUFDN0JnRCxjQUFNMk8sT0FBTixDQUFjLE1BQWQsRUFBc0JDLEVBQXRCLENBQXlCLG9CQUF6QixFQUErQyxZQUFNO0FBQ2pELGdCQUFJNVIsTUFBSixFQUFZO0FBQ1Isb0JBQU02UixZQUFZN1IsT0FBT0UsYUFBekI7O0FBRUEsb0JBQUkyUixVQUFVemEsYUFBZCxFQUE2QjtBQUN6QjRMLDBCQUFNSSxHQUFOLENBQVV5TyxVQUFVOUwsUUFBcEI7QUFDSDtBQUNKO0FBQ0osU0FSRDtBQVNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTK0wsNkJBQVQsQ0FBdUM5TyxLQUF2QyxFQUE4QztBQUMxQztBQUNBLFlBQU0rTyxTQUFTL08sTUFBTTBNLEVBQU4sQ0FBUywwRUFBVCxDQUFmOztBQUVBO0FBQ0EsWUFBSSxDQUFDcUMsTUFBRCxJQUFXL08sTUFBTTNELElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixPQUF3QyxPQUF2RCxFQUFnRTtBQUM1RDJELDRDQUE4Qk8sTUFBTTNELElBQU4sQ0FBVyxNQUFYLENBQTlCO0FBQ0g7O0FBRUQ7QUFDQSxZQUFNMlMsb0JBQW9CaFAsTUFBTTNELElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixFQUExQjtBQUNBLFlBQUlrVCxzQkFBc0IsT0FBdEIsSUFBaUMsQ0FBQ3pSLFVBQVV5UixpQkFBVixFQUE2QnhjLGNBQTdCLENBQXRDLEVBQW9GO0FBQ2hGaU4saUNBQW1CdVAsaUJBQW5CO0FBQ0g7O0FBRUQsZUFBT0QsTUFBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0UsNEJBQVQsQ0FBc0NoUCxRQUF0QyxFQUFnRDhPLE1BQWhELEVBQXdEL08sS0FBeEQsRUFBK0Q7QUFDM0QsWUFBSWtQLFdBQVcsSUFBZjs7QUFFQSxZQUFJSCxNQUFKLEVBQVk7QUFDUixnQkFBTWIsZUFBZWxPLE1BQU1JLEdBQU4sRUFBckI7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUEsZ0JBQUlILFNBQVNoTSxLQUFULElBQWtCaWEsaUJBQWlCLEVBQW5DLElBQXlDM1MseUJBQXlCeUUsTUFBTW1QLElBQU4sQ0FBVyxPQUFYLENBQXpCLENBQTdDLEVBQTRGO0FBQ3hGO0FBQ0Esb0JBQU1DLHFCQUFxQjNTLFdBQVd5UixhQUFhL1EsT0FBYixDQUFxQixHQUFyQixFQUEwQixHQUExQixDQUFYLENBQTNCO0FBQ0E7QUFDQSxvQkFBSSxDQUFDWCxNQUFNNFMsa0JBQU4sQ0FBRCxJQUE4QkMsYUFBYUQsa0JBQS9DLEVBQW1FO0FBQy9EcFAsMEJBQU1LLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUIrTyxrQkFBekI7QUFDQUYsK0JBQVcsS0FBWDtBQUNILGlCQUhELE1BR087QUFDSDtBQUNBelAsK0NBQXlCeU8sWUFBekI7QUFDSDtBQUNKLGFBWEQsTUFXTztBQUNIOzs7Ozs7QUFNQTtBQUNBLG9CQUFLak8sU0FBUzlMLFNBQVQsS0FBdUIsSUFBdkIsSUFBK0I4TCxTQUFTOUwsU0FBVCxDQUFtQnlKLFFBQW5CLE9BQWtDc1EsWUFBbEUsSUFDQ2pPLFNBQVM5TCxTQUFULEtBQXVCLElBQXZCLElBQStCK1osaUJBQWlCLEVBQWhELElBQXNEQSxpQkFBaUJsTyxNQUFNbVAsSUFBTixDQUFXLE9BQVgsQ0FEeEUsSUFFQ2pCLGlCQUFpQixFQUFqQixJQUF1QmxPLE1BQU1tUCxJQUFOLENBQVcsTUFBWCxNQUF1QixRQUE5QyxJQUEwRCxDQUFDalAsRUFBRW9QLFNBQUYsQ0FBWXBCLGFBQWEvUSxPQUFiLENBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLENBQVosQ0FGaEUsRUFFOEc7QUFDMUcsd0JBQUs4QyxTQUFTMU0sSUFBVCxLQUFrQixJQUFsQixJQUEwQjBNLFNBQVN0TSxLQUFwQyxJQUNDc00sU0FBU3pNLFlBQVQsSUFBeUJ5TSxTQUFTdE0sS0FEdkMsRUFDK0M7QUFDM0NzTSxpQ0FBUzhDLFFBQVQsR0FBb0IwRCxTQUFTekcsTUFBTSxDQUFOLENBQVQsRUFBbUJDLFFBQW5CLEVBQTZCLEtBQTdCLENBQXBCO0FBQ0g7O0FBRUQ7QUFDQSx3QkFBSSxDQUFDQSxTQUFTdE0sS0FBZCxFQUFxQjtBQUNqQiw0QkFBSTRiLGdCQUFKOztBQUVBLDRCQUFJdFAsU0FBU25NLFFBQVQsS0FBc0IsSUFBdEIsSUFBOEJtTSxTQUFTa0IsSUFBVCxLQUFrQixFQUFwRCxFQUF3RDtBQUNwRGxCLHFDQUFTdUIsS0FBVCxHQUFpQixJQUFqQjtBQUNBK04sc0NBQVU3TixnQkFBZ0J3TSxZQUFoQixFQUE4QmpPLFFBQTlCLENBQVY7QUFDSCx5QkFIRCxNQUdPO0FBQ0hzUCxzQ0FBVXJCLFlBQVY7QUFDSDs7QUFFRGpPLGlDQUFTOEMsUUFBVCxHQUFxQixDQUFDOUMsU0FBU2hOLElBQVQsS0FBa0IsR0FBbEIsSUFBMEJnTixTQUFTak4sS0FBVCxLQUFtQixHQUFuQixJQUEwQmlOLFNBQVNoTixJQUFULEtBQWtCLEdBQXZFLEtBQWdGZ04sU0FBU2tCLElBQVQsS0FBa0IsRUFBbEcsSUFBd0cvRCxTQUFTOFEsWUFBVCxFQUF1QixHQUF2QixDQUF6RyxHQUFzSSxNQUFNalIsVUFBVXNTLE9BQVYsRUFBbUJ0UCxRQUFuQixDQUE1SSxHQUF5S2hELFVBQVVzUyxPQUFWLEVBQW1CdFAsUUFBbkIsQ0FBN0w7QUFDSDs7QUFFRGlQLCtCQUFXLEtBQVg7QUFDSDtBQUNKOztBQUVELGdCQUFJaEIsaUJBQWlCLEVBQXJCLEVBQXlCO0FBQ3JCLHdCQUFRak8sU0FBU2xNLE1BQWpCO0FBQ0kseUJBQUssT0FBTDtBQUNJbWIsbUNBQVcsS0FBWDtBQUNBO0FBQ0oseUJBQUssUUFBTDtBQUNJbFAsOEJBQU1JLEdBQU4sQ0FBVUgsU0FBU2xOLEtBQW5CO0FBQ0FtYyxtQ0FBVyxLQUFYO0FBQ0E7QUFDSix5QkFBSyxNQUFMO0FBQ0lsUCw4QkFBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QixHQUF6QjtBQUNBNk8sbUNBQVcsS0FBWDtBQUNBO0FBQ0o7QUFDQTtBQWJKO0FBZUgsYUFoQkQsTUFnQk8sSUFBSUEsWUFBWWhCLGlCQUFpQmxPLE1BQU1tUCxJQUFOLENBQVcsT0FBWCxDQUFqQyxFQUFzRDtBQUN6RG5QLHNCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCNk4sWUFBekI7QUFDSDtBQUNKOztBQUVELFlBQUkzUSxVQUFVeUMsTUFBTTNELElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixFQUFWLEVBQStDbUUsU0FBU3VQLE9BQXhELEtBQW9FeFAsTUFBTWxELElBQU4sT0FBaUIsRUFBekYsRUFBNkY7QUFDekYsZ0JBQUltRCxTQUFTOUwsU0FBVCxLQUF1QixJQUEzQixFQUFpQztBQUM3QixvQkFBSThMLFNBQVM5TCxTQUFULEtBQXVCNkwsTUFBTWxELElBQU4sRUFBM0IsRUFBeUM7QUFDckNrRCwwQkFBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QkwsTUFBTWxELElBQU4sRUFBekI7QUFDSDtBQUNKLGFBSkQsTUFJTztBQUNIa0Qsc0JBQU1LLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUJMLE1BQU1sRCxJQUFOLEVBQXpCO0FBQ0g7QUFDSjtBQUNKOztBQUVEOzs7Ozs7Ozs7OztBQVdBLGFBQVMyUyxpQkFBVCxDQUEyQkMsT0FBM0IsRUFBb0N6UCxRQUFwQyxFQUE4QztBQUMxQyxZQUFJLENBQUMzRSxZQUFZb1UsT0FBWixDQUFELElBQXlCblUseUJBQXlCbVUsUUFBUXpjLElBQWpDLENBQXpCLElBQW1FeWMsUUFBUTNjLEtBQVIsS0FBa0IsRUFBekYsRUFBNkY7QUFDekYsb0JBQVFrTixTQUFTak4sS0FBakI7QUFDSSxxQkFBSyxHQUFMO0FBQ0lpTiw2QkFBU2hOLElBQVQsR0FBZ0IsR0FBaEI7QUFDQTtBQUNKLHFCQUFLLEdBQUw7QUFDSWdOLDZCQUFTaE4sSUFBVCxHQUFnQixHQUFoQjtBQUNBO0FBQ0o7QUFDQTtBQVJKO0FBVUg7QUFDSjs7QUFFRDs7Ozs7O0FBTUEsYUFBUzBjLGdDQUFULENBQTBDMVAsUUFBMUMsRUFBb0Q7QUFBQSxvQ0FDeEJBLFNBQVM3TSxJQUFULENBQWN3SyxRQUFkLEdBQXlCSSxLQUF6QixDQUErQixHQUEvQixDQUR3QjtBQUFBO0FBQUEsWUFDM0M0UixlQUQyQzs7QUFBQSxvQkFFdkIsQ0FBQzNQLFNBQVM1TSxJQUFWLElBQWtCNE0sU0FBUzVNLElBQVQsS0FBa0IsQ0FBckMsR0FBd0MsRUFBeEMsR0FBMkM0TSxTQUFTNU0sSUFBVCxDQUFjdUssUUFBZCxHQUF5QkksS0FBekIsQ0FBK0IsR0FBL0IsQ0FGbkI7QUFBQTtBQUFBLFlBRTNDNlIsZUFGMkM7O0FBR2hERCwwQkFBa0JBLGdCQUFnQnpTLE9BQWhCLENBQXdCLEdBQXhCLEVBQTZCLEVBQTdCLENBQWxCO0FBQ0EwUywwQkFBa0JBLGdCQUFnQjFTLE9BQWhCLENBQXdCLEdBQXhCLEVBQTZCLEVBQTdCLENBQWxCOztBQUVBOEMsaUJBQVNtQixPQUFULEdBQW1CYixLQUFLQyxHQUFMLENBQVNvUCxnQkFBZ0J6UixNQUF6QixFQUFpQyxDQUFqQyxDQUFuQjtBQUNBOEIsaUJBQVNzQixPQUFULEdBQW1CaEIsS0FBS0MsR0FBTCxDQUFTcVAsZ0JBQWdCMVIsTUFBekIsRUFBaUMsQ0FBakMsQ0FBbkI7QUFDSDs7QUFFRDs7Ozs7QUFLQSxhQUFTMlIsaUJBQVQsQ0FBMkI3UCxRQUEzQixFQUFxQztBQUNqQyxZQUFJLENBQUM3RSxPQUFPNkUsU0FBU3pNLFlBQWhCLENBQUQsSUFBa0MsQ0FBQzRILE9BQU82RSxTQUFTeE0sWUFBaEIsQ0FBdkMsRUFBc0U7QUFDbEU7QUFDQXdNLHFCQUFTM00sSUFBVCxHQUFnQjJNLFNBQVN4TSxZQUF6QjtBQUNILFNBSEQsTUFJSyxJQUFJMkgsT0FBTzZFLFNBQVMzTSxJQUFoQixDQUFKLEVBQTJCO0FBQzVCMk0scUJBQVMzTSxJQUFULEdBQWdCZ04sZ0NBQWdDTCxTQUFTNU0sSUFBekMsRUFBK0M0TSxTQUFTN00sSUFBeEQsQ0FBaEI7QUFDQTZNLHFCQUFTd0YsSUFBVCxHQUFnQi9KLE9BQU91RSxTQUFTM00sSUFBaEIsQ0FBaEI7QUFDSDs7QUFFRDtBQUNBMk0saUJBQVMzTSxJQUFULEdBQWdCNE8sT0FBT2pDLFNBQVMzTSxJQUFoQixDQUFoQjtBQUNIOztBQUVEOzs7OztBQUtBLGFBQVN5Yyx3Q0FBVCxDQUFrRDlQLFFBQWxELEVBQTREO0FBQ3hELFlBQUk3RSxPQUFPNkUsU0FBU25OLE1BQWhCLEtBQTJCb1AsT0FBT2pDLFNBQVMzTSxJQUFoQixJQUF3QixDQUF2RCxFQUEwRDtBQUN0RCxnQkFBSTJNLFNBQVNwTixJQUFULEtBQWtCLEdBQWxCLElBQXlCb04sU0FBU3ZOLElBQVQsS0FBa0IsR0FBL0MsRUFBb0Q7QUFDaER1Tix5QkFBU25OLE1BQVQsR0FBa0IsR0FBbEI7QUFDSCxhQUZELE1BRU8sSUFBSW1OLFNBQVNwTixJQUFULEtBQWtCLEdBQWxCLElBQXlCb04sU0FBU3ZOLElBQVQsS0FBa0IsR0FBL0MsRUFBb0Q7QUFDdkR1Tix5QkFBU25OLE1BQVQsR0FBa0IsR0FBbEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7O0FBS0EsYUFBU2tkLDZCQUFULENBQXVDL1AsUUFBdkMsRUFBaUQ7QUFDN0MsWUFBTWdRLFVBQVVoUSxTQUFTa0IsSUFBVCxhQUFzQmxCLFNBQVNrQixJQUEvQixXQUF5QyxNQUF6RDtBQUNBbEIsaUJBQVNvSSxnQkFBVCxHQUE0QjRILE9BQTVCO0FBQ0FoUSxpQkFBU1Esa0JBQVQsR0FBOEIsSUFBSTJDLE1BQUosQ0FBYzZNLE9BQWQsWUFBNEJoUSxTQUFTa0IsSUFBVCxVQUFtQmxCLFNBQVNrQixJQUE1QixHQUFtQyxFQUEvRCxXQUF1RWxCLFNBQVNwTixJQUFoRixzQkFBcUdvTixTQUFTcE4sSUFBOUcsVUFBOUI7QUFDQW9OLGlCQUFTVSxpQkFBVCxHQUE2QixJQUFJeUMsTUFBSixZQUFvQm5ELFNBQVNwTixJQUE3QixjQUEwQ29OLFNBQVNwTixJQUFuRCxlQUE3Qjs7QUFFQSxZQUFNcWQsNEJBQTBCalEsU0FBU3BOLElBQXpDO0FBQ0FvTixpQkFBU1csZ0JBQVQsR0FBNEIsSUFBSXdDLE1BQUosUUFBZ0I4TSxPQUFoQixRQUE0QixJQUE1QixDQUE1QjtBQUNBalEsaUJBQVNhLGVBQVQsR0FBMkIsSUFBSXNDLE1BQUosQ0FBYzZNLE9BQWQsYUFBNkJoUSxTQUFTcE4sSUFBdEMsZ0JBQXFEb04sU0FBU3BOLElBQTlELHdCQUFxRm9OLFNBQVNwTixJQUE5RixjQUEzQjs7QUFFQTtBQUNBb04saUJBQVN3QixRQUFULEdBQW9CLElBQUkyQixNQUFKLE9BQWVuRCxTQUFTb0ksZ0JBQXhCLGFBQXBCO0FBQ0g7O0FBRUQ7Ozs7O0FBS0EsYUFBUzhILG9DQUFULENBQThDbFEsUUFBOUMsRUFBd0Q7QUFDcERDLFVBQUVDLElBQUYsQ0FBT0YsUUFBUCxFQUFpQixVQUFDN0IsR0FBRCxFQUFNL0MsS0FBTixFQUFnQjtBQUM3QjtBQUNBLGdCQUFJQSxVQUFVLE1BQVYsSUFBb0JBLFVBQVUsT0FBbEMsRUFBMkM7QUFDdkM0RSx5QkFBUzdCLEdBQVQsSUFBZ0IvQyxVQUFVLE1BQTFCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLGdCQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIrQyxRQUFRLFFBQXpDLEVBQW1EO0FBQy9DNkIseUJBQVM3QixHQUFULElBQWdCL0MsTUFBTXVDLFFBQU4sRUFBaEI7QUFDSDtBQUNKLFNBWEQ7QUFZSDs7QUFFRDs7Ozs7Ozs7O0FBU0EsYUFBU3dTLGtCQUFULENBQTRCVixPQUE1QixFQUFxQzFQLEtBQXJDLEVBQTREO0FBQUEsWUFBaEJvRixNQUFnQix1RUFBUCxLQUFPOztBQUN4RDtBQUNBLFlBQUluRixXQUFXRCxNQUFNcUYsSUFBTixDQUFXLGFBQVgsQ0FBZjs7QUFFQTtBQUNBLFlBQUlELFVBQVU5SixZQUFZMkUsUUFBWixDQUFkLEVBQXFDO0FBQ2pDLGdCQUFJbUYsTUFBSixFQUFZO0FBQ1I7QUFDQW5GLDJCQUFXQyxFQUFFbVEsTUFBRixDQUFTcFEsUUFBVCxFQUFtQnlQLE9BQW5CLENBQVg7QUFDSCxhQUhELE1BR087QUFDSDtBQUNBO0FBQ0Esb0JBQU1ZLFVBQVV0USxNQUFNcUYsSUFBTixFQUFoQjtBQUNBcEYsMkJBQVdDLEVBQUVtUSxNQUFGLENBQVMsRUFBVCxFQUFhNWQsZUFBYixFQUE4QjZkLE9BQTlCLEVBQXVDWixPQUF2QyxFQUFnRDtBQUN2RGxPLDJCQUFrQixLQURxQztBQUV2RCtPLDZCQUFrQixLQUZxQztBQUd2RHhOLDhCQUFrQixFQUhxQztBQUl2RHJDLHNDQUFrQixLQUpxQztBQUt2RG9KLDhCQUFrQixLQUxxQztBQU12REUsZ0NBQWtCLElBTnFDLEVBTS9CO0FBQ3hCdkgsMkJBQWtCLElBUHFDO0FBUXZEK00sNkJBQWtCaGQ7QUFScUMsaUJBQWhELENBQVg7QUFVSDs7QUFFRDtBQUNBMmQsaURBQXFDbFEsUUFBckM7O0FBRUE7QUFDQXdQLDhCQUFrQkMsT0FBbEIsRUFBMkJ6UCxRQUEzQjs7QUFFQTtBQUNBQSxxQkFBU2tCLElBQVQsR0FBZ0JsQixTQUFTNU0sSUFBVCxHQUFnQixDQUFoQixHQUFvQixHQUFwQixHQUEwQixFQUExQzs7QUFFQTtBQUNBME0saURBQXFDQyxLQUFyQyxFQUE0Q0MsUUFBNUM7QUFDQTBQLDZDQUFpQzFQLFFBQWpDO0FBQ0E2UCw4QkFBa0I3UCxRQUFsQjtBQUNBOFAscURBQXlDOVAsUUFBekM7QUFDQStQLDBDQUE4Qi9QLFFBQTlCOztBQUVBO0FBQ0EzTixxQkFBUzJOLFFBQVQsRUFBbUIsS0FBbkIsRUFyQ2lDLENBcUNOOztBQUUzQjtBQUNBdUYsdUNBQTJCdkYsUUFBM0I7O0FBRUE7QUFDQUQsa0JBQU1xRixJQUFOLENBQVcsYUFBWCxFQUEwQnBGLFFBQTFCOztBQUVBLG1CQUFPQSxRQUFQO0FBQ0gsU0E5Q0QsTUE4Q087QUFDSCxtQkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRDs7O0FBR0EsUUFBTXVRLFVBQVU7QUFDWjs7Ozs7Ozs7OztBQVVBQyxZQVhZLGdCQVdQZixPQVhPLEVBV0U7QUFDVixtQkFBTyxLQUFLdlAsSUFBTCxDQUFVLFlBQVc7QUFDeEIsb0JBQU1ILFFBQVFFLEVBQUUsSUFBRixDQUFkO0FBQ0Esb0JBQU02TyxTQUFTRCw4QkFBOEI5TyxLQUE5QixDQUFmOztBQUVBLG9CQUFNQyxXQUFXbVEsbUJBQW1CVixPQUFuQixFQUE0QjFQLEtBQTVCLEVBQW1DLEtBQW5DLENBQWpCO0FBQ0Esb0JBQUk1RSxPQUFPNkUsUUFBUCxDQUFKLEVBQXNCO0FBQ2xCLDJCQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLG9CQUFNakQsU0FBU2tJLFVBQVVsRixLQUFWLEVBQWlCQyxRQUFqQixFQUEyQixLQUEzQixDQUFmOztBQUVBLG9CQUFJLENBQUNBLFNBQVNzUSxPQUFWLElBQXFCdFEsU0FBU2hNLEtBQWxDLEVBQXlDO0FBQ3JDZ2IsaURBQTZCaFAsUUFBN0IsRUFBdUM4TyxNQUF2QyxFQUErQy9PLEtBQS9DO0FBQ0g7O0FBRURDLHlCQUFTc1EsT0FBVCxHQUFtQixJQUFuQjs7QUFFQTtBQUNBLG9CQUFJeEIsTUFBSixFQUFZO0FBQ1IseUJBQUsyQixnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxhQUFLO0FBQUVqRSwrQ0FBdUJ6TSxLQUF2QixFQUE4QmhELE1BQTlCLEVBQXNDdEcsQ0FBdEM7QUFBMkMscUJBQW5GLEVBQXFGLEtBQXJGO0FBQ0EseUJBQUtnYSxnQkFBTCxDQUFzQixZQUF0QixFQUFvQyxhQUFLO0FBQUVqRSwrQ0FBdUJ6TSxLQUF2QixFQUE4QmhELE1BQTlCLEVBQXNDdEcsQ0FBdEM7QUFBMkMscUJBQXRGLEVBQXdGLEtBQXhGO0FBQ0EseUJBQUtnYSxnQkFBTCxDQUFzQixVQUF0QixFQUFrQyxhQUFLO0FBQUU5QyxnREFBd0I1TixLQUF4QixFQUErQmhELE1BQS9CLEVBQXVDdEcsQ0FBdkM7QUFBNEMscUJBQXJGLEVBQXVGLEtBQXZGO0FBQ0EseUJBQUtnYSxnQkFBTCxDQUFzQixZQUF0QixFQUFvQyxhQUFLO0FBQUU5QyxnREFBd0I1TixLQUF4QixFQUErQmhELE1BQS9CLEVBQXVDdEcsQ0FBdkM7QUFBNEMscUJBQXZGLEVBQXlGLEtBQXpGO0FBQ0EseUJBQUtnYSxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxhQUFLO0FBQUUzRCxrQ0FBVS9QLE1BQVYsRUFBa0J0RyxDQUFsQjtBQUF1QixxQkFBL0QsRUFBaUUsS0FBakU7QUFDQSx5QkFBS2dhLGdCQUFMLENBQXNCLFVBQXRCLEVBQWtDLGFBQUs7QUFBRWxELG1DQUFXeFEsTUFBWCxFQUFtQnRHLENBQW5CO0FBQXdCLHFCQUFqRSxFQUFtRSxLQUFuRTtBQUNBLHlCQUFLZ2EsZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsYUFBSztBQUFFaEQsZ0NBQVExUSxNQUFSLEVBQWdCaUQsUUFBaEIsRUFBMEJ2SixDQUExQjtBQUErQixxQkFBckUsRUFBdUUsS0FBdkU7QUFDQSx5QkFBS2dhLGdCQUFMLENBQXNCLE1BQXRCLEVBQThCLGFBQUs7QUFBRWpDLCtCQUFPelIsTUFBUCxFQUFldEcsQ0FBZjtBQUFvQixxQkFBekQsRUFBMkQsS0FBM0Q7QUFDQSx5QkFBS2dhLGdCQUFMLENBQXNCLE9BQXRCLEVBQStCLGFBQUs7QUFBRTFDLGdDQUFRaE8sS0FBUixFQUFlaEQsTUFBZixFQUF1QnRHLENBQXZCO0FBQTRCLHFCQUFsRSxFQUFvRSxLQUFwRTtBQUNBZ1ksNkJBQVMxTyxLQUFULEVBQWdCaEQsTUFBaEIsRUFWUSxDQVVpQjtBQUM1QjtBQUNKLGFBL0JNLENBQVA7QUFnQ0gsU0E1Q1c7OztBQThDWjs7Ozs7QUFLQTJULGVBbkRZLHFCQW1ERjtBQUNOLG1CQUFPelEsRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFNSCxRQUFRaUYsUUFBUSxJQUFSLENBQWQ7QUFDQSxvQkFBTWhGLFdBQVdELE1BQU1xRixJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLG9CQUFJLFFBQU9wRixRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXhCLEVBQWtDO0FBQzlCRCwwQkFBTUksR0FBTixDQUFVLEVBQVY7QUFDQXFHLDZCQUFTekcsTUFBTSxDQUFOLENBQVQsRUFBbUJDLFFBQW5CLEVBQTZCLE1BQTdCO0FBQ0FELDBCQUFNNFEsVUFBTixDQUFpQixhQUFqQjtBQUNBNVEsMEJBQU02USxHQUFOLENBQVUsY0FBVjtBQUNIO0FBQ0osYUFUTSxDQUFQO0FBVUgsU0E5RFc7OztBQWdFWjs7Ozs7QUFLQUMsWUFyRVksa0JBcUVMO0FBQ0gsbUJBQU81USxFQUFFLElBQUYsRUFBUUMsSUFBUixDQUFhLFlBQVc7QUFDM0Isb0JBQU1ILFFBQVFpRixRQUFRLElBQVIsQ0FBZDtBQUNBLG9CQUFNaEYsV0FBV0QsTUFBTXFGLElBQU4sQ0FBVyxhQUFYLENBQWpCO0FBQ0Esb0JBQUksUUFBT3BGLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJELDBCQUFNSSxHQUFOLENBQVUsRUFBVjtBQUNBSCw2QkFBUzhDLFFBQVQsR0FBb0IsRUFBcEI7QUFDQTBELDZCQUFTekcsTUFBTSxDQUFOLENBQVQsRUFBbUJDLFFBQW5CLEVBQTZCLE1BQTdCO0FBQ0g7QUFDSixhQVJNLENBQVA7QUFTSCxTQS9FVzs7O0FBaUZaOzs7Ozs7O0FBT0FtRixjQXhGWSxrQkF3RkxzSyxPQXhGSyxFQXdGSTtBQUNaLG1CQUFPeFAsRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFNSCxRQUFRaUYsUUFBUSxJQUFSLENBQWQ7QUFDQSxvQkFBTXhDLFFBQVF6QyxNQUFNSyxXQUFOLENBQWtCLEtBQWxCLENBQWQ7QUFDQSxvQkFBTUosV0FBV21RLG1CQUFtQlYsT0FBbkIsRUFBNEIxUCxLQUE1QixFQUFtQyxJQUFuQyxDQUFqQjs7QUFFQTtBQUNBa0YsMEJBQVVsRixLQUFWLEVBQWlCQyxRQUFqQixFQUEyQixJQUEzQjs7QUFFQSxvQkFBSUQsTUFBTUksR0FBTixPQUFnQixFQUFoQixJQUFzQkosTUFBTWxELElBQU4sT0FBaUIsRUFBM0MsRUFBK0M7QUFDM0MsMkJBQU9rRCxNQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCb0MsS0FBekIsQ0FBUDtBQUNIO0FBQ0osYUFYTSxDQUFQO0FBWUgsU0FyR1c7OztBQXVHWjs7Ozs7Ozs7O0FBU0FzTyxXQWhIWSxlQWdIUjNJLFFBaEhRLEVBZ0hFO0FBQ1YsbUJBQU9sSSxFQUFFLElBQUYsRUFBUUMsSUFBUixDQUFhLFlBQVc7QUFDM0Isb0JBQUlpSSxhQUFhLElBQWIsSUFBcUI5TSxZQUFZOE0sUUFBWixDQUF6QixFQUFnRDtBQUM1QztBQUNIOztBQUVEO0FBQ0Esb0JBQU1wSSxRQUFRaUYsUUFBUSxJQUFSLENBQWQ7QUFDQSxvQkFBTWhGLFdBQVdELE1BQU1xRixJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLG9CQUFNMEosU0FBUy9PLE1BQU0wTSxFQUFOLENBQVMsMEVBQVQsQ0FBZjtBQUNBLG9CQUFJclIsUUFBUStNLFNBQVN4SyxRQUFULEVBQVo7QUFDQSxvQkFBSSxRQUFPcUMsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUM5QlI7QUFDSDs7QUFFRDtBQUNBcEUsd0JBQVF3RyxXQUFXeEcsS0FBWCxDQUFSOztBQUVBO0FBQ0Esb0JBQUksQ0FBQzZFLEVBQUVvUCxTQUFGLENBQVlwTixPQUFPN0csS0FBUCxDQUFaLENBQUwsRUFBaUM7QUFDN0JzRSw0Q0FBc0J0RSxLQUF0QjtBQUNBLDJCQUFPMkUsTUFBTUksR0FBTixDQUFVLEVBQVYsQ0FBUDtBQUNIOztBQUVELG9CQUFJL0UsVUFBVSxFQUFkLEVBQWtCO0FBQUEsc0NBQ2F3SixVQUFVeEosS0FBVixFQUFpQjRFLFFBQWpCLENBRGI7QUFBQTtBQUFBLHdCQUNQd0ksT0FETztBQUFBLHdCQUNFQyxPQURGOztBQUVkLHdCQUFJRCxXQUFXQyxPQUFmLEVBQXdCO0FBQ3BCLDRCQUFJcUcsV0FBVzlPLFNBQVMxTSxJQUFULElBQWlCME0sU0FBU3pNLFlBQXJDLENBQUosRUFBd0Q7QUFDcER5TSxxQ0FBUzhDLFFBQVQsR0FBb0IxSCxLQUFwQjtBQUNIOztBQUVEO0FBQ0EsNEJBQUkwVCxVQUFVeFIsVUFBVXlDLE1BQU0zRCxJQUFOLENBQVcsU0FBWCxFQUFzQlAsV0FBdEIsRUFBVixFQUErQ21FLFNBQVN1UCxPQUF4RCxDQUFkLEVBQWdGO0FBQzVFLGdDQUFJdlAsU0FBU3pNLFlBQVQsSUFBeUIsQ0FBQ3lNLFNBQVN1QixLQUF2QyxFQUE4QztBQUMxQ25HLHdDQUFRQSxRQUFRNEUsU0FBU3pNLFlBQXpCO0FBQ0E2SCx3Q0FBUUEsTUFBTXVDLFFBQU4sRUFBUjtBQUNBcUMseUNBQVMzTSxJQUFULEdBQWlCMk0sU0FBU3hNLFlBQVYsR0FBMEJ3TSxTQUFTeE0sWUFBbkMsR0FBa0R3TSxTQUFTM00sSUFBM0U7QUFDSDs7QUFFRCtILG9DQUFRZ0ksVUFBVWhJLEtBQVYsRUFBaUI0RSxRQUFqQixDQUFSO0FBQ0EsZ0NBQUlBLFNBQVMxTSxJQUFULEtBQWtCLElBQWxCLElBQTBCME0sU0FBU3pNLFlBQVQsS0FBMEIsSUFBeEQsRUFBOEQ7QUFDMUR5TSx5Q0FBUzhDLFFBQVQsR0FBb0IxSCxLQUFwQjtBQUNIOztBQUVEQSxvQ0FBUStHLGNBQWMvRyxLQUFkLEVBQXFCNEUsUUFBckIsQ0FBUjtBQUNBNUUsb0NBQVFtSCxVQUFVbkgsS0FBVixFQUFpQjRFLFFBQWpCLENBQVI7QUFDSDs7QUFFRCw0QkFBSUEsU0FBU3RNLEtBQVQsS0FBbUJzTSxTQUFTMU0sSUFBVCxJQUFpQjBNLFNBQVN6TSxZQUE3QyxDQUFKLEVBQWdFO0FBQzVEaVQscUNBQVN6RyxNQUFNLENBQU4sQ0FBVCxFQUFtQkMsUUFBbkIsRUFBNkIsS0FBN0I7QUFDSDtBQUNKLHFCQXpCRCxNQXlCTztBQUNIQSxpQ0FBUzhDLFFBQVQsR0FBb0IsRUFBcEI7QUFDQTBELGlDQUFTekcsTUFBTSxDQUFOLENBQVQsRUFBbUJDLFFBQW5CLEVBQTZCLE1BQTdCO0FBQ0EsNEJBQU0rUSxpQkFBaUIzVixLQUF2QjtBQUNBQSxnQ0FBUSxFQUFSO0FBQ0EsNEJBQUksQ0FBQ29OLE9BQUwsRUFBYztBQUNWekksa0NBQU02SSxPQUFOLENBQWMseUJBQWQ7QUFDSDs7QUFFRCw0QkFBSSxDQUFDSCxPQUFMLEVBQWM7QUFDVjFJLGtDQUFNNkksT0FBTixDQUFjLHlCQUFkO0FBQ0g7O0FBRURwSixtREFBeUJ1UixjQUF6QiwrQ0FBaUYvUSxTQUFTNU0sSUFBMUYsb0JBQTZHNE0sU0FBUzdNLElBQXRIOztBQUVBLCtCQUFPNE0sTUFBTUksR0FBTixDQUFVLEVBQVYsQ0FBUDtBQUNIO0FBQ0osaUJBNUNELE1BNENPO0FBQ0gsMkJBQU9KLE1BQU1JLEdBQU4sQ0FBVSxFQUFWLENBQVA7QUFDSDs7QUFFRCxvQkFBSSxDQUFDSCxTQUFTdUIsS0FBVixJQUFtQnZCLFNBQVN2TSxXQUFoQyxFQUE2QztBQUN6QzJILDRCQUFRQSxRQUFRNEUsU0FBU3ZNLFdBQXpCO0FBQ0g7O0FBRUQsb0JBQUlxYixNQUFKLEVBQVk7QUFDUiwyQkFBTy9PLE1BQU1JLEdBQU4sQ0FBVS9FLEtBQVYsQ0FBUDtBQUNIOztBQUVELG9CQUFJa0MsVUFBVXlDLE1BQU0zRCxJQUFOLENBQVcsU0FBWCxFQUFzQlAsV0FBdEIsRUFBVixFQUErQ21FLFNBQVN1UCxPQUF4RCxDQUFKLEVBQXNFO0FBQ2xFLDJCQUFPeFAsTUFBTWxELElBQU4sQ0FBV3pCLEtBQVgsQ0FBUDtBQUNIOztBQUVELHVCQUFPLEtBQVA7QUFDSCxhQXBGTSxDQUFQO0FBcUZILFNBdE1XOzs7QUF3TVo7Ozs7OztBQU1BNFYsYUE5TVksbUJBOE1KO0FBQ0osbUJBQU8vUSxFQUFFLElBQUYsRUFBUUMsSUFBUixDQUFhLFlBQVc7QUFDM0Isb0JBQU1ILFFBQVFpRixRQUFRLElBQVIsQ0FBZDtBQUNBLG9CQUFNaEYsV0FBV0QsTUFBTXFGLElBQU4sQ0FBVyxhQUFYLENBQWpCO0FBQ0Esb0JBQUksUUFBT3BGLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJBLDZCQUFTdUIsS0FBVCxHQUFpQixJQUFqQjtBQUNBeEIsMEJBQU1JLEdBQU4sQ0FBVUosTUFBTUssV0FBTixDQUFrQixjQUFsQixDQUFWO0FBQ0g7QUFDSixhQVBNLENBQVA7QUFRSCxTQXZOVzs7O0FBeU5aOzs7OztBQUtBNlEsYUE5TlksbUJBOE5KO0FBQ0osbUJBQU9oUixFQUFFLElBQUYsRUFBUUMsSUFBUixDQUFhLFlBQVc7QUFDM0Isb0JBQU1ILFFBQVFpRixRQUFRLElBQVIsQ0FBZDtBQUNBLG9CQUFNaEYsV0FBV0QsTUFBTXFGLElBQU4sQ0FBVyxhQUFYLENBQWpCO0FBQ0Esb0JBQUksUUFBT3BGLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJELDBCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCTCxNQUFNSSxHQUFOLEVBQXpCO0FBQ0g7QUFDSixhQU5NLENBQVA7QUFPSCxTQXRPVzs7O0FBd09aOzs7Ozs7O0FBT0FtRixXQS9PWSxpQkErT047QUFDRjtBQUNBLGdCQUFNdkYsUUFBUWlGLFFBQVEsSUFBUixDQUFkO0FBQ0E7QUFDQSxnQkFBTThKLFNBQVMvTyxNQUFNME0sRUFBTixDQUFTLDBFQUFULENBQWY7QUFDQSxnQkFBTXpNLFdBQVdELE1BQU1xRixJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLGdCQUFJLFFBQU9wRixRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXhCLEVBQWtDO0FBQzlCUjtBQUNIOztBQUVEO0FBQ0EsZ0JBQUlwRSxRQUFRLEVBQVo7QUFDQSxnQkFBSTBULE1BQUosRUFBWTtBQUNSMVQsd0JBQVEyRSxNQUFNbVIsRUFBTixDQUFTLENBQVQsRUFBWS9RLEdBQVosRUFBUjtBQUNILGFBRkQsTUFFTyxJQUFJN0MsVUFBVXlDLE1BQU0zRCxJQUFOLENBQVcsU0FBWCxFQUFzQlAsV0FBdEIsRUFBVixFQUErQ21FLFNBQVN1UCxPQUF4RCxDQUFKLEVBQXNFO0FBQ3pFblUsd0JBQVEyRSxNQUFNbVIsRUFBTixDQUFTLENBQVQsRUFBWXJVLElBQVosRUFBUjtBQUNILGFBRk0sTUFFQTtBQUNIMkMsc0NBQW9CTyxNQUFNM0QsSUFBTixDQUFXLFNBQVgsRUFBc0JQLFdBQXRCLEVBQXBCO0FBQ0g7O0FBRUQsZ0JBQUltRSxTQUFTMU0sSUFBVCxJQUFpQjBNLFNBQVN6TSxZQUE5QixFQUE0QztBQUN4QzZILHdCQUFRNEUsU0FBUzhDLFFBQWpCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsb0JBQUksRUFBRyxJQUFELENBQU9GLElBQVAsQ0FBWXhILEtBQVosS0FBc0I2RyxPQUFPN0csS0FBUCxNQUFrQixDQUExQyxLQUFnRDRFLFNBQVNsTSxNQUFULEtBQW9CLE9BQXhFLEVBQWlGO0FBQzdFLDJCQUFPLEVBQVA7QUFDSDs7QUFFRCxvQkFBSXNILFVBQVUsRUFBVixJQUFnQjRFLFNBQVNuTSxRQUFULEtBQXNCLElBQTFDLEVBQWdEO0FBQzVDbU0sNkJBQVN1QixLQUFULEdBQWlCLElBQWpCO0FBQ0FuRyw0QkFBUXFHLGdCQUFnQnJHLEtBQWhCLEVBQXVCNEUsUUFBdkIsQ0FBUjtBQUNIOztBQUVELG9CQUFJQSxTQUFTc1EsT0FBVCxJQUFvQnRRLFNBQVNoTSxLQUFULEtBQW1CLEtBQTNDLEVBQWtEO0FBQzlDb0gsNEJBQVE0QixVQUFVNUIsS0FBVixFQUFpQjRFLFFBQWpCLENBQVI7QUFDSDs7QUFFRDVFLHdCQUFROEcsVUFBVTlHLEtBQVYsRUFBaUI0RSxRQUFqQixDQUFSO0FBQ0g7O0FBRUQ7QUFDQSxtQkFBTzVFLEtBQVA7QUFDSCxTQXhSVzs7O0FBMFJaOzs7Ozs7Ozs7O0FBVUErVixvQkFwU1ksMEJBb1NHO0FBQ1gsZ0JBQU1wUixRQUFRaUYsUUFBUSxJQUFSLENBQWQ7QUFDQSxnQkFBSTVKLFFBQVEyRSxNQUFNSyxXQUFOLENBQWtCLEtBQWxCLENBQVo7QUFDQSxnQkFBTUosV0FBV0QsTUFBTXFGLElBQU4sQ0FBVyxhQUFYLENBQWpCOztBQUVBLGdCQUFJbkQsT0FBTzdHLEtBQVAsTUFBa0IsQ0FBbEIsSUFBdUI0RSxTQUFTak0sS0FBVCxLQUFtQixNQUE5QyxFQUFzRDtBQUNsRHFILHdCQUFRLEdBQVI7QUFDSDs7QUFFRCxtQkFBTzBHLFNBQVMxRyxLQUFULEVBQWdCNEUsU0FBUzVMLFVBQXpCLENBQVA7QUFDSCxTQTlTVzs7O0FBZ1RaOzs7Ozs7QUFNQWdkLG9CQXRUWSwwQkFzVEc7QUFDWDtBQUNBLGdCQUFJLENBQUMsS0FBSy9VLGNBQUwsQ0FBb0IsR0FBcEIsQ0FBRCxJQUE2QixFQUFFLFdBQVcsS0FBSyxDQUFMLENBQWIsQ0FBakMsRUFBd0Q7QUFDcERtRCwyQkFBVyxzREFBWDtBQUNIOztBQUVELG1CQUFPLEtBQUssQ0FBTCxFQUFRcEUsS0FBZjtBQUNILFNBN1RXOzs7QUErVFo7Ozs7Ozs7QUFPQWlXLGlCQXRVWSx1QkFzVUE7QUFDUixtQkFBT3RHLGtCQUFrQixLQUFsQixFQUF5QixJQUF6QixDQUFQO0FBQ0gsU0F4VVc7OztBQTBVWjs7Ozs7OztBQU9BdUcsZ0JBalZZLHNCQWlWRDtBQUNQLG1CQUFPdkcsa0JBQWtCLElBQWxCLEVBQXdCLElBQXhCLENBQVA7QUFDSCxTQW5WVzs7O0FBcVZaOzs7OztBQUtBd0csbUJBMVZZLHlCQTBWRTtBQUNWLG1CQUFPLEtBQUtuTSxJQUFMLENBQVUsYUFBVixDQUFQO0FBQ0g7QUE1VlcsS0FBaEI7O0FBK1ZBOzs7O0FBSUFuRixNQUFFdVIsRUFBRixDQUFLcFIsV0FBTCxHQUFtQixVQUFTcVIsTUFBVCxFQUEwQjtBQUN6QyxZQUFJbEIsUUFBUWtCLE1BQVIsQ0FBSixFQUFxQjtBQUFBLDhDQURjQyxJQUNkO0FBRGNBLG9CQUNkO0FBQUE7O0FBQ2pCLG1CQUFPbkIsUUFBUWtCLE1BQVIsRUFBZ0JFLEtBQWhCLENBQXNCLElBQXRCLEVBQTRCRCxJQUE1QixDQUFQO0FBQ0g7O0FBRUQsWUFBSSxRQUFPRCxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCLENBQUNBLE1BQW5DLEVBQTJDO0FBQ3ZDO0FBQ0EsbUJBQU9sQixRQUFRQyxJQUFSLENBQWFtQixLQUFiLENBQW1CLElBQW5CLEVBQXlCLENBQUNGLE1BQUQsQ0FBekIsQ0FBUDtBQUNIOztBQUVEalMsZ0NBQXNCaVMsTUFBdEI7QUFDSCxLQVhEOztBQWFBOzs7OztBQUtBcmYsdUJBQW1CO0FBQUEsZUFBTUksZUFBTjtBQUFBLEtBQW5COztBQUVBeU4sTUFBRXVSLEVBQUYsQ0FBS3BSLFdBQUwsQ0FBaUJ3UixRQUFqQixHQUE0QnBmLGVBQTVCLENBcjVGRyxDQXE1RjBDOztBQUU3Qzs7O0FBR0FOLGlCQUFhLG9CQUFDa0osS0FBRCxFQUFRcVUsT0FBUixFQUFvQjtBQUM3QixZQUFJcFUsWUFBWUQsS0FBWixLQUFzQkEsVUFBVSxJQUFwQyxFQUEwQztBQUN0QyxtQkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLENBQUNrQixTQUFTbEIsS0FBVCxDQUFMLEVBQXNCO0FBQ2xCb0UseUVBQTJEcEUsS0FBM0Q7QUFDSDs7QUFFRDtBQUNBLFlBQU00RSxXQUFXQyxFQUFFbVEsTUFBRixDQUFTLEVBQVQsRUFBYTVkLGVBQWIsRUFBOEIsRUFBRWdRLE9BQU8sS0FBVCxFQUE5QixFQUFnRGlOLE9BQWhELENBQWpCO0FBQ0FyVSxnQkFBUUEsTUFBTXVDLFFBQU4sRUFBUjtBQUNBdkMsZ0JBQVF3RyxXQUFXeEcsS0FBWCxDQUFSO0FBQ0EsWUFBSTZHLE9BQU83RyxLQUFQLElBQWdCLENBQXBCLEVBQXVCO0FBQ25CNEUscUJBQVNrQixJQUFULEdBQWdCLEdBQWhCO0FBQ0g7O0FBRUQsWUFBSS9GLE9BQU82RSxTQUFTM00sSUFBaEIsQ0FBSixFQUEyQjtBQUN2QjJNLHFCQUFTM00sSUFBVCxHQUFnQmdOLGdDQUFnQ0wsU0FBUzVNLElBQXpDLEVBQStDNE0sU0FBUzdNLElBQXhELENBQWhCO0FBQ0g7O0FBRUQ7O0FBdEI2QiwwQkF1QkZ5UixVQUFVeEosS0FBVixFQUFpQjRFLFFBQWpCLENBdkJFO0FBQUE7QUFBQSxZQXVCdEJ3SSxPQXZCc0I7QUFBQSxZQXVCYkMsT0F2QmE7O0FBd0I3QixZQUFJLENBQUNELE9BQUQsSUFBWSxDQUFDQyxPQUFqQixFQUEwQjtBQUN0QjtBQUNBeUUseUJBQWEsd0JBQWIsRUFBdUN0TyxRQUF2QztBQUNBWSx1Q0FBeUJwRSxLQUF6QiwrQ0FBd0U0RSxTQUFTNU0sSUFBakYsb0JBQW9HNE0sU0FBUzdNLElBQTdHO0FBQ0g7O0FBRUQ7QUFDQWlJLGdCQUFRZ0ksVUFBVWhJLEtBQVYsRUFBaUI0RSxRQUFqQixDQUFSO0FBQ0E1RSxnQkFBUStHLGNBQWMvRyxLQUFkLEVBQXFCNEUsUUFBckIsQ0FBUjtBQUNBNUUsZ0JBQVFtSCxVQUFVbkgsS0FBVixFQUFpQjRFLFFBQWpCLENBQVI7O0FBRUEsZUFBTzVFLEtBQVA7QUFDSCxLQXBDRDs7QUFzQ0E2RSxNQUFFdVIsRUFBRixDQUFLdGYsVUFBTCxHQUFrQkEsVUFBbEIsQ0FoOEZHLENBZzhGMkI7O0FBRTlCOzs7QUFHQUMsbUJBQWUsc0JBQUNpSixLQUFELEVBQVFxVSxPQUFSLEVBQW9CO0FBQy9CLFlBQUlwVSxZQUFZRCxLQUFaLEtBQXNCQSxVQUFVLElBQXBDLEVBQTBDO0FBQ3RDLG1CQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLFlBQUlrQixTQUFTbEIsS0FBVCxDQUFKLEVBQXFCO0FBQ2pCLG1CQUFPNkcsT0FBTzdHLEtBQVAsQ0FBUDtBQUNIOztBQUVELFlBQUlhLFFBQVFiLEtBQVIsS0FBa0JVLFNBQVNWLEtBQVQsQ0FBdEIsRUFBdUM7QUFBRTtBQUNyQztBQUNBb0UsNkdBQStGcEUsS0FBL0Y7QUFDSDs7QUFFRCxZQUFNNEUsV0FBV0MsRUFBRW1RLE1BQUYsQ0FBUyxFQUFULEVBQWE1ZCxlQUFiLEVBQThCLEVBQUVnUSxPQUFPLEtBQVQsRUFBOUIsRUFBZ0RpTixPQUFoRCxDQUFqQjtBQUNBLFlBQU1RLDRCQUEwQmpRLFNBQVNwTixJQUF6QztBQUNBLFlBQU1vSyxZQUFZLElBQUltRyxNQUFKLFFBQWdCOE0sT0FBaEIsUUFBNEIsSUFBNUIsQ0FBbEI7QUFDQTdVLGdCQUFRQSxNQUFNdUMsUUFBTixFQUFSOztBQUVBLFlBQUl2QyxNQUFNZ0csTUFBTixDQUFhLENBQWIsTUFBb0IsR0FBeEIsRUFBNkI7QUFDekJwQixxQkFBU2tCLElBQVQsR0FBZ0IsR0FBaEI7QUFDSCxTQUZELE1BRU8sSUFBSWxCLFNBQVNuTSxRQUFULElBQXFCbU0sU0FBU25NLFFBQVQsQ0FBa0JrSyxLQUFsQixDQUF3QixHQUF4QixFQUE2QixDQUE3QixNQUFvQzNDLE1BQU1nRyxNQUFOLENBQWEsQ0FBYixDQUE3RCxFQUE4RTtBQUNqRnBCLHFCQUFTa0IsSUFBVCxHQUFnQixHQUFoQjtBQUNBbEIscUJBQVN1QixLQUFULEdBQWlCLElBQWpCO0FBQ0FuRyxvQkFBUXFHLGdCQUFnQnJHLEtBQWhCLEVBQXVCNEUsUUFBdkIsQ0FBUjtBQUNIOztBQUVENUUsZ0JBQVFBLE1BQU04QixPQUFOLENBQWNGLFNBQWQsRUFBeUIsRUFBekIsQ0FBUjtBQUNBNUIsZ0JBQVFBLE1BQU04QixPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFSO0FBQ0E5QixnQkFBUTBHLFNBQVMxRyxLQUFULEVBQWdCNEUsU0FBUzVMLFVBQXpCLENBQVI7O0FBRUEsZUFBT2dILEtBQVA7QUFDSCxLQWpDRDs7QUFtQ0E2RSxNQUFFdVIsRUFBRixDQUFLSyxZQUFMLEdBQW9CMWYsWUFBcEIsQ0F4K0ZHLENBdytGK0I7O0FBRWxDOzs7Ozs7Ozs7OztBQVdBRSxlQUFXLGtCQUFDeWYsV0FBRCxFQUFvRDtBQUFBLFlBQXRDQywwQkFBc0MsdUVBQVQsSUFBUzs7QUFDM0QsWUFBTTFkLFFBQVEsSUFBZCxDQUQyRCxDQUN2Qzs7QUFFcEIsWUFBSWlILHlCQUF5QndXLFdBQXpCLEtBQXlDLENBQUNoVyxTQUFTZ1csV0FBVCxDQUExQyxJQUFtRTVWLFdBQVc0VixXQUFYLENBQXZFLEVBQWdHO0FBQzVGdFMsd0ZBQTBFc1MsV0FBMUU7QUFDSDs7QUFFRDtBQUNBLFlBQUlyQyxnQkFBSjtBQUNBLFlBQUlzQywwQkFBSixFQUFnQztBQUM1QnRDLHNCQUFVeFAsRUFBRW1RLE1BQUYsQ0FBUyxFQUFULEVBQWE1ZCxlQUFiLEVBQThCc2YsV0FBOUIsQ0FBVjtBQUNILFNBRkQsTUFFTztBQUNIckMsc0JBQVVxQyxXQUFWO0FBQ0g7O0FBRUQsWUFBTUUsc0JBQXNCLFVBQTVCO0FBQ0EsWUFBTUMsMEJBQTBCLFFBQWhDO0FBQ0E7QUFDQSxZQUFNQyw0Q0FBNEMsd0JBQWxEO0FBQ0EsWUFBTUMsNkJBQTZCLHNCQUFuQzs7QUFFQTtBQUNBLFlBQUksQ0FBQzdVLFVBQVVtUyxRQUFRaGQsSUFBbEIsRUFBd0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsRUFBaEIsQ0FBeEIsQ0FBTCxFQUFtRDtBQUMvQytNLDZJQUFxSGlRLFFBQVFoZCxJQUE3SDtBQUNIOztBQUVELFlBQUksQ0FBQ2tKLG9CQUFvQjhULFFBQVEvYyxJQUE1QixDQUFELElBQXNDLENBQUNnSixVQUFVK1QsUUFBUS9jLElBQWxCLENBQTNDLEVBQW9FO0FBQ2hFOE0seUdBQXFGaVEsUUFBUS9jLElBQTdGO0FBQ0g7O0FBRUQsWUFBSSxDQUFDc2Ysb0JBQW9CcFAsSUFBcEIsQ0FBeUI2TSxRQUFROWMsTUFBakMsQ0FBTCxFQUErQztBQUFFO0FBQzdDNk0seUlBQXlIaVEsUUFBUTljLE1BQWpJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDMkssVUFBVW1TLFFBQVE3YyxJQUFsQixFQUF3QixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXhCLENBQUwsRUFBMEM7QUFDdEM0TSx1SEFBbUdpUSxRQUFRN2MsSUFBM0c7QUFDSDs7QUFFRDtBQUNBLFlBQUk2YyxRQUFRN2MsSUFBUixLQUFpQjZjLFFBQVFoZCxJQUE3QixFQUFtQztBQUMvQitNLHdHQUF3RmlRLFFBQVE3YyxJQUFoRywrQ0FBNEk2YyxRQUFRaGQsSUFBcEo7QUFDSDs7QUFFRCxZQUFJLENBQUMwSSxPQUFPc1UsUUFBUTVjLE1BQWYsQ0FBRCxJQUEyQixDQUFDMEksU0FBU2tVLFFBQVE1YyxNQUFqQixDQUFoQyxFQUEwRDtBQUN0RDJNLDZIQUE2R2lRLFFBQVE1YyxNQUFySDtBQUNIOztBQUVELFlBQUk0YyxRQUFRM2MsS0FBUixLQUFrQixFQUFsQixJQUF3QixDQUFDeUksU0FBU2tVLFFBQVEzYyxLQUFqQixDQUE3QixFQUFzRDtBQUNsRDBNLHNHQUFzRmlRLFFBQVEzYyxLQUE5RjtBQUNIOztBQUVELFlBQUksQ0FBQ3dLLFVBQVVtUyxRQUFRMWMsS0FBbEIsRUFBeUIsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUF6QixDQUFMLEVBQTJDO0FBQ3ZDeU0sb0pBQWdJaVEsUUFBUTFjLEtBQXhJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDdUssVUFBVW1TLFFBQVF6YyxJQUFsQixFQUF3QixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUF4QixDQUFMLEVBQW9EO0FBQ2hEd00sZ0xBQXdKaVEsUUFBUXpjLElBQWhLO0FBQ0g7O0FBRUQsWUFBSSxDQUFDdUksU0FBU2tVLFFBQVF4YyxPQUFqQixDQUFELElBQStCd2MsUUFBUXhjLE9BQVIsS0FBb0IsRUFBcEIsS0FBMkJrSyxTQUFTc1MsUUFBUXhjLE9BQWpCLEVBQTBCLEdBQTFCLEtBQWtDZ2Ysd0JBQXdCclAsSUFBeEIsQ0FBNkI2TSxRQUFReGMsT0FBckMsQ0FBN0QsQ0FBbkMsRUFBaUo7QUFDN0l1TSxnS0FBOElpUSxRQUFReGMsT0FBdEo7QUFDSDs7QUFFRCxZQUFJLENBQUNrSSxPQUFPc1UsUUFBUXZjLE9BQWYsQ0FBRCxJQUE0QixDQUFDb0ssVUFBVW1TLFFBQVF2YyxPQUFsQixFQUEyQixDQUFDLFNBQUQsRUFBWSxPQUFaLEVBQXFCLFFBQXJCLENBQTNCLENBQWpDLEVBQTZGO0FBQ3pGc00scUpBQStIaVEsUUFBUXZjLE9BQXZJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDcUksU0FBU2tVLFFBQVF0YyxJQUFqQixDQUFELElBQTJCLENBQUMrZSwwQ0FBMEN0UCxJQUExQyxDQUErQzZNLFFBQVF0YyxJQUF2RCxDQUFoQyxFQUE4RjtBQUMxRnFNLDBKQUEwSWlRLFFBQVF0YyxJQUFsSjtBQUNIOztBQUVELFlBQUksQ0FBQ29JLFNBQVNrVSxRQUFRcmMsSUFBakIsQ0FBRCxJQUEyQixDQUFDOGUsMENBQTBDdFAsSUFBMUMsQ0FBK0M2TSxRQUFRcmMsSUFBdkQsQ0FBaEMsRUFBOEY7QUFDMUZvTSwwSkFBMElpUSxRQUFRcmMsSUFBbEo7QUFDSDs7QUFFRCxZQUFJb0osV0FBV2lULFFBQVFyYyxJQUFuQixJQUEyQm9KLFdBQVdpVCxRQUFRdGMsSUFBbkIsQ0FBL0IsRUFBeUQ7QUFDckRxTSw0SEFBNEdpUSxRQUFRcmMsSUFBcEgsMkNBQTRKcWMsUUFBUXRjLElBQXBLO0FBQ0g7O0FBRUQsWUFBSSxFQUFFZ0ksT0FBT3NVLFFBQVFwYyxJQUFmLEtBQ0RxSixNQUFNK1MsUUFBUXBjLElBQWQsS0FBdUJvYyxRQUFRcGMsSUFBUixJQUFnQixDQUR0QyxJQUM0QztBQUM3Q2tJLGlCQUFTa1UsUUFBUXBjLElBQWpCLEtBQTBCMmUsb0JBQW9CcFAsSUFBcEIsQ0FBeUI2TSxRQUFRcGMsSUFBakMsQ0FGM0IsQ0FBSixDQUV5RTtBQUZ6RSxVQUdFO0FBQ0VtTSxvSUFBZ0hpUSxRQUFRcGMsSUFBeEg7QUFDSDs7QUFFRDtBQUNBLFlBQU0rZSx1QkFBdUIvUixnQ0FBZ0NvUCxRQUFRcmMsSUFBeEMsRUFBOENxYyxRQUFRdGMsSUFBdEQsQ0FBN0I7QUFDQSxZQUFJLENBQUNnSSxPQUFPc1UsUUFBUXBjLElBQWYsQ0FBRCxJQUNDLENBQUN5SyxZQUFZMlIsUUFBUXJjLElBQXBCLEtBQTZCMEssWUFBWTJSLFFBQVF0YyxJQUFwQixDQUE5QixLQUE0RGlmLHlCQUF5Qm5RLE9BQU93TixRQUFRcGMsSUFBZixDQUQxRixFQUNpSDtBQUM3R3FNLDhDQUE4QitQLFFBQVFwYyxJQUF0QywyREFBOEZvYyxRQUFRcmMsSUFBdEcsd0JBQTJIcWMsUUFBUXRjLElBQW5JLFNBQTZJa0IsS0FBN0k7QUFDSDs7QUFFRCxZQUFJLENBQUNvYixRQUFRN2IsSUFBVCxJQUFpQixDQUFDdUgsT0FBT3NVLFFBQVFwYyxJQUFmLENBQXRCLEVBQTRDO0FBQ3hDcU0saUdBQStFK1AsUUFBUXBjLElBQXZGLFNBQWlHZ0IsS0FBakc7QUFDSDs7QUFFRCxZQUFJLENBQUM4RyxPQUFPc1UsUUFBUW5jLElBQWYsQ0FBRCxLQUEwQixDQUFDaUksU0FBU2tVLFFBQVFuYyxJQUFqQixDQUFELElBQTJCLENBQUMwZSxvQkFBb0JwUCxJQUFwQixDQUF5QjZNLFFBQVFuYyxJQUFqQyxDQUF0RCxDQUFKLEVBQW1HO0FBQy9Ga00saUlBQWlIaVEsUUFBUW5jLElBQXpIO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLENBQUM2SCxPQUFPc1UsUUFBUW5jLElBQWYsQ0FBRCxJQUF5QixDQUFDNkgsT0FBT3NVLFFBQVFwYyxJQUFmLENBQTFCLElBQWtENE8sT0FBT3dOLFFBQVFwYyxJQUFmLElBQXVCNE8sT0FBT3dOLFFBQVFuYyxJQUFmLENBQTdFLEVBQW1HO0FBQy9Ga00sOEdBQThGaVEsUUFBUW5jLElBQXRHLHdDQUEySW1jLFFBQVFwYyxJQUFuSjtBQUNIOztBQUVELFlBQUksQ0FBQzhILE9BQU9zVSxRQUFRbGMsWUFBZixDQUFELElBQWlDLENBQUM0ZSwyQkFBMkJ2UCxJQUEzQixDQUFnQzZNLFFBQVFsYyxZQUF4QyxDQUF0QyxFQUE2RjtBQUN6RmlNLDJJQUEySGlRLFFBQVFsYyxZQUFuSTtBQUNIOztBQUVELFlBQUksQ0FBQzRILE9BQU9zVSxRQUFRamMsWUFBZixDQUFELElBQWlDLENBQUN3ZSxvQkFBb0JwUCxJQUFwQixDQUF5QjZNLFFBQVFqYyxZQUFqQyxDQUF0QyxFQUFzRjtBQUNsRmdNLGdJQUFnSGlRLFFBQVFqYyxZQUF4SDtBQUNIOztBQUVELFlBQUksQ0FBQzJILE9BQU9zVSxRQUFRaGMsV0FBZixDQUFELElBQWdDLENBQUM4SCxTQUFTa1UsUUFBUWhjLFdBQWpCLENBQXJDLEVBQW9FO0FBQ2hFK0wseUdBQXlGaVEsUUFBUWhjLFdBQWpHO0FBQ0g7O0FBRUQsWUFBSSxDQUFDa0ksb0JBQW9COFQsUUFBUS9iLEtBQTVCLENBQUQsSUFBdUMsQ0FBQ2dJLFVBQVUrVCxRQUFRL2IsS0FBbEIsQ0FBNUMsRUFBc0U7QUFDbEU4TCxrSUFBOEdpUSxRQUFRL2IsS0FBdEg7QUFDSDs7QUFFRCxZQUFJLENBQUM0SixVQUFVbVMsUUFBUTliLE1BQWxCLEVBQTBCLENBQzNCLEdBRDJCLEVBRTNCLEdBRjJCLEVBRzNCLEdBSDJCLEVBSTNCLEdBSjJCLEVBSzNCLEdBTDJCLEVBTTNCLEdBTjJCLEVBTzNCLEdBUDJCLEVBUTNCLEdBUjJCLEVBUzNCLEdBVDJCLEVBVTNCLEtBVjJCLEVBVzNCLEtBWDJCLEVBWTNCLEtBWjJCLEVBYTNCLEtBYjJCLENBQTFCLENBQUwsRUFjSTtBQUNBNkwsNk5BQW1MaVEsUUFBUTliLE1BQTNMO0FBQ0g7O0FBRUQsWUFBSSxDQUFDZ0ksb0JBQW9COFQsUUFBUTdiLElBQTVCLENBQUQsSUFBc0MsQ0FBQzhILFVBQVUrVCxRQUFRN2IsSUFBbEIsQ0FBM0MsRUFBb0U7QUFDaEU0TCxpSUFBNkdpUSxRQUFRN2IsSUFBckg7QUFDSDs7QUFFRCxZQUFJLENBQUN1SCxPQUFPc1UsUUFBUTViLFFBQWYsQ0FBRCxJQUE2QixDQUFDeUosVUFBVW1TLFFBQVE1YixRQUFsQixFQUE0QixDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsS0FBZixFQUFzQixLQUF0QixDQUE1QixDQUFsQyxFQUE2RjtBQUN6RjJMLHlKQUFpSWlRLFFBQVE1YixRQUF6STtBQUNIOztBQUVELFlBQUksQ0FBQ3lKLFVBQVVtUyxRQUFRM2IsTUFBbEIsRUFBMEIsQ0FBQyxPQUFELEVBQVUsT0FBVixFQUFtQixRQUFuQixFQUE2QixNQUE3QixDQUExQixDQUFMLEVBQXNFO0FBQ2xFMEwsMEpBQWtJaVEsUUFBUTNiLE1BQTFJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDd0osVUFBVW1TLFFBQVExYixLQUFsQixFQUF5QixDQUFDLE9BQUQsRUFBVSxNQUFWLEVBQWtCLE1BQWxCLENBQXpCLENBQUwsRUFBMEQ7QUFDdER5TCwwSUFBb0hpUSxRQUFRMWIsS0FBNUg7QUFDSDs7QUFFRCxZQUFJLENBQUM0SCxvQkFBb0I4VCxRQUFRemIsS0FBNUIsQ0FBRCxJQUF1QyxDQUFDMEgsVUFBVStULFFBQVF6YixLQUFsQixDQUE1QyxFQUFzRTtBQUNsRXdMLG1JQUErR2lRLFFBQVF6YixLQUF2SDtBQUNIOztBQUVELFlBQUksQ0FBQzJILG9CQUFvQjhULFFBQVF4YixPQUE1QixDQUFELElBQXlDLENBQUN5SCxVQUFVK1QsUUFBUXhiLE9BQWxCLENBQTlDLEVBQTBFO0FBQ3RFdUwsK0hBQTJHaVEsUUFBUXhiLE9BQW5IO0FBQ0g7O0FBRUQsWUFBSSxDQUFDa0gsT0FBT3NVLFFBQVF2YixTQUFmLENBQUQsSUFBK0J1YixRQUFRdmIsU0FBUixLQUFzQixFQUF0QixJQUE0QixDQUFDZ2UsMENBQTBDdFAsSUFBMUMsQ0FBK0M2TSxRQUFRdmIsU0FBdkQsQ0FBaEUsRUFBb0k7QUFDaElzTCxrS0FBa0ppUSxRQUFRdmIsU0FBMUo7QUFDSDs7QUFFRCxZQUFJLENBQUN5SCxvQkFBb0I4VCxRQUFRdGIsYUFBNUIsQ0FBRCxJQUErQyxDQUFDdUgsVUFBVStULFFBQVF0YixhQUFsQixDQUFwRCxFQUFzRjtBQUNsRnFMLDhJQUEwSGlRLFFBQVF0YixhQUFsSTtBQUNIOztBQUVELFlBQUksQ0FBQ2dILE9BQU9zVSxRQUFRcmIsVUFBZixDQUFELElBQStCLENBQUNrSixVQUFVbVMsUUFBUXJiLFVBQWxCLEVBQThCLENBQzlELFFBRDhELEVBRTlELFFBRjhELEVBRzlELEdBSDhELEVBSTlELElBSjhELEVBSzlELEdBTDhELEVBTTlELElBTjhELEVBTzlELElBUDhELEVBUTlELElBUjhELENBQTlCLENBQXBDLEVBU0k7QUFDQW9MLDJMQUEySmlRLFFBQVFyYixVQUFuSztBQUNIOztBQUVELFlBQUksQ0FBQ3VILG9CQUFvQjhULFFBQVFwYixLQUE1QixDQUFELElBQXVDLENBQUNxSCxVQUFVK1QsUUFBUXBiLEtBQWxCLENBQTVDLEVBQXNFO0FBQ2xFbUwsZ0hBQTRGaVEsUUFBUXBiLEtBQXBHO0FBQ0g7QUFDSixLQTVMRDs7QUE4TEE0TCxNQUFFdVIsRUFBRixDQUFLbmYsUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUE7Ozs7OztBQU1BQyx1QkFBbUIsMEJBQVNtZCxPQUFULEVBQWtCO0FBQ2pDLFlBQUk0QyxVQUFVLElBQWQ7QUFDQSxZQUFJO0FBQ0FoZ0IscUJBQVNvZCxPQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU82QyxLQUFQLEVBQWM7QUFDVkQsc0JBQVUsS0FBVjtBQUNIOztBQUVELGVBQU9BLE9BQVA7QUFDSCxLQVZEOztBQVlBOzs7Ozs7OztBQVFBLGFBQVNuRixZQUFULENBQXNCcUYsU0FBdEIsRUFBb0U7QUFBQSxZQUFuQzlMLE9BQW1DLHVFQUF6QjdILFFBQXlCO0FBQUEsWUFBZjRULE1BQWUsdUVBQU4sSUFBTTs7QUFDaEUsWUFBSXBVLGNBQUo7QUFDQSxZQUFJbkQsT0FBT3dYLFdBQVgsRUFBd0I7QUFDcEJyVSxvQkFBUSxJQUFJcVUsV0FBSixDQUFnQkYsU0FBaEIsRUFBMkIsRUFBRUMsY0FBRixFQUFVRSxTQUFTLEtBQW5CLEVBQTBCQyxZQUFZLEtBQXRDLEVBQTNCLENBQVIsQ0FEb0IsQ0FDK0Q7QUFDdEYsU0FGRCxNQUVPO0FBQ0h2VSxvQkFBUVEsU0FBU2dVLFdBQVQsQ0FBcUIsYUFBckIsQ0FBUjtBQUNBeFUsa0JBQU15VSxlQUFOLENBQXNCTixTQUF0QixFQUFpQyxJQUFqQyxFQUF1QyxJQUF2QyxFQUE2QyxFQUFFQyxjQUFGLEVBQTdDO0FBQ0g7O0FBRUQvTCxnQkFBUXFNLGFBQVIsQ0FBc0IxVSxLQUF0QjtBQUNIOztBQUVEOzs7QUFHQSxLQUFDLFlBQVc7QUFDUixZQUFJLE9BQU9uRCxPQUFPd1gsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQVNBLFdBQVQsQ0FBcUJyVSxLQUFyQixFQUE0QjJVLE1BQTVCLEVBQW9DO0FBQ2hDQSxxQkFBU0EsVUFBVSxFQUFFTCxTQUFTLEtBQVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNUSxNQUFNcFUsU0FBU2dVLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBSSxnQkFBSUgsZUFBSixDQUFvQnpVLEtBQXBCLEVBQTJCMlUsT0FBT0wsT0FBbEMsRUFBMkNLLE9BQU9KLFVBQWxELEVBQThESSxPQUFPUCxNQUFyRTtBQUNBLG1CQUFPUSxHQUFQO0FBQ0g7O0FBRURQLG9CQUFZL1UsU0FBWixHQUF3QnpDLE9BQU9nWSxLQUFQLENBQWF2VixTQUFyQztBQUNBekMsZUFBT3dYLFdBQVAsR0FBcUJBLFdBQXJCO0FBQ0gsS0FkRDtBQWVILENBenZHQSxDQUFEOztBQTJ2R0E7OztrQkFHZTtBQUNYUyxZQUFVaGhCLFVBREM7QUFFWGloQixjQUFVaGhCLFlBRkM7QUFHWEMsc0NBSFc7QUFJWEMsc0JBSlcsRUFJRDtBQUNWQyxzQ0FMVyxFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogYXV0b051bWVyaWMuanNcbiogQGF1dGhvcjogQm9iIEtub3RoZVxuKiBAY29udHJpYnV0b3JzOiBTb2tvbG92IFl1cmEgYW5kIG90aGVyIEdpdGh1YiB1c2Vyc1xuKiBAdmVyc2lvbjogMi4wIC0gMjAxNi0xMi0wMSBVVEMgMjE6MDBcbipcbiogQ3JlYXRlZCBieSBSb2JlcnQgSi4gS25vdGhlIG9uIDIwMDktMDgtMDkuIFBsZWFzZSByZXBvcnQgYW55IGJ1Z3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL0JvYktub3RoZS9hdXRvTnVtZXJpY1xuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4qXG4qIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vKiBnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBkZWZpbmUgKi9cblxuLy8gRnVuY3Rpb25zIG5hbWVzIGZvciBFUzYgZXhwb3J0c1xubGV0IGF1dG9Gb3JtYXQ7XG5sZXQgYXV0b1VuRm9ybWF0O1xubGV0IGdldERlZmF1bHRDb25maWc7XG5sZXQgdmFsaWRhdGU7XG5sZXQgYXJlU2V0dGluZ3NWYWxpZDtcblxuLy8gQXV0b051bWVyaWMgZGVmYXVsdCBzZXR0aW5nc1xuLyoqXG4gKiBMaXN0IG9mIGFsbG93ZWQgdGFnIG9uIHdoaWNoIGF1dG9OdW1lcmljIGNhbiBiZSB1c2VkLlxuICovXG5jb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAnYicsXG4gICAgJ2NhcHRpb24nLFxuICAgICdjaXRlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvbnN0JyxcbiAgICAnZGQnLFxuICAgICdkZWwnLFxuICAgICdkaXYnLFxuICAgICdkZm4nLFxuICAgICdkdCcsXG4gICAgJ2VtJyxcbiAgICAnaDEnLFxuICAgICdoMicsXG4gICAgJ2gzJyxcbiAgICAnaDQnLFxuICAgICdoNScsXG4gICAgJ2g2JyxcbiAgICAnaW5zJyxcbiAgICAna2RiJyxcbiAgICAnbGFiZWwnLFxuICAgICdsaScsXG4gICAgJ29wdGlvbicsXG4gICAgJ291dHB1dCcsXG4gICAgJ3AnLFxuICAgICdxJyxcbiAgICAncycsXG4gICAgJ3NhbXBsZScsXG4gICAgJ3NwYW4nLFxuICAgICdzdHJvbmcnLFxuICAgICd0ZCcsXG4gICAgJ3RoJyxcbiAgICAndScsXG5dO1xuXG4vKipcbiAqIERlZmF1bHRzIG9wdGlvbnMgYXJlIHB1YmxpYyAtIHRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmc6XG4gKiAtIEhUTUw1IGRhdGEgYXR0cmlidXRlc1xuICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcbiAqIC0gVXNlIGpRdWVyeSdzIGAkLmV4dGVuZGAgbWV0aG9kIGZvciBnbG9iYWwgY2hhbmdlcyAtIGFsc28gYSBncmVhdCB3YXkgdG8gcGFzcyBBU1AuTkVUIGN1cnJlbnQgY3VsdHVyZSBzZXR0aW5nc1xuICovXG5jb25zdCBkZWZhdWx0U2V0dGluZ3MgPSB7XG4gICAgLyogQWxsb3dlZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICogYXBvc3Ryb3BoZSBpcyBlc2NhcGVkID0gXCJcXFwiXCJcbiAgICAgKiBzcGFjZSA9IFwiIFwiXG4gICAgICogbm9uZSA9IFwiXCJcbiAgICAgKiBOT1RFOiBkbyBub3QgdXNlIG51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGFTZXA6ICcsJyxcblxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKi9cbiAgICBuU2VwOiBmYWxzZSxcblxuICAgIC8qIERpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcbiAgICAgKiBkR3JvdXA6IFwiMlwiLCByZXN1bHRzIGluIDk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzXG4gICAgICogZEdyb3VwOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxuICAgICAqIGRHcm91cDogXCI0XCIsIHJlc3VsdHMgaW4gOTk5OSw5OTk5LDk5OTkgdXNlZCBpbiBzb21lIEFzaWFuIGNvdW50cmllc1xuICAgICAqL1xuICAgIGRHcm91cDogJzMnLFxuXG4gICAgLyogQWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgKi9cbiAgICBhRGVjOiAnLicsXG5cbiAgICAvKiBBbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgYURlY1xuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgKi9cbiAgICBhbHREZWM6IG51bGwsXG5cbiAgICAvKiBhU2lnbiA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXG4gICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICckICdcbiAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnICQnXG4gICAgICovXG4gICAgYVNpZ246ICcnLFxuXG4gICAgLyogcFNpZ24gPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XG4gICAgICogZm9yIHByZWZpeCBwU2lnbjogXCJwXCIgKGRlZmF1bHQpXG4gICAgICogZm9yIHN1ZmZpeCBwU2lnbjogXCJzXCJcbiAgICAgKi9cbiAgICBwU2lnbjogJ3AnLFxuXG4gICAgLyogUGxhY2VtZW50IG9mIG5lZ2F0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGFTaWduIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcbiAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxuICAgICAqIC0kMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIn1cbiAgICAgKiAkLTEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwiclwifVxuICAgICAqIC0xLDIzNC41NiQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn1cbiAgICAgKiAxLDIzNC41Ni0gID0+IHtwTmVnOiBcInNcIn1cbiAgICAgKiAkMSwyMzQuNTYtID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwic1wifVxuICAgICAqIDEsMjM0LjU2LSQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wifVxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInJcIn1cbiAgICAgKi9cbiAgICBwTmVnOiAnbCcsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTdWZmaXg6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBhU3VmZml4OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqL1xuICAgIGFTdWZmaXg6ICcnLFxuXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcbiAgICAgKiBvTGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIHZNYXggYW5kIGlnbm9yZXMgdk1pbiBzZXR0aW5nc1xuICAgICAqIG9MaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIHZNaW4gYW5kIGlnbm9yZXMgdk1heCBzZXR0aW5nc1xuICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICovXG4gICAgb0xpbWl0czogbnVsbCxcblxuICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICogdmFsdWUgbXVzdCBiZSBsYXJnZXIgdGhhbiB2TWluXG4gICAgICovXG4gICAgdk1heDogJzk5OTk5OTk5OTk5OTkuOTknLCAvLyA5Ljk5OS45OTkuOTk5Ljk5OSw5OSB+PSAxMDAwMCBiaWxsaW9uc1xuXG4gICAgLyogTWluaW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbiB2TWF4XG4gICAgICovXG4gICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JywgLy8gLTkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgKi9cbiAgICBtRGVjOiBudWxsLFxuXG4gICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XG4gICAgICoge2VEZWM6IFwiNVwifSBhbmQgdGhlIGRlZmF1bHQgMiBkZWNpbWFsIHBsYWNlcyB3aXRoIGZvY3VzIFwiMSwwMDAuMTIzNDVcIiB3aXRob3V0IGZvY3VzIFwiMSwwMDAuMTJcIiB0aGUgcmVzdWx0cyBkZXBlbmRzIG9uIHRoZSByb3VuZGluZyBtZXRob2QgdXNlZFxuICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAqL1xuICAgIGVEZWM6IG51bGwsXG5cbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbCAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJhU3RvclwiIG9wdGlvbiB0byBlbnN1cmUgcmV0YWluaW5nIHRoZSB2YWx1ZVxuICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxuICAgICAqIEV4YW1wbGU6IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25zIHNldCB7c2NhbGVEaXZpc29yOiAnMTAwMCcsIHNjYWxlRGVjaW1hbDogJzEnLCBzY2FsZVN5bWJvbDogJyBLJ31cbiAgICAgKiBFeGFtcGxlOiBmb2N1c2luIHZhbHVlIFwiMSwxMTEuMTFcIiBmb2N1c291dCB2YWx1ZSBcIjEuMSBLXCJcbiAgICAgKi9cblxuICAgIC8qIFRoZSBgc2NhbGVEaXZpc29yYCBkZWNpZGVzIHRoZSBvbiBmb2N1cyB2YWx1ZSBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IG9uIGZvY3Vzb3V0XG4gICAgICogRXhhbXBsZSB7c2NhbGVEaXZpc29yOiAnMTAwMCd9IG9yIDxpbnB1dCBkYXRhLXNjYWxlLWRpdmlzb3I9XCIxMDAwXCI+XG4gICAgICogVGhlIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciBidXQgcGxlYXNlIHVuZGVyc3RhbmQgdGhhdCBKYXZhc2NyaXB0IGhhcyBsaW1pdGVkIGFjY3VyYWN5IGluIG1hdGhcbiAgICAgKiBUaGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSAnaGlkZGVuJyBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBzY2FsZURpdmlzb3I6IG51bGwsXG5cbiAgICAvKlxuICAgICAqIFRoZSBgc2NhbGVEZWNpbWFsYCBvcHRpb24gaXMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlIHdoZW4gbm90IGluIGZvY3VzIC0gZm9yIHRoaXMgdG8gd29yaywgYHNjYWxlZERpdmlzb3JgIG11c3Qgbm90IGJlIGBudWxsYC5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxuICAgICAqL1xuICAgIHNjYWxlRGVjaW1hbDogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbDogbnVsbCxcblxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBlRGVjIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAqL1xuICAgIGFTdG9yOiBmYWxzZSxcblxuICAgIC8qIG1ldGhvZCB1c2VkIGZvciByb3VuZGluZ1xuICAgICAqIG1Sb3VuZDogXCJTXCIsIFJvdW5kLUhhbGYtVXAgU3ltbWV0cmljIChkZWZhdWx0KVxuICAgICAqIG1Sb3VuZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIG1Sb3VuZDogXCJzXCIsIFJvdW5kLUhhbGYtRG93biBTeW1tZXRyaWMgKGxvd2VyIGNhc2UgcylcbiAgICAgKiBtUm91bmQ6IFwiYVwiLCBSb3VuZC1IYWxmLURvd24gQXN5bW1ldHJpYyAobG93ZXIgY2FzZSBhKVxuICAgICAqIG1Sb3VuZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIG1Sb3VuZDogXCJVXCIsIFJvdW5kIFVwIFwiUm91bmQtQXdheS1Gcm9tLVplcm9cIlxuICAgICAqIG1Sb3VuZDogXCJEXCIsIFJvdW5kIERvd24gXCJSb3VuZC1Ub3dhcmQtWmVyb1wiIC0gc2FtZSBhcyB0cnVuY2F0ZVxuICAgICAqIG1Sb3VuZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIG1Sb3VuZDogXCJGXCIsIFJvdW5kIHRvIEZsb29yIFwiVG93YXJkIE5lZ2F0aXZlIEluZmluaXR5XCJcbiAgICAgKiBtUm91bmQ6IFwiTjA1XCIgUm91bmRzIHRvIHRoZSBuZWFyZXN0IC4wNSA9PiBzYW1lIGFzIFwiQ0hGXCIgdXNlZCBpbiAxLjlYIGFuZCBzdGlsbCB2YWxpZFxuICAgICAqIG1Sb3VuZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiBtUm91bmQ6IFwiRDA1XCIgUm91bmRzIGRvd24gdG8gbmV4dCAuMDVcbiAgICAgKi9cbiAgICBtUm91bmQ6ICdTJyxcblxuICAgIC8qIENvbnRyb2xzIGRlY2ltYWwgcGFkZGluZ1xuICAgICAqIGFQYWQ6IHRydWUgLSBhbHdheXMgUGFkIGRlY2ltYWxzIHdpdGggemVyb3NcbiAgICAgKiBhUGFkOiBmYWxzZSAtIGRvZXMgbm90IHBhZCB3aXRoIHplcm9zLlxuICAgICAqIE5vdGU6IHNldHRpbmcgYVBhZCB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdtRGVjJyBzZXR0aW5nLlxuICAgICAqXG4gICAgICogdGhhbmtzIHRvIEpvbmFzIEpvaGFuc3NvbiBmb3IgdGhlIHN1Z2dlc3Rpb25cbiAgICAgKi9cbiAgICBhUGFkOiB0cnVlLFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIG5CcmFja2V0OiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICogbkJyYWNrZXQ6ICcoLCknLCBuQnJhY2tldDogJ1ssXScsIG5CcmFja2V0OiAnPCw+JyBvciBuQnJhY2tldDogJ3ssfSdcbiAgICAgKi9cbiAgICBuQnJhY2tldDogbnVsbCxcblxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAqIHdFbXB0eTogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgKiB3RW1wdHk6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICogd0VtcHR5OiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgKiB3RW1wdHk6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgKi9cbiAgICAvL1RPRE8gQWRkIGFuIG9wdGlvbiB0byBkaXNwbGF5IHRoZSBjdXJyZW5jeSBzaWduIG9ubHkgb24gaG92ZXIgKGlmIHRoZSBpbnB1dCBpcyBlbXB0eSlcbiAgICB3RW1wdHk6ICdmb2N1cycsXG5cbiAgICAvKiBDb250cm9scyBsZWFkaW5nIHplcm8gYmVoYXZpb3JcbiAgICAgKiBsWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgKiBsWmVybzogXCJkZW55XCIsIC0gYWxsb3dzIG9ubHkgb25lIGxlYWRpbmcgemVybyBvbiB2YWx1ZXMgbGVzcyB0aGFuIG9uZVxuICAgICAqIGxaZXJvOiBcImtlZXBcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBvbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIHJldGFpbmVkLlxuICAgICAqL1xuICAgIGxaZXJvOiAnZGVueScsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogdHJ1ZSA9IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICovXG4gICAgYUZvcm06IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxuICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgKiBpZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNOdW1iZXI6IGZhbHNlLFxuXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBleGFtcGxlczpcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2FuRGVmYXVsdDogXCJcIn1cbiAgICAgKiB2YWx1ZT0xMjM0LjU2IHthbkRlZmF1bHQ6ICcxMjM0LjU2J31cbiAgICAgKi9cbiAgICBhbkRlZmF1bHQ6IG51bGwsXG5cbiAgICAvKiBSZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcbiAgICAgKi9cbiAgICB1blNldE9uU3VibWl0OiBmYWxzZSxcblxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICogbnVsbCBvciAnc3RyaW5nJyA9PiAnbm5ubi5ubicgb3IgJy1ubm5uLm5uJyBhcyB0ZXh0IHR5cGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAqICcsJyBvciAnLSwnICAgICAgPT4gJ25ubm4sbm4nIG9yICctbm5ubixubidcbiAgICAgKiAnLi0nICAgICAgICAgICAgID0+ICdubm5uLm5uJyBvciAnbm5ubi5ubi0nXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAqL1xuICAgIG91dHB1dFR5cGU6IG51bGwsXG5cbiAgICAvKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAqIHRydWUgPT4gYWxsIGVycm9ycyBhcmUgdGhyb3duIC0gaGVscGZ1bCBpbiBzaXRlIGRldmVsb3BtZW50XG4gICAgICogZmFsc2UgPT4gdGhyb3dzIGVycm9ycyB3aGVuIGNhbGxpbmcgbWV0aG9kcyBwcmlvciB0byB0aGUgc3VwcG9ydGVkIGVsZW1lbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYmUgYXV0b051bWVyaWNcbiAgICAgKi9cbiAgICBkZWJ1ZzogZmFsc2UsXG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICovXG5jb25zdCBrZXlDb2RlID0ge1xuICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgIFRhYjogICAgICAgICAgICA5LFxuICAgIEVudGVyOiAgICAgICAgICAxMyxcbiAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgQ3RybDogICAgICAgICAgIDE3LFxuICAgIEFsdDogICAgICAgICAgICAxOCxcbiAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgQ2Fwc0xvY2s6ICAgICAgIDIwLFxuICAgIEVzYzogICAgICAgICAgICAyNyxcbiAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgUGFnZVVwOiAgICAgICAgIDMzLFxuICAgIFBhZ2VEb3duOiAgICAgICAzNCxcbiAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgSG9tZTogICAgICAgICAgIDM2LFxuICAgIExlZnRBcnJvdzogICAgICAzNyxcbiAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgUmlnaHRBcnJvdzogICAgIDM5LFxuICAgIERvd25BcnJvdzogICAgICA0MCxcbiAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgRGVsZXRlOiAgICAgICAgIDQ2LFxuICAgIG51bTA6ICAgICAgICAgICA0OCxcbiAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgbnVtMjogICAgICAgICAgIDUwLFxuICAgIG51bTM6ICAgICAgICAgICA1MSxcbiAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgbnVtNTogICAgICAgICAgIDUzLFxuICAgIG51bTY6ICAgICAgICAgICA1NCxcbiAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgbnVtODogICAgICAgICAgIDU2LFxuICAgIG51bTk6ICAgICAgICAgICA1NyxcbiAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgYjogICAgICAgICAgICAgIDY2LFxuICAgIGM6ICAgICAgICAgICAgICA2NyxcbiAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgZTogICAgICAgICAgICAgIDY5LFxuICAgIGY6ICAgICAgICAgICAgICA3MCxcbiAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgaDogICAgICAgICAgICAgIDcyLFxuICAgIGk6ICAgICAgICAgICAgICA3MyxcbiAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgazogICAgICAgICAgICAgIDc1LFxuICAgIGw6ICAgICAgICAgICAgICA3NixcbiAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgbjogICAgICAgICAgICAgIDc4LFxuICAgIG86ICAgICAgICAgICAgICA3OSxcbiAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgcTogICAgICAgICAgICAgIDgxLFxuICAgIHI6ICAgICAgICAgICAgICA4MixcbiAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgdDogICAgICAgICAgICAgIDg0LFxuICAgIHU6ICAgICAgICAgICAgICA4NSxcbiAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgdzogICAgICAgICAgICAgIDg3LFxuICAgIHg6ICAgICAgICAgICAgICA4OCxcbiAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgejogICAgICAgICAgICAgIDkwLFxuICAgIFdpbmRvd3M6ICAgICAgICA5MSxcbiAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgbnVtcGFkMDogICAgICAgIDk2LFxuICAgIG51bXBhZDE6ICAgICAgICA5NyxcbiAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgbnVtcGFkMzogICAgICAgIDk5LFxuICAgIG51bXBhZDQ6ICAgICAgICAxMDAsXG4gICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICBudW1wYWQ2OiAgICAgICAgMTAyLFxuICAgIG51bXBhZDc6ICAgICAgICAxMDMsXG4gICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICBudW1wYWQ5OiAgICAgICAgMTA1LFxuICAgIE11bHRpcGx5TnVtcGFkOiAxMDYsXG4gICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICBNaW51c051bXBhZDogICAgMTA5LFxuICAgIERvdE51bXBhZDogICAgICAxMTAsXG4gICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICBGMTogICAgICAgICAgICAgMTEyLFxuICAgIEYyOiAgICAgICAgICAgICAxMTMsXG4gICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICBGNDogICAgICAgICAgICAgMTE1LFxuICAgIEY1OiAgICAgICAgICAgICAxMTYsXG4gICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICBGNzogICAgICAgICAgICAgMTE4LFxuICAgIEY4OiAgICAgICAgICAgICAxMTksXG4gICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICBGMTA6ICAgICAgICAgICAgMTIxLFxuICAgIEYxMTogICAgICAgICAgICAxMjIsXG4gICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICBOdW1Mb2NrOiAgICAgICAgMTQ0LFxuICAgIFNjcm9sbExvY2s6ICAgICAxNDUsXG4gICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICBNeUNhbGN1bGF0b3I6ICAgMTgzLFxuICAgIFNlbWljb2xvbjogICAgICAxODYsXG4gICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICBDb21tYTogICAgICAgICAgMTg4LFxuICAgIEh5cGhlbjogICAgICAgICAxODksXG4gICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICBTbGFzaDogICAgICAgICAgMTkxLFxuICAgIEJhY2txdW90ZTogICAgICAxOTIsXG4gICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICBCYWNrc2xhc2g6ICAgICAgMjIwLFxuICAgIFJpZ2h0QnJhY2tldDogICAyMjEsXG4gICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICBDb21tYW5kOiAgICAgICAgMjI0LFxufTtcblxuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xufSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xufVxufSgkID0+IHtcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyBudWxsXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIG51bGwgb3IgZW1wdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFueSBjYXNlcyBmb3IgdGhvc2Ugc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1RydWVPckZhbHNlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG93ZXJjYXNlVmFsdWUgPT09ICd0cnVlJyB8fCBsb3dlcmNhc2VWYWx1ZSA9PT0gJ2ZhbHNlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdChyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZlcmVuY2UgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QgYW5kIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5LW9iamVjdC10ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIChvciBhIG51bWJlciB3cml0dGVuIGFzIGEgc3RyaW5nKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc0FycmF5KG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgKGFuZCBub3QgYSBmbG9hdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludChuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgcGFyc2VGbG9hdChuKSA9PT0gcGFyc2VJbnQobiwgMTApICYmICFpc05hTihuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgdGV4dCBnaXZlbiBhcyBhIHBhcmFtZXRlciBpcyB2YWxpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZFBhc3RlVGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQHBhcmFtIGhvbGRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIGF1dG9TdHJpcCh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5hRGVjLCAnLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXkoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgdGhyb3cgZXJyb3IgbWVzc2FnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGRpc3BsYXkgYSB3YXJuaW5nIG1lc3NhZ2VzLCBhY2NvcmRpbmcgdG8gdGhlIGRlYnVnIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN1cHByZXNzV2FybmluZ3MgSWYgVFJVRSwgdGhlbiB0aGUgd2FybmluZyBtZXNzYWdlIGlzIG5vdCBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHN1cHByZXNzV2FybmluZ3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc3VwcHJlc3NXYXJuaW5ncykge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXV0b051bWVyaWMtc3BlY2lmaWMgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBSdW4gYW55IGNhbGxiYWNrcyBmb3VuZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqIEFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbWF4aW11bSBkZWNpbWFsIGxlbmd0aCBmcm9tIHRoZSB2TWluIGFuZCB2TWF4IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCh2TWluLCB2TWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkZWNpbWFsUGxhY2VzKHZNaW4pLCBkZWNpbWFsUGxhY2VzKHZNYXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBhbGwgdW53YW50ZWQgY2hhcmFjdGVycyBhbmQgbGVhdmUgb25seSBhIG51bWJlciBhbGVydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1N0cmlwKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2lnbiAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTaWduLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdWZmaXhcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5hU3VmZml4KSkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVN1ZmZpeCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgcmVwbGFjZSBhbnl0aGluZyBiZWZvcmUgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xuXG4gICAgICAgIGlmICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIGNvbnRhaW5zKHMsICctJykgJiYgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyBUaGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGluZyBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsdERlYywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5hTmVnKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5hRGVjICsgZGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3MubFplcm8gPT09ICdkZW55JykgfHxcbiAgICAgICAgICAgICghc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycpKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnN0cmlwUmVnLCAnJDEkMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2VzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoKHNldHRpbmdzLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpKSB7XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBsb2NhbGUgZm9ybWF0IHRvIEphdmFzY3JpcHQgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWQgb2YgY3VycmVuY3kgc2lnbnMgYWxsb3dlZFxuICAgICAqICcxMjM0LjU2JyAgICBPS1xuICAgICAqICctMTIzNC41NicgICBPS1xuICAgICAqICcxMjM0LjU2LScgICBPS1xuICAgICAqICcxMjM0LDU2JyAgICBPS1xuICAgICAqICctMTIzNCw1NicgICBPS1xuICAgICAqICcxMjM0LDU2LScgICBPS1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Mb2NhbGUocykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudC5cbiAgICAgKiBTZWUgdGhlIFwib3V0cHV0VHlwZVwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAoaXNOdWxsKGxvY2FsZSkgfHwgbG9jYWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4tJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgY2FzZSAnLSwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLC0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zKHJlc3VsdCwgJy0nKSA/IHJlc3VsdC5yZXBsYWNlKCctJywgJycpICsgJy0nIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2FzZVxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBjYXNlICctLic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gb3V0cHV0VHlwZSBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZml4TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYURlYywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYU5lZyAhPT0gJy0nICYmIHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcbiAgICAgICAgICAgIHMgKz0gJzAuMDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSByZWFsIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gb3VyIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICE9PSAnLScgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLmFOZWcpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5wTmVnID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYVN1ZmZpeCA6IHNldHRpbmdzLmFTaWduICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR3JvdXAoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gYXV0b1N0cmlwKGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhpbnB1dFZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJy0nICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBjb250YWlucyhpbnB1dFZhbHVlLCAnLScpO1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKGVtcHR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuZEdyb3VwID0gc2V0dGluZ3MuZEdyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXA7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MuZEdyb3VwKSB7XG4gICAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMnMnOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHszfT8pKykkLztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwbGl0cyB0aGUgc3RyaW5nIGF0IHRoZSBkZWNpbWFsIHN0cmluZ1xuICAgICAgICBsZXQgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYVNlcCAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIFJlLWluc2VydHMgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHdoaWxlIChkaWdpdGFsR3JvdXAudGVzdChpbnRlZ2VyUGFydCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0LnJlcGxhY2UoZGlnaXRhbEdyb3VwLCBgJDEke3NldHRpbmdzLmFTZXB9JDJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MubURlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIGl0J3MgYW4gaW50ZWdlclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5wTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmFOZWcgKyBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hTmVnICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnBOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmFOZWcgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gbmVnYXRpdmVCcmFja2V0KGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5hU3VmZml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3VuZGVkSW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSByRGVjXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHJEZWMpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHJEZWMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBwYWRkaW5nIC0gcmVtb3ZlcyB0cmFpbGluZyB6ZXJvcyB1bnRpbCB0aGUgZmlyc3Qgc2lnbmlmaWNhbnQgZGlnaXQgaXMgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgcGFkZGluZyB3aGVuIG1EZWMgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBtRGVjIGxlbmd0aCB3aGVuIGFQYWQgaXMgc2V0IHRvIHRydWVcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcLlxcXFxkeyR7ckRlY319KD86XFxcXGQqWzEtOV0pPykwKmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXG4gICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgIGlmIChyRGVjID09PSAwKSB7XG4gICAgICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91bmRlZElucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm91bmQgbnVtYmVyIGFmdGVyIHNldHRpbmcgYnkgcGFzdGluZyBvciAkKCkuYXV0b051bWVyaWNTZXQoKVxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gZm9yIHJvdW5kIHRoZSBudW1iZXJcbiAgICAgKiBwbGVhc2Ugbm90ZSB0aGlzIGhhbmRsZWQgYXMgdGV4dCAtIEphdmFTY3JpcHQgbWF0aCBmdW5jdGlvbiBjYW4gcmV0dXJuIGluYWNjdXJhdGUgdmFsdWVzXG4gICAgICogYWxzbyB0aGlzIG9mZmVycyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzIHRoYXQgYXJlIG5vdCBlYXNpbHkgYWNjb21wbGlzaGVkIGluIEphdmFTY3JpcHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1JvdW5kKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7IC8vIHZhbHVlIHRvIHN0cmluZ1xuICAgICAgICBpbnB1dFZhbHVlID0gKGlucHV0VmFsdWUgPT09ICcnKSA/ICcwJyA6IGlucHV0VmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLm1Sb3VuZCA9PT0gJ04wNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnQ0hGJyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdVMDUnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0QwNScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubVJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLnJvdW5kKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmNlaWwoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmZsb29yKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMoaW5wdXRWYWx1ZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZS5sZW5ndGggLSBpbnB1dFZhbHVlLmluZGV4T2YoJy4nKSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgbGV0IHJEZWM7XG5cbiAgICAgICAgLy8gc2V0cyB0aGUgdHJ1bmNhdGUgemVybyBtZXRob2RcbiAgICAgICAgaWYgKHNldHRpbmdzLmFQYWQpIHtcbiAgICAgICAgICAgIHJEZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgckRlYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGlucHV0VmFsdWUgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGlmIChpbnB1dFZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICctJztcblxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB0aGF0IHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgdG8gYmUgYSBkb3QpXG4gICAgICAgIGlmICghaW5wdXRWYWx1ZS5tYXRjaCgvXlxcZC8pKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJzAnICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGlucHV0VmFsdWUpID09PSAwKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXG4gICAgICAgIGlmICgoTnVtYmVyKGlucHV0VmFsdWUpID4gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB8fCAoaW5wdXRWYWx1ZS5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRQb3MgPSBpbnB1dFZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFsdWVIYXNBRG90ID0gZFBvcyA9PT0gLTE7XG5cbiAgICAgICAgLy8gVmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gaW5wdXRWYWx1ZUhhc0FEb3QgPyBpbnB1dFZhbHVlLmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIENoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpbnB1dFZhbHVlLmxlbmd0aCAtIDEpIC0gdmRQb3M7XG5cbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MubURlYykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgemVyb3MgPSAnMDAwMDAwJztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHJEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgckRlYyAtIGNEZWMpO1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHJEZWMpIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPT09IDAgJiYgckRlYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBsZXQgckxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MubURlYyAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MubURlYyArIGRQb3M7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0Um91bmQgPSBOdW1iZXIoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCArIDEpKTtcbiAgICAgICAgY29uc3Qgb2RkID0gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggLSAxKSAlIDIpIDogKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGgpICUgMik7XG4gICAgICAgIGxldCBpdkFycmF5ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcblxuICAgICAgICBpZiAoKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnUycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ2EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnYScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0InICYmIG9kZCA9PT0gMSkgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdDJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCB0byBjZWlsaW5nIHRvd2FyZCBwb3NpdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnRicgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgdG8gZmxvb3IgdG93YXJkIG5lZ2F0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdVJykpIHsgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCBhd2F5IGZyb20gemVyb1xuICAgICAgICAgICAgLy8gUm91bmQgdXAgdGhlIGxhc3QgZGlnaXQgaWYgcmVxdWlyZWQsIGFuZCBjb250aW51ZSB1bnRpbCBubyBtb3JlIDkncyBhcmUgZm91bmRcbiAgICAgICAgICAgIGZvciAoaSA9IChpdkFycmF5Lmxlbmd0aCAtIDEpOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICtpdkFycmF5W2ldICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xuICAgICAgICBpdkFycmF5ID0gaXZBcnJheS5zbGljZSgwLCByTGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgckRlYyk7XG5cbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XG4gICAgICAgIGNvbnN0IGFEZWMgPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICBjb25zdCBtRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcblxuICAgICAgICBpZiAoYURlYyAmJiBtRGVjKSB7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoYURlYyk7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIGRlY2ltYWwgcGFydCB0byBzYXRpc2Z5aW5nIGxlbmd0aCBzaW5jZSB3ZSB3b3VsZCByb3VuZCBpdCBhbnl3YXlcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBtRGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1EZWMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgbURlYyk7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBgJHtpbnRlZ2VyUGFydH0ke2FEZWN9JHttb2RpZmllZERlY2ltYWxQYXJ0fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHBhcnNlIHZNaW4sIHZNYXggJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiB2TWluOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU3RyKG4pIHtcbiAgICAgICAgY29uc3QgeCA9IHt9O1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBuTDtcbiAgICAgICAgbGV0IGo7XG5cbiAgICAgICAgLy8gTWludXMgemVybz9cbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgICAgICBuID0gJy0wJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLiAxIHBvc2l0aXZlLCAtMSBuZWdhdGl2ZVxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XG4gICAgICAgICAgICB4LnMgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChlID4gLTEpIHtcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgLy8gSW50ZWdlclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcbiAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmMgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5MIC09IDE7XG5cbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcbiAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzXG4gICAgICogVGhpcyB1c2VzIHRoZSBwYXJzZWQgc3RyaW5ncyBmb3IgdGhlIGFib3ZlIHBhcnNlU3RyIGZ1bmN0aW9uXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAgICAgKiBNYW55IHRoYW5rcyB0byBNaWtlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVzdE1pbk1heCh5LCB4KSB7XG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xuICAgICAgICBjb25zdCB5YyA9IHkuYztcbiAgICAgICAgbGV0IGkgPSB4LnM7XG4gICAgICAgIGxldCBqID0geS5zO1xuICAgICAgICBsZXQgayA9IHguZTtcbiAgICAgICAgbGV0IGwgPSB5LmU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCF4Y1swXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhOZWcgPSBpIDwgMDtcblxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xuICAgICAgICBpZiAoayAhPT0gbCkge1xuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBrID0geGMubGVuZ3RoO1xuICAgICAgICBsID0geWMubGVuZ3RoO1xuICAgICAgICBqID0gKGsgPCBsKSA/IGsgOiBsO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcbiAgICAgICAgZm9yIChpICs9IDE7IGkgPCBqOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChrID09PSBsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgbnVtYmVyIHNhdGlzZnkgdGhlIGZvcm1hdCBjb25kaXRpb25zXG4gICAgICogYW5kIGxheXMgYmV0d2VlbiBzZXR0aW5ncy52TWluIGFuZCBzZXR0aW5ncy52TWF4XG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0NoZWNrKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNaW4pO1xuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNYXgpO1xuICAgICAgICBjb25zdCB2YWxQYXJzZSA9IHBhcnNlU3RyKHMpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mub0xpbWl0cykge1xuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhhbmtzIHRvIEFudGhvbnkgJiBFdmFuIENcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR2V0KG9iaikge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIChhbmQgdGhlcmVmb3JlIGlzIGEgQ1NTIHNlbGVjdG9yKSwgdGhlbiB3ZSBuZWVkIHRvIG1vZGlmeSB0aGlzIHN0cmluZyBpbiBvcmRlclxuICAgICAgICAgKiBmb3IgalF1ZXJ5IHRvIGJlIGFibGUgdG8gcGFyc2UgdGhlIHNlbGVjdG9yIGNvcnJlY3RseS5cbiAgICAgICAgICogY2YuIGh0dHA6Ly9sZWFybi5qcXVlcnkuY29tL3VzaW5nLWpxdWVyeS1jb3JlL2ZhcS9ob3ctZG8taS1zZWxlY3QtYW4tZWxlbWVudC1ieS1hbi1pZC10aGF0LWhhcy1jaGFyYWN0ZXJzLXVzZWQtaW4tY3NzLW5vdGF0aW9uL1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzU3RyaW5nKG9iaikpIHtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGJsb2NrIGlzIGFwcGFyZW50bHkgbmV2ZXIgZW50ZXJlZC4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBhZnRlciBtYWtpbmcgc3VyZSB0aGF0J3MgMTAwJSB0aGUgY2FzZVxuICAgICAgICAgICAgb2JqID0gYCMke29iai5yZXBsYWNlKC8oOnxcXC58XFxbfF18LHw9KS9nLCAnXFxcXCQxJyl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkKG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhdHRhY2ggdGhlIGF1dG9OdW1lcmljIGZpZWxkIHByb3BlcnRpZXMgdG8gdGhlIERPTSBlbGVtZW50IHZpYSBhbiBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoYXRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xuICAgICAgICBpZiAodXBkYXRlIHx8IChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGF0LmdldCgwKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxuICAgICAqIFRob3NlIG9yaWdpbmFsIHNldHRpbmdzIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IGluIHRoZSBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5vRGVjICAgICA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYVBhZDtcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uQnJhY2tldDtcbiAgICAgICAgc2V0dGluZ3Mub1NlcCAgICAgPSBzZXR0aW5ncy5hU2VwO1xuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmFTaWduO1xuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkIC0gdGFrZW4gZnJvbSBtb2Rlcm5penJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU2F2ZShlbGVtZW50LCBzZXR0aW5ncywgdG9Ebykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZE5hbWUgPSAoZWxlbWVudC5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoZWxlbWVudC5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQubmFtZSl9YCA6YEFVVE9fJHtlbGVtZW50LmlkfWA7XG4gICAgICAgICAgICBsZXQgZGF0ZTtcbiAgICAgICAgICAgIGxldCBleHBpcmVzO1xuXG4gICAgICAgICAgICAvLyBzZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XG4gICAgICAgICAgICBpZiAoc3RvcmFnZVRlc3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXNzIEF1dG9OdW1lcmljSG9sZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF91cGRhdGVGaWVsZFByb3BlcnRpZXMoZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3RybEtleSA9IGUuY3RybEtleTtcbiAgICAgICAgICAgIHRoaXMuY21kS2V5ID0gZS5tZXRhS2V5O1xuICAgICAgICAgICAgdGhpcy5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG5cbiAgICAgICAgICAgIC8vIGtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQpO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMua2RDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aGljaCA9IGUud2hpY2g7XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3NldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRCZWZvcmVBZnRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIC8vRklYTUUgYHRoaXMuc2VsZWN0aW9uYCBjYW4gc29tZXRpbWVzIGJlIHVuZGVmaW5lZCwgZm91bmQgd2h5IGFuZCBmaXggaXRcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5zZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRCZWZvcmVBZnRlclN0cmlwcGVkKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSAocmlnaHQgPT09ICctJykgPyAnJyA6IHJpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIF9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgc2V0dGluZ3NDbG9uZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhRGVjLFxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnJyB8fCBsZWZ0ID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIHNldHRpbmdzQ2xvbmUubFplcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5hRGVjfWApKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIGFkdmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBhZHZlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IChjb250YWlucyh0aGlzLm5ld1ZhbHVlLCAnLCcpKSA/IHRoaXMubmV3VmFsdWUucmVwbGFjZSgnLCcsICcuJykgOiB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPT09ICcnIHx8IHRlc3RWYWx1ZSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdoZW4gdGhlIHVzZXIgZW50ZXIgYSAnMCcgb24gdGhlIGZhciBsZWZ0IHdpdGggYSBsZWFkaW5nIHplcm8gb3B0aW9uIHNldCB0byAnZGVueScsIHRoYXQgdGhlIGNhcmV0IGRvZXMgbm90IG1vdmVzIHNpbmNlIHRoZSBpbnB1dCBpcyBkcm9wcGVkIChmaXggaXNzdWUgIzI4MylcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDEgJiYgcGFydHNbMF0gPT09ICcwJyAmJiBzZXR0aW5nc0Nsb25lLmxaZXJvID09PSAnZGVueScpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgX2V4cGFuZFNlbGVjdGlvbk9uU2lnblxuICAgICAgICAgKiByZXR1cm5zIHNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIF9zaWduUG9zaXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgYVNpZ24gPSBzZXR0aW5nc0Nsb25lLmFTaWduO1xuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcblxuICAgICAgICAgICAgaWYgKGFTaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmRzIHNlbGVjdGlvbiB0byBjb3ZlciB3aG9sZSBzaWduXG4gICAgICAgICAqIFByZXZlbnRzIHBhcnRpYWwgZGVsZXRpb24vY29weWluZy9vdmVyd3JpdGluZyBvZiBhIHNpZ25cbiAgICAgICAgICovXG4gICAgICAgIF9leHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5fc2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgX2NoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIGZpcnN0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGVmdFBhcnQgPSBsZWZ0LnN1YnN0cigwLCBvbGRQYXJ0c1swXS5sZW5ndGgpICsgYXV0b1N0cmlwKGxlZnQuc3Vic3RyKG9sZFBhcnRzWzBdLmxlbmd0aCksIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIElmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIF9za2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2ggPSB0aGlzLndoaWNoO1xuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xuXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcbiAgICAgICAgICAgIGlmICgoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKHNoaWZ0S2V5ICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2tpcCBGeCBrZXlzLCB3aW5kb3dzIGtleXMsIG90aGVyIHNwZWNpYWwga2V5c1xuICAgICAgICAgICAgaWYgKChrZENvZGUgPj0ga2V5Q29kZS5GMSAmJiBrZENvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLldpbmRvd3MgJiYga2RDb2RlIDw9IGtleUNvZGUuUmlnaHRDbGljaykgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuVGFiICYmIGtkQ29kZSA8IGtleUNvZGUuU3BhY2UpIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXG4gICAgICAgICAgICAgICAgKHdoaWNoID09PSAwIHx8IHdoaWNoID09PSBrZENvZGUpKSB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5OdW1Mb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLlNjcm9sbExvY2sgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0IHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGFsbCAoYSlcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBpcyB1c2VkIGhlcmUgdG8gcHJldmVudCB0aGUgYnJvd3NlciB0byBmaXJzdCBzZWxlY3QgYWxsIHRoZSBpbnB1dCB0ZXh0IChpbmNsdWRpbmcgdGhlIGN1cnJlbmN5IHNpZ24pLCBvdGhlcndpc2Ugd2Ugd291bGQgc2VlIHRoYXQgd2hvbGUgc2VsZWN0aW9uIGZpcnN0IGluIGEgZmxhc2gsIHRoZW4gdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIG51bWJlciBwYXJ0IHdpdGhvdXQgdGhlIGN1cnJlbmN5IHNpZ24uXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IHRoaXMuc2V0dGluZ3MuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWNvbnRhaW5zKHRoaXMudGhhdC52YWx1ZSwgJy0nKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU3VmZml4TGVuID0gdGhpcy5zZXR0aW5ncy5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcFNpZ24gPSB0aGlzLnNldHRpbmdzLnBTaWduO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwTmVnID0gdGhpcy5zZXR0aW5ncy5wTmVnO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHBOZWcgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgYVNpZ25MZW4gPiAwKT9hU2lnbkxlbiArIDE6YVNpZ25MZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBhU3VmZml4TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTdWZmaXhMZW4gKyBhU2lnbkxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoYVNpZ25MZW4gPiAwKT92YWx1ZUxlbiAtIChhU2lnbkxlbiArIG5lZ0xlbiArIGFTdWZmaXhMZW4pOnZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChhU2lnbkxlbiArIGFTdWZmaXhMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgKGtkQ29kZSA9PT0ga2V5Q29kZS5jIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5cHJlc3MnIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5jO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3RybEtleSB8fCBjbWRLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8ganVtcCBvdmVyIHRob3VzYW5kIHNlcGFyYXRvclxuICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgfHwga2RDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhU2VwID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTZXA7XG4gICAgICAgICAgICAgICAgY29uc3QgYURlYyA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hRGVjO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IHRoaXMuc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyAmJiAhdGhpcy5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYURlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHN0YXJ0SnVtcCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24oc3RhcnRKdW1wICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZENvZGUgPj0ga2V5Q29kZS5QYWdlRG93biAmJiBrZENvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTdWZmaXgpICYmIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVNpZ24pICsgc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsICctJykgJiYgdGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgLSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVNpZ24pICYmIHNldHRpbmdzQ2xvbmUuYVNpZ24gIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyB0aGUgZGVsZXRpb24gb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgICAgIGxldCByaWdodDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0QmVmb3JlQWZ0ZXJTdHJpcHBlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiByaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiAoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHRoaXMudmFsdWUsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX3Byb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBkZWNpZGVzIGlmIHRoZSBrZXkgcHJlc3NlZCBzaG91bGQgYmUgZHJvcHBlZCBvciBhY2NlcHRlZCwgYW5kIG1vZGlmeSB0aGUgdmFsdWUgJ29uLXRoZS1mbHknIGFjY29yZGluZ2x5LlxuICAgICAgICAgKiBSZXR1cm5zIFRSVUUgaWYgYSBwcm9jZXNzaW5nIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IC8vRklYTUUgVGhpcyBhbHdheXMgcmV0dXJucyBUUlVFXG4gICAgICAgICAqL1xuICAgICAgICBfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBjQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy53aGljaCk7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fFxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmFsdERlYyAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hbHREZWMpIHx8XG4gICAgICAgICAgICAgICAgKChjQ29kZSA9PT0gJy4nIHx8IGNDb2RlID09PSAnLCcpICYmIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRvdE51bXBhZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUubURlYyB8fCAhc2V0dGluZ3NDbG9uZS5hRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgYU5lZyBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hTmVnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBvdGhlciBkZWNpbWFsIGNoYXJhY3RlciBwcmVzZW50XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuYURlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmFEZWMsIHJpZ2h0LCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG1pbnVzIGlmIG5vdCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoKGNDb2RlID09PSAnLScgfHwgY0NvZGUgPT09ICcrJykgJiYgc2V0dGluZ3NDbG9uZS5hTmVnID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FyZXQgaXMgYWx3YXlzIGFmdGVyIG1pbnVzXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHx8IChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnICE9PSAncCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09ICctJyB8fCBjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdHJ5IHRvIGluc2VydCBkaWdpdCBiZWZvcmUgbWludXNcbiAgICAgICAgICAgIGlmIChjQ29kZSA+PSAnMCcgJiYgY0NvZGUgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnZNYXggPD0gMCAmJiBzZXR0aW5nc0Nsb25lLnZNaW4gPCBzZXR0aW5nc0Nsb25lLnZNYXggJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZVBhcnRzKGxlZnQgKyBjQ29kZSwgcmlnaHQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBfZm9ybWF0UXVpY2soZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZXZlbnRLZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuX2dldEJlZm9yZUFmdGVyU3RyaXBwZWQoKTtcblxuICAgICAgICAgICAgLy8gTm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuYVNlcCAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTZXAgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2VwKSkpICYmXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuYVNpZ24gPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2lnbikpKSkge1xuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmFEZWMpO1xuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhzdWJQYXJ0cywgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF1dG9Hcm91cCh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKGV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnblBhcnRzID0gc2V0dGluZ3NDbG9uZS5hU2lnbi5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2lnblBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCdcXFxcJyArIG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUganVzdCBiZWZvcmUgdGhlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0VHlwZVwiIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2V0QXJyYXlCZWhhdmlvciAtIElmIHNldCB0byBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gYmVoYXZlIGxpa2UgYGdldEFycmF5KClgLCBvdGhlcndpc2UgaWYgc2V0IHRvIEZBTFNFLCBpdCBiZWhhdmUgbGlrZSBgZ2V0U3RyaW5nKClgXG4gICAgICogQHBhcmFtIHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoYXQpO1xuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRTdHJpbmcoKSBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybVBhcnRzLCBpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRJbnB1dFZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IGAke2lucHV0TmFtZX09JHttb2RpZmllZElucHV0VmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybVBhcnRzLmpvaW4oJyYnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c2luJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiBzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKG5lZ2F0aXZlQnJhY2tldChlLnRhcmdldC52YWx1ZSwgc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IHNldHRpbmdzLmVEZWM7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MublNlcCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFTZXAgPSAnJztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFTdWZmaXggPSAnJztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gYXV0b1N0cmlwKGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncykpICE9PSBzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBzZW5kIGEgJ25hdGl2ZScgY2hhbmdlIGV2ZW50IHdoZW4gYmx1cnJpbmcgdGhlIGlucHV0LCB3ZSBuZWVkIHRvIGZpcnN0IHN0b3JlIHRoZSBpbml0aWFsIGlucHV0IHZhbHVlIG9uIGZvY3VzLlxuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIudmFsdWVPbkZvY3VzO1xuICAgICAgICAgICAgY29uc3Qgb25FbXB0eSA9IGNoZWNrRW1wdHkoaG9sZGVyLnZhbHVlT25Gb2N1cywgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiBzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5ZG93bicgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3Qgc3RhcnRlZCBwdXNoaW5nIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogTm90ZSA6XG4gICAgICogQnkgZGVmYXVsdCBhICdub3JtYWwnIGlucHV0IG91dHB1dCB0aG9zZSBldmVudHMgaW4gdGhlIHJpZ2h0IG9yZGVyIHdoZW4gaW5wdXR0aW5nIGEgY2hhcmFjdGVyIGtleSAoaWUuICdhJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogLi4ud2hlbiBpbnB1dHRpbmcgYSBtb2RpZmllciBrZXkgKGllLiAnY3RybCcpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZGVsZXRlJyBvciAnYmFja3NwYWNlJyBpcyBlbnRlcmVkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gY2hhbmdlXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogV2hlbiBhIHBhc3RlIGlzIGRvbmUsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGlucHV0IChpZiBwYXN0ZSBpcyBkb25lIHdpdGggdGhlIG1vdXNlKVxuICAgICAqXG4gICAgICogLSBrZXlkb3duIChpZiBwYXN0ZSBpcyBkb25lIHdpdGggY3RybCt2KVxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bihob2xkZXIsIGUpIHtcbiAgICAgICAgLy9UT0RPIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0cmlldmUgdGhlIGVsZW1lbnQgdmFsdWUgKGVpdGhlciBieSB1c2luZyBgZS50YXJnZXQudmFsdWVgIHdoZW4gdGhlIGVsZW1lbnQgaXMgYW4gPGlucHV0Piwgb3IgYnkgdXNpbmcgYGVsZW1lbnQudGV4dENvbnRlbnRgIHdoZW4gdGhlIGVsZW1lbnQgYXMgaXRzIGBjb250ZW50ZWRpdGFibGVgIHNldCB0byB0cnVlKVxuICAgICAgICBjb25zdCBjdXJyZW50S2V5Q29kZSA9IGtleShlKTsgLy8gVGhlIGtleSBiZWluZyB1c2VkXG5cbiAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIFwiZW50ZXJcIiBrZXkgdGhyb3dzIGEgYGNoYW5nZWAgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBgZm9jdXNgIGV2ZW50XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLnZhbHVlT25Gb2N1cyAhPT0gZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9sZGVyLl91cGRhdGVGaWVsZFByb3BlcnRpZXMoZSk7IC8vRklYTUUgVGhpcyBpcyBjYWxsZWQgMiB0byAzIHRpbWVzXG4gICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChob2xkZXIuX3NraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUga2V5IGlzIGEgZGVsZXRlL2JhY2tzcGFjZSBrZXlcbiAgICAgICAgaWYgKGN1cnJlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBjdXJyZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcbiAgICAgICAgICAgIGhvbGRlci5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFF1aWNrKGUpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmQgb25seSBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGhhcyBjaGFuZ2VkIGFmdGVyIHRoYXQgYmFja3NwYWNlL2RlbGV0ZSwgdGhlbiB3ZSBoYXZlIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCBsaWtlIGJyb3dzZXJzIG5vcm1hbGx5IGRvLlxuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7IC8vVE9ETyBJcyB0aGlzIGxpbmUgbmVlZGVkP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXByZXNzKGhvbGRlciwgZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50S2V5Q29kZSA9IGtleShlKTsgLy8gVGhlIGtleSBiZWluZyB1c2VkXG5cbiAgICAgICAgLy8gRmlyZWZveCBmaXggZm9yIFNoaWZ0ICYmIGluc2VydCBwYXN0ZSBldmVudFxuICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBjdXJyZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XG4gICAgICAgIGhvbGRlci5fdXBkYXRlRmllbGRQcm9wZXJ0aWVzKGUpOyAvL0ZJWE1FIFRoaXMgaXMgY2FsbGVkIDIgdG8gMyB0aW1lc1xuICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vRklYTUUgYF9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uKClgIGFsd2F5cyByZXR1cm5zIFRSVUUsIHdoaWNoIG1lYW5zIGBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7YCBhdCB0aGUgZW5kIGlzIE5FVkVSIGNhbGxlZC5cbiAgICAgICAgaWYgKGhvbGRlci5fcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbigpKSB7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGFkZCBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIHdlIGRvIG5vdCBhbGxvdyB0aGUgaW5wdXQgZXZlbnQgdG8gYmUgc2VudFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXVwJyBldmVudHMuXG4gICAgICogVGhlIHVzZXIganVzdCByZWxlYXNlZCBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEtleUNvZGUgPSBrZXkoZSk7IC8vIFRoZSBrZXkgYmVpbmcgdXNlZFxuXG4gICAgICAgIGhvbGRlci5fdXBkYXRlRmllbGRQcm9wZXJ0aWVzKGUpOyAvL0ZJWE1FIFRoaXMgaXMgY2FsbGVkIDIgdG8gMyB0aW1lc1xuICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLl9za2lwQWx3YXlzKGUpO1xuICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgaWYgKHNraXAgfHwgZS50YXJnZXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbikge1xuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRLZXlDb2RlID09PSBrZXlDb2RlLlRhYikge1xuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHx8XG4gICAgICAgICAgICAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJykpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxuICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xuICAgICAgICAgICAgYXV0b1NhdmUoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0UXVpY2soZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgaWYgKCEkdGhpcy5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgYXV0b1NhdmUoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYVNlcCA9IHNldHRpbmdzLm9TZXA7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYVNpZ24gPSBzZXR0aW5ncy5vU2lnbjtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hU3VmZml4ID0gc2V0dGluZ3Mub1N1ZmZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hUGFkID0gc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5uQnJhY2tldCA9IHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKSA9PT0gbnVsbCAmJiBtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/ICtzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZXNlbnROdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQoJzAnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25QYXN0ZSgkdGhpcywgaG9sZGVyLCBlKSB7XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWRcbiAgICAgICAgLy8gVGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBkZWZhdWx0LCBzaW5jZSBvdGhlcndpc2UgdGhlIHVzZXIgd291bGQgYmUgYWJsZSB0byBwYXN0ZSBpbnZhbGlkIGNoYXJhY3RlcnMgaW50byB0aGUgaW5wdXRcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBlLnRhcmdldC52YWx1ZSB8fCAnJztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBjdXJyZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyksIGhvbGRlcik7XG5cbiAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQocGFzdGVkVGV4dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJlcGFyZVBhc3RlZFRleHQocHJlZml4ICsgTnVtYmVyKHBhc3RlZFRleHQpLnZhbHVlT2YoKSArIHN1ZmZpeCwgaG9sZGVyKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQobmV3VmFsdWUpICYmIE51bWJlcihvbGRSYXdWYWx1ZSkudmFsdWVPZigpICE9PSBOdW1iZXIobmV3VmFsdWUpLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gT24gYSAnbm9ybWFsJyBub24tYXV0b051bWVyaWMgaW5wdXQsIGFuIGBpbnB1dGAgZXZlbnQgaXMgc2VudCB3aGVuIGEgcGFzdGUgaXMgZG9uZS4gV2UgbWltaWMgdGhhdC5cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8vRklYTUUgQWZ0ZXIgYSBwYXN0ZSwgdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgZmFyIHJpZ2h0IG9mIHRoZSBpbnB1dCwgaXQgc2hvdWxkIGJlIHNldCB0byBzb21ldGhpbmcgbGlrZSBgbmV3Q2FyZXRQb3NpdGlvbiA9IG9sZENhcmV0UG9zaXRpb24gKyBwYXN0ZVRleHQubGVuZ3RoO2AsIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMsIHRoZSBkZWNpbWFsIGNoYXJhY3RlciwgdGhlIG5lZ2F0aXZlIHNpZ24vYnJhY2tldHMsIGFuZCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBmb2N1c2luZyBvdXQgb2YgdGhlIGlucHV0LCB3ZSBjaGVjayBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsIHRoZW4gd2Ugc2VuZCBhIGBjaGFuZ2VgIGV2ZW50IChzaW5jZSB0aGUgbmF0aXZlIG9uZSB3b3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGBlLnByZXZlbnREZWZhdWx0KClgIGNhbGxlZCBpbiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkJsdXIoaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLnZhbHVlT25Gb2N1cykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIHNlbmQgYSBzZWNvbmQgY2hhbmdlIGV2ZW50ICh0aGF0IHNvbWVob3cgZ2V0cyBwaWNrZWQgdXAgYnkgalF1ZXJ5LCBidXQgbm90IGJ5IGBhZGRFdmVudExpc3RlbmVyKClgIC8vRklYTUUgS05PV04gQlVHIDogVGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBzZWNvbmQgY2hhbmdlIGV2ZW50IHRvIGJlIHBpY2tlZCB1cCBieSBqUXVlcnlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdzdWJtaXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25TdWJtaXQoJHRoaXMsIGhvbGRlcikge1xuICAgICAgICAkdGhpcy5jbG9zZXN0KCdmb3JtJykub24oJ3N1Ym1pdC5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5TZXRPblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgalF1ZXJ5IHNlbGVjdGVkIGlucHV0IGlmIHRoZSB0YWcgYW5kIHR5cGUgYXJlIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcbiAgICAgICAgLy8gU3VwcG9ydGVkIGlucHV0IHR5cGVcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xuICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudFRhZyA9ICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRUYWcgIT09ICdpbnB1dCcgJiYgIWlzSW5BcnJheShjdXJyZW50RWxlbWVudFRhZywgYWxsb3dlZFRhZ0xpc3QpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRpbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3V0aW5lIHRvIGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSAkaW5wdXRcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKSB7XG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5hRm9ybWApKS5cbiAgICAgICAgICAgICAqIE5vdGU7IHRoaXMgaXMgdHJ1ZSB3aGF0ZXZlciB0aGUgZGV2ZWxvcGVyIGhhcyBzZXQgZm9yIGBkYXRhLWFuLWRlZmF1bHRgIGluIHRoZSBodG1sIChhc3AubmV0IHVzZXJzKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxuICAgICAgICAgICAgICogQnV0IGlmIGBpbnB1dC52YWx1ZWAgaXMgc2V0IHRvIGEgbnVtYmVyLCBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsIHRoZW4gaXQgbWVhbnMgdGhlIGRldiBoYXNcbiAgICAgICAgICAgICAqIGNoYW5nZWQgdGhlIGlucHV0IHZhbHVlLCBhbmQgdGhlbiBpdCBtZWFucyB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSBoaXMgb3duIGRlY2lzaW9uIHRvIGRvIHNvLlxuICAgICAgICAgICAgICogSGVuY2UsIGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgaWdub3JlIGBhbkRlZmF1bHRgIGFsdG9nZXRoZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRm9ybSAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBgdmFsdWVgIGlzIHZhbGlkIG9yIG5vdFxuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RlZEN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQoY3VycmVudFZhbHVlLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih0ZXN0ZWRDdXJyZW50VmFsdWUpICYmIEluZmluaXR5ICE9PSB0ZXN0ZWRDdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHRlc3RlZEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBpbmZvcm0gdGhlIGRldmVsb3BlciB0aGF0IG5vdGhpbmcgdXNhYmxlIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XG4gICAgICAgICAgICAgICAgICogLSBwYWdlIHJlbG9hZCBmcm9tIGJhY2sgYnV0dG9uLCBhbmRcbiAgICAgICAgICAgICAgICAgKiAtIEFTUC5uZXQgZm9ybSBwb3N0IGJhY2tcbiAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXG4gICAgICAgICAgICAgICAgICogICAgICBleGFtcGxlOiA8YXNwOlRleHRCb3ggcnVuYXQ9XCJzZXJ2ZXJcIiBpZD1cInNvbWVJRFwiIHRleHQ9XCIxMjM0LjU2XCIgZGF0YS1hbi1kZWZhdWx0PVwiMTIzNC41NlwiPlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCcsIGJhc2VkIG9uIHRoZSBsb2NhbGUgdXNlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsICYmIHNldHRpbmdzLmFuRGVmYXVsdC50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBjdXJyZW50VmFsdWUgIT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hU3RvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3MuYVN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVEZWMgdmFsdWUgc2hvdWxkIE5PVCBiZSBzYXZlZCBpbiBzZXNzaW9uU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKT8nLScgKyBhdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpOmF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLndFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoc2V0dGluZ3MuYVNpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09ICR0aGlzLnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5oYW5jZSB0aGUgdXNlciBleHBlcmllbmNlIGJ5IG1vZGlmeWluZyB0aGUgZGVmYXVsdCBgcE5lZ2Agb3B0aW9uIGRlcGVuZGluZyBvbiBgYVNpZ25gIGFuZCBgcFNpZ25gLlxuICAgICAqXG4gICAgICogSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiAoYHBOZWdgKSwgYnV0IGhhcyBzZXQgYSBjdXJyZW5jeSBzeW1ib2wgKGBhU2lnbmApLFxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBwTmVnYCBpbiBvcmRlciB0byBrZWVwIHRoZSByZXN1bHRpbmcgb3V0cHV0IGxvZ2ljYWwgYnkgZGVmYXVsdCA6XG4gICAgICogLSBcIiQtMSwyMzQuNTZcIiBpbnN0ZWFkIG9mIFwiLSQxLDIzNC41NlwiICh7YVNpZ246IFwiJFwiLCBwTmVnOiBcInJcIn0pXG4gICAgICogLSBcIi0xLDIzNC41NiRcIiBpbnN0ZWFkIG9mIFwiMSwyMzQuNTYtJFwiICh7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCIsIHBOZWc6IFwicFwifSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ycmVjdFBOZWdPcHRpb24ob3B0aW9ucywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChvcHRpb25zKSAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkob3B0aW9ucy5wTmVnKSAmJiBvcHRpb25zLmFTaWduICE9PSAnJykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5wU2lnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5wTmVnID0gJ3AnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucE5lZyA9ICdyJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emUgYW5kIHNhdmUgdGhlIHZNaW4gYW5kIHZNYXggaW50ZWdlciBzaXplIGZvciBsYXRlciB1c2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7e3ZNYXg6IEFycmF5LCB2TWluOiBBcnJheX19XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IFt2TWF4SW50ZWdlclBhcnRdID0gc2V0dGluZ3Mudk1heC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBbdk1pbkludGVnZXJQYXJ0XSA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKT9bXTpzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgdk1heEludGVnZXJQYXJ0ID0gdk1heEludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHZNaW5JbnRlZ2VyUGFydCA9IHZNaW5JbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xuXG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heCh2TWF4SW50ZWdlclBhcnQubGVuZ3RoLCAxKTtcbiAgICAgICAgc2V0dGluZ3MubUludE5lZyA9IE1hdGgubWF4KHZNaW5JbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBgbURlY2AgYXMgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3JyZWN0TURlY09wdGlvbihzZXR0aW5ncykge1xuICAgICAgICBpZiAoIWlzTnVsbChzZXR0aW5ncy5zY2FsZURpdmlzb3IpICYmICFpc051bGwoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSkge1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHdpdGggdGhlIG9uZSBkZWZpbmVkIHdpdGggdGhlIG51bWJlciBvZiBkZWNpbWFscyB0byBzaG93IHdoZW4gbm90IGluIGZvY3VzLCBpZiBzZXRcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBzZXR0aW5ncy5zY2FsZURlY2ltYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsKHNldHRpbmdzLm1EZWMpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChzZXR0aW5ncy52TWluLCBzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBTdHJpbmcoc2V0dGluZ3MubURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3N0IGNhbGN1bHVzIGFzc3VtZSBgbURlY2AgaXMgYW4gaW50ZWdlciwgdGhlIGZvbGxvd2luZyBzdGF0ZW1lbnQgbWFrZXMgaXQgY2xlYXIgKG90aGVyd2lzZSBoYXZpbmcgaXQgYXMgYSBzdHJpbmcgbGVhZHMgdG8gcHJvYmxlbXMgaW4gcm91bmRpbmcgZm9yIGluc3RhbmNlKVxuICAgICAgICBzZXR0aW5ncy5tRGVjID0gTnVtYmVyKHNldHRpbmdzLm1EZWMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5hbHREZWMpICYmIE51bWJlcihzZXR0aW5ncy5tRGVjKSA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLicgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJywnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLCcgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVzIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIGF1dG9TdHJpcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLmFOZWc/YChbLVxcXFwke3NldHRpbmdzLmFOZWd9XT8pYDonKC0/KSc7XG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHsoc2V0dGluZ3MuYU5lZz9gXFxcXCR7c2V0dGluZ3MuYU5lZ31gOicnKX1cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXS4qPyhcXFxcZHxcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmFEZWN9PylbXlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdXFxcXEQqJGApO1xuXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5hRGVjfT8oXFxcXGQrXFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCspfChcXFxcZCooPzpcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKik/KSlgKTtcblxuICAgICAgICAvLyBVc2luZyB0aGlzIHJlZ2V4IHZlcnNpb24gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGR8JClgIGVudGlyZWx5IGNsZWFyIHRoZSBpbnB1dCBvbiBibHVyXG4gICAgICAgIHNldHRpbmdzLnN0cmlwUmVnID0gbmV3IFJlZ0V4cChgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZClgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZScgbGF0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlID09PSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIGFscmVhZHkgb2YgdHlwZSAnTnVtYmVyJywgc2hvdWxkbid0IHdlIGtlZXAgaXQgYXMgYSBudW1iZXIgZm9yIGZ1cnRoZXIgbWFuaXB1bGF0aW9uLCBpbnN0ZWFkIG9mIHVzaW5nIGEgc3RyaW5nP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYga2V5ICE9PSAnYVNjYWxlJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXG4gICAgICogTm90ZTogVGhpcyByZXR1cm5zIGBudWxsYCBpZiBzb21laG93IHRoZSBzZXR0aW5ncyByZXR1cm5lZCBieSBqUXVlcnkgaXMgbm90IGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGUgLSBJZiBUUlVFLCB0aGVuIHRoZSBzZXR0aW5ncyBhbHJlYWR5IGV4aXN0cyBhbmQgdGhpcyBmdW5jdGlvbiBvbmx5IHVwZGF0ZXMgdGhlbSBpbnN0ZWFkIG9mIHJlY3JlYXRpbmcgdGhlbSBmcm9tIHNjcmF0Y2hcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgXCJhdXRvTnVtZXJpY1wiIHNldHRpbmdzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgaXQgcmV0dXJucyBcInVuZGVmaW5lZFwiLlxuICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICBpZiAodXBkYXRlIHx8IGlzVW5kZWZpbmVkKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgSFRNTDUgZGF0YSwgaWYgaXQgZG9lc24ndCBleGlzdCwgd2UnbGwgZ2V0IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdEYXRhID0gJHRoaXMuZGF0YSgpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdGFnRGF0YSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBvbk9mZiAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRocm93SW5wdXQgICAgICA6IHRydWUsIC8vIFRocm93IGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHN0cmlwICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcbiAgICAgICAgICAgIHRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIEltcHJvdmUgdGhlIGBwTmVnYCBvcHRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb3JyZWN0UE5lZ09wdGlvbihvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgIHNldHRpbmdzLmFOZWcgPSBzZXR0aW5ncy52TWluIDwgMCA/ICctJyA6ICcnO1xuXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGNoYW5nZXMgdG8gdGhlIHNldHRpbmdzIG9iamVjdCAoZnJvbSB0aGUgb3JpZ2luYWwgYXV0b0NvZGUoKSBmdW5jdGlvbilcbiAgICAgICAgICAgIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29ycmVjdE1EZWNPcHRpb24oc2V0dGluZ3MpO1xuICAgICAgICAgICAgc2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlcihzZXR0aW5ncyk7XG4gICAgICAgICAgICBjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgdmFsaWRhdGUoc2V0dGluZ3MsIGZhbHNlKTsgLy8gVGhyb3dzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYywgc2NhbGVEaXZpc29yICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICAgICAgICBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIG5ldyBzZXR0aW5nc1xuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kcyBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNcbiAgICAgKi9cbiAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGluaXRpYXRlIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoKTsgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ydW5PbmNlICYmIHNldHRpbmdzLmFGb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJ1bk9uY2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBldmVudHMgbGlzdGVuZXJzIHRvIHN1cHBvcnRlZCBpbnB1dCB0eXBlcyAoXCJ0ZXh0XCIsIFwiaGlkZGVuXCIsIFwidGVsXCIgYW5kIG5vIHR5cGUpXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBlID0+IHsgb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBlID0+IHsgb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgZSA9PiB7IG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlID0+IHsgb25LZXlkb3duKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGUgPT4geyBvbktleXByZXNzKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGUgPT4geyBvbktleXVwKGhvbGRlciwgc2V0dGluZ3MsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGUgPT4geyBvbkJsdXIoaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgZSA9PiB7IG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQoJHRoaXMsIGhvbGRlcik7IC8vVE9ETyBTd2l0Y2ggdG8gYGFkZEV2ZW50TGlzdGVuZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byByZW1vdmUgc2V0dGluZ3MgYW5kIHN0b3AgYXV0b051bWVyaWMoKSAtIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJkZXN0cm95XCIpOyAvLyBkZXN0cm95cyBhdXRvTnVtZXJpY1xuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBhbmQgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcIndpcGVcIik7IC8vIHJlbW92ZXMgc2Vzc2lvbiBzdG9yYWdlIGFuZCBjb29raWVzIGZyb20gbWVtb3J5XG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdpcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgICAgICogSXQgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpZiBuZWVkZWQuXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gdXBkYXRlcyB0aGUgc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpcCA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzdHJpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBmb3JtYXQgdGhlIHZhbHVlIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAndmFsdWUnKTsgLy8gZm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcbiAgICAgICAgICogYW5kIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIChwZXJpb2QpIGNoYXJhY3RlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG51bGwgfHwgaXNVbmRlZmluZWQobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBiZWluZyBzZXQgaXMgbm90IG51bWVyaWNcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNOdW1lcmljKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5zY2FsZURpdmlzb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZXNlbnROdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2F0dGVtcHRlZFZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIHZNaW4gWyR7c2V0dGluZ3Mudk1pbn1dIGFuZCB2TWF4IFske3NldHRpbmdzLnZNYXh9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnRleHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gdW4tZm9ybWF0IGlucHV0cyAtIGhhbmR5IHRvIHVzZSByaWdodCBiZWZvcmUgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygndW5TZXQnKTsgLy8gbm8gcGFyYW1ldGVyIGFjY2VwdGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0VHlwZVwiIGZvciBtb3JlIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIHVuU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCR0aGlzLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byByZS1mb3JtYXQgaW5wdXRzIC0gaGFuZHkgdG8gdXNlIHJpZ2h0IGFmdGVyIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3JlU2V0Jyk7IC8vIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICogdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlICd1blNldCcgbWV0aG9kIHRvIHJlZm9ybWF0IHRoZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgcmVTZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAvL1RPRE8gV2h5IHdvdWxkIHdlIG5lZWQgdG8gZ2V0IGEgbmV3IHJlZmVyZW5jZSB0byAkdGhpcyBzaW5jZSBpdCBoYXMgYmVlbiBkb25lIGluIGBpbml0KClgP1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cbiAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS52YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudGV4dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgXCI8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+XCIgdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKC9cXGQvKS50ZXN0KHZhbHVlKSB8fCBOdW1iZXIodmFsdWUpID09PSAwKSAmJiBzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlIHx8IHNldHRpbmdzLmFGb3JtID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gZml4TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYSBudW1lcmljIHN0cmluZ1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgYnV0IGZvbGxvd2luZyB0aGUgYG91dHB1dFR5cGVgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICAgICAqIC0gYSBzdHJpbmcgKHRoYXQgY291bGQgb3IgY291bGQgbm90IHJlcHJlc2VudCBhIG51bWJlciAoaWUuIFwiMTIzNDUsNjctXCIpKSwgb3JcbiAgICAgICAgICogLSBhIHBsYWluIG51bWJlciAoaWYgdGhlIHNldHRpbmcgJ251bWJlcicgaXMgdXNlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhlIHJldHVybmVkIHZhbHVlcyBhcmUgYW4gSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXG4gICAgICAgICAqIENoZWNrIHRoZSBcIm91dHB1dFR5cGVcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldExvY2FsaXplZCgpIHtcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubFplcm8gIT09ICdrZWVwJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dFR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnMCcpIHx8ICEoJ3ZhbHVlJyBpbiB0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRUeXBlXCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dFR5cGVcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXV0b051bWVyaWMgZnVuY3Rpb24gYWNjZXB0cyBtZXRob2RzIG5hbWVzIChpbiBzdHJpbmcgZm9ybWF0KSBhbmQgdGhvc2UgbWV0aG9kIHBhcmFtZXRlcnMgaWYgbmVlZGVkLlxuICAgICAqIEl0IGluaXRpYWxpemUgYXV0b051bWVyaWMgb24gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICovXG4gICAgJC5mbi5hdXRvTnVtZXJpYyA9IGZ1bmN0aW9uKG1ldGhvZCwgLi4uYXJncykge1xuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvcHRpb25zIGhhdmUgYmVlbiBwYXNzZWQgZGlyZWN0bHksIHdpdGhvdXQgdXNpbmcgYSBuYW1lZCBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdENvbmZpZyA9ICgpID0+IGRlZmF1bHRTZXR0aW5ncztcblxuICAgICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMgPSBkZWZhdWx0U2V0dGluZ3M7IC8vIE1ha2UgdGhvc2Ugc2V0dGluZ3MgcHVibGljIHZpYSBqUXVlcnkgdG9vLlxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50IHRyaWdnZXJcbiAgICAgKi9cbiAgICBhdXRvRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxuICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgQSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gZm9ybWF0IGl0LCBbJHt2YWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhdGUgYSB2ZXJ5IGJhc2ljIHNldHRpbmdzIG9iamVjdFxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MubURlYykpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLnZNaW4sIHNldHRpbmdzLnZNYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFzaWMgdGVzdHMgdG8gY2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHZhbGlkXG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBkb2N1bWVudCwgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rLCBwcm9jZWVkIHRvIHJvdW5kaW5nLCBmb3JtYXR0aW5nIGFuZCBncm91cGluZ1xuICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IHByZXNlbnROdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b0Zvcm1hdCA9IGF1dG9Gb3JtYXQ7IC8vIFRoZSBqUXVlcnkgZXhwb3J0XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdW5mb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGF1dG9VbkZvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdpdmluZyBhbiB1bmZvcm1hdHRlZCB2YWx1ZSBzaG91bGQgcmV0dXJuIHRoZSBzYW1lIHVuZm9ybWF0dGVkIHZhbHVlLCB3aGF0ZXZlciB0aGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpKSB7IC8vVE9ETyBDb21wbGV0ZSB0aGUgdGVzdCB0byB0aHJvdyB3aGVuIGdpdmVuIGEgd3JvbmdseSBmb3JtYXR0ZWQgbnVtYmVyIChpZS4gJ2Zvb2JhcicpXG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBBIG51bWJlciBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBudW1iZXIgaXMgbmVlZGVkIHRvIGJlIGFibGUgdG8gdW5mb3JtYXQgaXQsIFske3ZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFOZWcgPSAnLSc7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubkJyYWNrZXQgJiYgc2V0dGluZ3MubkJyYWNrZXQuc3BsaXQoJywnKVswXSA9PT0gdmFsdWUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0VHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9VbmZvcm1hdCA9IGF1dG9VbkZvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiBvcHRpb24gb2JqZWN0LlxuICAgICAqIElmIHRoZSBvcHRpb25zIGFyZSB2YWxpZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIG5vdGhpbmcsIG90aGVyd2lzZSBpZiB0aGUgb3B0aW9ucyBhcmUgaW52YWxpZCwgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIHRlc3RzIGlmIHRoZSBvcHRpb25zIGFyZSBub3QgY29uZmxpY3RpbmcgYW5kIGFyZSB3ZWxsIGZvcm1hdHRlZC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxlbmllbnQgc2luY2UgaXQgb25seSB0ZXN0cyB0aGUgc2V0dGluZ3MgcHJvcGVydGllcyA7IGl0IGlnbm9yZXMgYW55IG90aGVyIHByb3BlcnRpZXMgdGhlIG9wdGlvbnMgb2JqZWN0IGNvdWxkIGhhdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHVzZXJPcHRpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyBJZiBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBleHRlbmRzIHRoZSBgdXNlck9wdGlvbnNgIHBhc3NlZCBieSB0aGUgdXNlciwgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSA9ICh1c2VyT3B0aW9ucywgc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSB0cnVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlYnVnID0gdHJ1ZTsgLy8gVGhlIGVycm9yIGhlcmUgbXVzdCBhbHdheXMgYmUgdGhyb3duLCBzaW5jZSBhIGJhZGx5IGNvbmZpZ3VyZWQgb3B0aW9ucyBvYmplY3Qgd2lsbCBsZWFkIHRvIHdyb25nIHJlc3VsdHMsIGlmIGFueS5cblxuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHVzZXJPcHRpb25zKSB8fCAhaXNPYmplY3QodXNlck9wdGlvbnMpIHx8IGlzRW1wdHlPYmoodXNlck9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdXNlck9wdGlvbnMgYXJlIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSB2YWxpZCBvYmplY3QsIFske3VzZXJPcHRpb25zfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUludGVnZXIgPSAvXlswLTldKyQvO1xuICAgICAgICBjb25zdCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyA9IC9bMC05XSsvO1xuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcbiAgICAgICAgY29uc3QgdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspPyQvO1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciA9IC9eWzAtOV0rKFxcLj9bMC05XSspPyQvO1xuXG4gICAgICAgIC8vIFRoZW4gdGVzdHMgdGhlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuYVNlcCwgWycsJywgJy4nLCAnICcsICcnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYVNlcCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJyAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuYVNlcH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMublNlcCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5TZXApKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgJ25TZXAnIG9wdGlvbiBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5uU2VwfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRHcm91cCkpIHsgLy8gaXNOYU4ocGFyc2VJbnQob3B0aW9ucy5kR3JvdXApKSAvL0RFQlVHXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZEdyb3VwJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kR3JvdXB9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuYURlYywgWycsJywgJy4nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJyBvciAnLCcsIFske29wdGlvbnMuYURlY31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAob3B0aW9ucy5hRGVjID09PSBvcHRpb25zLmFTZXApIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdhRGVjJyBbJHtvcHRpb25zLmFEZWN9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciAnYVNlcCcgWyR7b3B0aW9ucy5hU2VwfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuYWx0RGVjKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5hbHREZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FsdERlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hbHREZWN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFTaWduICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hU2lnbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdhU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hU2lnbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5wU2lnbiwgWydwJywgJ3MnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIGN1cnJlbmN5IHNpZ24gb3B0aW9uICdwU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpIG9yICdzJyAoc3VmZml4KSwgWyR7b3B0aW9ucy5wU2lnbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5wTmVnLCBbJ3AnLCAncycsICdsJywgJ3InXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICdwTmVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSBvciAncicgKHJpZ2h0KSwgWyR7b3B0aW9ucy5wTmVnfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuYVN1ZmZpeCkgfHwgKG9wdGlvbnMuYVN1ZmZpeCAhPT0gJycgJiYgKGNvbnRhaW5zKG9wdGlvbnMuYVN1ZmZpeCwgJy0nKSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuYVN1ZmZpeCkpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnYVN1ZmZpeCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuYVN1ZmZpeH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vTGltaXRzKSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub0xpbWl0cywgWydjZWlsaW5nJywgJ2Zsb29yJywgJ2lnbm9yZSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG92ZXJyaWRlIG1pbiAmIG1heCBsaW1pdHMgb3B0aW9uICdvTGltaXRzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnY2VpbGluZycsICdmbG9vcicgb3IgJ2lnbm9yZScsIFske29wdGlvbnMub0xpbWl0c31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNYXgpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1heCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1heH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNaW4pIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1pbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1pbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1pbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQob3B0aW9ucy52TWluKSA+IHBhcnNlRmxvYXQob3B0aW9ucy52TWF4KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gOyAndk1pbicgWyR7b3B0aW9ucy52TWlufV0gc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiAndk1heCcgWyR7b3B0aW9ucy52TWF4fV0uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShpc051bGwob3B0aW9ucy5tRGVjKSB8fFxuICAgICAgICAgICAgKGlzSW50KG9wdGlvbnMubURlYykgJiYgb3B0aW9ucy5tRGVjID49IDApIHx8IC8vIElmIGludGVnZXIgb3B0aW9uXG4gICAgICAgICAgICAoaXNTdHJpbmcob3B0aW9ucy5tRGVjKSAmJiB0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5tRGVjKSkpICAvLyBJZiBzdHJpbmcgb3B0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnbURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMubURlY31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIHZNaW4vdk1heCBpcyBvdmVycmlkZGVuIGJ5IG1EZWMgKGFuZCBub3QgaWYgbURlYyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiB2TWluL3ZNYXgpXG4gICAgICAgIGNvbnN0IHZNaW5NYXhEZWNpbWFsUGxhY2VzID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChvcHRpb25zLnZNaW4sIG9wdGlvbnMudk1heCk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiZcbiAgICAgICAgICAgICgoaGFzRGVjaW1hbHMob3B0aW9ucy52TWluKSB8fCBoYXNEZWNpbWFscyhvcHRpb25zLnZNYXgpKSAmJiB2TWluTWF4RGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdtRGVjJyB0byBbJHtvcHRpb25zLm1EZWN9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAndk1pbicgWyR7b3B0aW9ucy52TWlufV0gYW5kICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYVBhZCAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FQYWQnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnbURlYycgc2V0dGluZyBbJHtvcHRpb25zLm1EZWN9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5lRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZURlY31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImVEZWNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcIm1EZWNcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICFpc051bGwob3B0aW9ucy5tRGVjKSAmJiBOdW1iZXIob3B0aW9ucy5tRGVjKSA8IE51bWJlcihvcHRpb25zLmVEZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZURlYycgWyR7b3B0aW9ucy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSAnbURlYycgWyR7b3B0aW9ucy5tRGVjfV0gdmFsdWUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGl2aXNvcikgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgZGl2aXNvciBvcHRpb24gJ3NjYWxlRGl2aXNvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlciwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGl2aXNvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWwpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWwpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWx9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hU3RvcikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFTdG9yKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnYVN0b3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFTdG9yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm1Sb3VuZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAnbVJvdW5kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMubVJvdW5kfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hUGFkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVBhZCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FQYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFQYWR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubkJyYWNrZXQpICYmICFpc0luQXJyYXkob3B0aW9ucy5uQnJhY2tldCwgWycoLCknLCAnWyxdJywgJzwsPicsICd7LH0nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbkJyYWNrZXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicgb3IgJ3ssfScsIFske29wdGlvbnMubkJyYWNrZXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMud0VtcHR5LCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICd3RW1wdHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy53RW1wdHl9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubFplcm8sIFsnYWxsb3cnLCAnZGVueScsICdrZWVwJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbGVhZGluZyB6ZXJvIGJlaGF2aW9yIG9wdGlvbiAnbFplcm8nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdhbGxvdycsICdkZW55JyBvciAna2VlcCcsIFske29wdGlvbnMubFplcm99XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFGb3JtKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYUZvcm0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnYUZvcm0nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFGb3JtfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zTnVtYmVyKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc051bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzTnVtYmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zTnVtYmVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFuRGVmYXVsdCkgJiYgKG9wdGlvbnMuYW5EZWZhdWx0ICE9PSAnJyAmJiAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLmFuRGVmYXVsdCkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2FuRGVmYXVsdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuYW5EZWZhdWx0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy51blNldE9uU3VibWl0KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMudW5TZXRPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByZW1vdmUgZm9ybWF0dGluZyBvbiBzdWJtaXQgb3B0aW9uICd1blNldE9uU3VibWl0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51blNldE9uU3VibWl0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm91dHB1dFR5cGUpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdXRwdXRUeXBlLCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dFR5cGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIG51bGwsICdzdHJpbmcnLCAnbnVtYmVyJywgJy4nLCAnLS4nLCAnLCcsICctLCcsICcuLScgb3IgJywtJywgWyR7b3B0aW9ucy5vdXRwdXRUeXBlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5kZWJ1ZykgJiYgIWlzQm9vbGVhbihvcHRpb25zLmRlYnVnKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZGVidWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmRlYnVnfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICAgIH0pKCk7XG59KSk7XG5cbi8qKlxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy9hbi5hcmVTZXR0aW5nc1ZhbGlkKG9wdGlvbnMpIDogcmV0dXJuIHRydWUgb3IgZmFsc2UgLy9UT0RPIElzIHRoaXMgcmVkdW5kYW50PyBTaG91bGQgd2UgbGV0IHRoZSBkZXZlbG9wZXJzIHdyYXAgZWFjaCBhdXRvTnVtZXJpYy52YWxpZGF0ZSgpIGNhbGxzIGluIHRyeS9jYXRjaCBibG9jaz8gT3Igc2hvdWxkIHdlIGp1c3QgZmFjaWxpdGF0ZSB0aGVpciBsaWZlIGJ5IGRvaW5nIGl0IGFscmVhZHk/XG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXV0b051bWVyaWMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
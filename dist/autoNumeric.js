(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-16 UTC-10 23:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message) {\n        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * Function to handle warning messages\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n        if (settings.scaleDecimal) {\n            settings.mDec = settings.scaleDecimal;\n        }\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * converts the ISO numeric string to the locale decimal and minus sign placement\n     * see \"localeOutput\" option for determine\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        //FIXME `settings.aPad` should never be 'null' since the default is 'true'\n        if (typeof settings.aPad === 'boolean' || settings.aPad === null) {\n            rDec = settings.aPad ? settings.mDec : 0;\n        } else {\n            rDec = Number(settings.aPad);\n        }\n\n        // Checks if the iv (input Value) is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 's' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        //FIXME The options 'a' is never tested here\n        tRound > 5 && settings.mRound === 'A' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'A' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // Supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // Checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n                }\n\n                // Checks for non-supported tags\n                //TODO Move the static configuration objects out of that block, and hoist them at the start of this file\n                var allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n                var currentElementTag = $this.prop('tagName').toLowerCase();\n                if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n                    throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n                }\n\n                // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: allowedTagList\n                    });\n\n                    // Modify the user settings to make them 'exploitable'\n                    $.each(settings, function (key, value) {\n                        // Convert the string 'true' and 'false' to real Boolean\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n\n                        // Convert numbers in options to strings\n                        //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                        if (typeof value === 'number' && key !== 'aScale') {\n                            settings[key] = value.toString();\n                        }\n                    });\n\n                    // Validate the settings\n                    validate(settings, false); // Throws if necessary\n\n                    // Additional `aScale` settings initialization\n                    if (settings.aScale !== null) {\n                        settings.scaleFactor = +settings.aScale[0];\n                        settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                        settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                    }\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n\n                        /*\n                         * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                         * precedence and should get formatted on init (if that this input value is a valid number and that the\n                         * developer wants it formatted on init (cf. `settings.aForm`)). Note; this is true whatever the developer\n                         * has set for `data-an-default` in the html (asp.net users).\n                         *\n                         * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n                         * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n                         * changed the input value, and then it means we should not overwrite his own decision to do so.\n                         * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n                         * we should ignore `anDefault` altogether.\n                         */\n                        if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                            // Check if the `value` is valid or not\n                            var testedCurrentValue = parseFloat(currentValue.replace(',', '.')); //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                            if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                                $this.autoNumeric('set', testedCurrentValue);\n                                setValue = false;\n                            } else {\n                                // If not, inform the developer that nothing usable has been provided\n                                throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                            }\n                        } else {\n                            /* Checks for :\n                             * - page reload from back button, and\n                             * - ASP.net form post back\n                             *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                             *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                             */\n                            //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                            if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                                if (settings.eDec !== null && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (settings.aScale && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (!settings.aStor) {\n                                    var toStrip = void 0;\n                                    if (settings.nBracket !== null && settings.aNeg !== '') {\n                                        settings.onOff = true;\n                                        toStrip = negativeBracket(currentValue, settings);\n                                    } else {\n                                        toStrip = currentValue;\n                                    }\n                                    settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                                }\n                                setValue = false;\n                            }\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                //TODO Extract the event listeners to another function\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                        }\n\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.aScale) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n                            $this.change();\n                            holder.inVal = $this.val();\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.aScale) {\n                                    value = value / $settings.scaleFactor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.aScale && $settings.aScale[1] ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSuffix ? groupedValue + $settings.scaleSuffix : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.aScale !== null) {\n                    settings.scaleFactor = +settings.aScale[0];\n                    settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                    settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (!settings.eDec || !settings.aScale)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.aScale && !settings.onOff) {\n                                value = value / settings.scaleFactor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.aScale === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec !== null || settings.aScale !== null)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSuffix) {\n                    value = value + settings.scaleSuffix;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.aScale) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!isArray(this) || this.length !== 1 || !this[0].hasOwnProperty('value')) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * autoNumeric function\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            //TODO First validate the options passed as an argument, before using `init` (with `validate()`)\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /**\n     * Defaults are public - these can be overridden by the following:\n     * HTML5 data attributes\n     * Options passed by the 'init' or 'update' methods\n     * Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n     */\n    $.fn.autoNumeric.defaults = {\n        /* allowed thousand separator characters\n         * comma = \",\"\n         * period \"full stop\" = \".\"\n         * apostrophe is escaped = \"\\\"\"\n         * space = \" \"\n         * none = \"\"\n         * NOTE: do not use numeric characters\n         */\n        aSep: ',',\n\n        /* when true => when the input has focus only the decimal character is visible\n         */\n        nSep: false,\n\n        /* digital grouping for the thousand separator used in Format\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n         * dGroup: \"3\", results in 999,999,999 default\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n         */\n        dGroup: '3',\n\n        /* allowed decimal separator characters\n         * period \"full stop\" = \".\"\n         * comma = \",\"\n         */\n        aDec: '.',\n\n        /* allow to declare alternative decimal separator which is automatically replaced by aDec\n         * developed for countries the use a comma \",\" as the decimal character\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\n         * Must be in quotes aSign: \"$\"\n         * space to the right of the currency symbol aSign: '$ '\n         * space to the left of the currency symbol aSign: ' $'\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\n         * for prefix pSign: \"p\" (default)\n         * for suffix pSign: \"s\"\n         */\n        pSign: 'p',\n\n        /* placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n         * -1,234.56  => default no options required\n         * -$1,234.56 => {aSign: \"$\"}\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n         * 1,234.56-  => {pNeg: \"s\"}\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n         * Numeric characters and negative sign not allowed'\n         */\n        aSuffix: '',\n\n        /* Override min max limits\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n         * oLimits: \"ignore\" ignores both vMin & vMax\n         */\n        oLimits: null,\n\n        /* maximum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be larger than vMin\n         */\n        vMax: '9999999999999.99',\n\n        /* minimum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be smaller than vMax\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n         * value must be enclosed in quotes example mDec: \"3\",\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n         * the \"get\" method returns the extended decimal places\n         */\n        eDec: null,\n\n        /* Scaled number displayed when input does not have focus example with the following:\n         * {aScale: [\"1000\", \"0\", \"K\"]}  => with focus \"1,000.00\" without focus \"1K\"\n         * [\"divisor\", \"decimal places\", \"symbol\"]\n         * divisor value - does not need to be whole number - please understand that Javascript has limited accuracy in math\n         * the \"get\" method returns the full value and scaled value.\n         * decimal places \"optional\" when not in focus - if omitted the decimal places will be the same when the input has focus\n         * Symbol \"optional\" displayed when the input does not have focus - NOTE: if a symbol is used you MUST also specify the decimal places\n         * value must be enclosed in quotes example mDec: \"3\"\n         */\n        aScale: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\n         * if ie 6 or 7 the value will be saved as a session cookie\n         */\n        aStor: false,\n\n        /* method used for rounding\n         * mRound: \"S\", Round-Half-Up Symmetric (default)\n         * mRound: \"A\", Round-Half-Up Asymmetric\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n         * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n         * mRound: \"U05\" Rounds up to next .05\n         * mRound: \"D05\" Rounds down to next .05\n         */\n        mRound: 's',\n\n        /* controls decimal padding\n         * aPad: true - always Pad decimals with zeros\n         * aPad: false - does not pad with zeros.\n         * Note: setting aPad to 'false' will override the 'mDec' setting.\n         *\n         * thanks to Jonas Johansson for the suggestion\n         */\n        aPad: true,\n\n        /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n         * Those brackets are visible only when the field does NOT have the focus.\n         * The left and right symbols should be enclosed in quotes and separated by a comma\n         * nBracket: null - (default)\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\n         * wEmpty: \"always\" - always displays the currency sign only\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n         */\n        //TODO Add an option to display the currency sign only on hover (if the input is empty)\n        wEmpty: 'focus',\n\n        /* controls leading zero behavior\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n         * lZero: \"deny\", - allows only one leading zero on values less than one\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n         */\n        lZero: 'allow',\n\n        /* determine if the default value will be formatted on initialization.\n         * true = automatically formats the default value on initialization\n         * false = will not format the default value\n         */\n        aForm: true,\n\n        /* determine if the select all keyboard command will select\n         * the complete input text or only the input numeric value\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n         */\n        sNumber: false,\n\n        /* helper option for ASP.NET postback\n         * should be the value of the unformatted default value\n         * examples:\n         * no default value=\"\" {anDefault: \"\"}\n         * value=1234.56 {anDefault: '1234.56'}\n         */\n        anDefault: null,\n\n        /* removes formatting on submit event\n         * this output format: positive nnnn.nn, negative -nnnn.nn\n         * review the 'unSet' method for other formats\n         */\n        unSetOnSubmit: false,\n\n        /* allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n         * null => nnnn.nn or -nnnn.nn default\n         * \",\"  => nnnn,nn or -nnnn,nn can also be \"-,\"\n         * \".-\" => nnnn.nn or nnnn.nn-\n         * \",-\" => nnnn,nn or nnnn,nn-\n         */\n        localeOutput: null,\n\n        /* error handling function\n         * true => all errors are thrown - helpful in site development\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.', debug);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, $.fn.autoNumeric.defaults, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.', debug);\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.', debug);\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.', debug);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.', debug);\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.', debug);\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.', debug);\n        }\n\n        var testNumericalCharacters = /[0-9]+/;\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.', debug);\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.', debug);\n        }\n\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.', debug);\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.', debug);\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.', debug);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.', debug);\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.', debug);\n        }\n\n        //FIXME Finish the aScale* options\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.', debug);\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.', debug);\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.', debug);\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.', debug);\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.', debug);\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.', debug);\n        }\n\n        if (!isNull(options.localeOutput) && !isInArray(options.localeOutput, ['.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'localeOutput\\' is invalid ; it should either be empty, \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.localeOutput + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.', debug);\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\n        eventInfo.detail = detail;\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJpc051bGwiLCJ2YWx1ZSIsImlzVW5kZWZpbmVkIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc1RydWVPckZhbHNlU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzT2JqZWN0IiwicmVmZXJlbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJoYXNEZWNpbWFscyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJkZWNpbWFsUGxhY2VzIiwibGVuZ3RoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwidGV4dCIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJkZWJ1ZyIsIndhcm5pbmciLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3MiLCIkdGhpcyIsInNldHRpbmdzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsImRlY0xlbmd0aCIsInZNaW4iLCJ2TWF4Iiwidk1heExlbmd0aCIsInZNaW5MZW5ndGgiLCJNYXRoIiwibWF4IiwiYXV0b0NvZGUiLCJhTmVnIiwicmVwbGFjZSIsIm1JbnRQb3MiLCJtSW50TmVnIiwibURlYyIsIm9EZWMiLCJOdW1iZXIiLCJzY2FsZURlY2ltYWwiLCJhbHREZWMiLCJhRGVjIiwiYVNlcCIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsImF1dG9TdHJpcCIsImFTaWduIiwiYVN1ZmZpeCIsInBOZWciLCJwU2lnbiIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJsWmVybyIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwiY2hhckF0Iiwic2xpY2UiLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwibkJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpdiIsInNpZ25PbkVtcHR5Iiwid0VtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnIiwiZGlnaXRhbEdyb3VwIiwiZEdyb3VwIiwidGVzdCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsIml2Um91bmRlZCIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsIm1Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwicmVzdWx0IiwiYVBhZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsIm9MaW1pdHMiLCJhdXRvR2V0IiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiaG9sZGVyIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwT3JpZ2luYWxTZXR0aW5ncyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJhdXRvU2F2ZSIsInRvRG8iLCJhU3RvciIsInN0b3JlZE5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZCIsImRhdGUiLCJleHBpcmVzIiwiRGF0ZSIsInNldFRpbWUiLCJnZXRUaW1lIiwidG9VVENTdHJpbmciLCJnZXRJdGVtIiwiZm9ybWF0dGVkIiwic2V0dGluZ3NDbG9uZSIsImluaXQiLCJjdHJsS2V5IiwiY21kS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwidHlwZSIsImtkQ29kZSIsIndoaWNoIiwicHJvY2Vzc2VkIiwic2V0U2VsZWN0aW9uIiwic2V0UmVhbCIsIm1pbiIsInNldFBvc2l0aW9uIiwicG9zIiwiZ2V0QmVmb3JlQWZ0ZXIiLCJsZWZ0IiwicmlnaHQiLCJnZXRCZWZvcmVBZnRlclN0cmlwZWQiLCJub3JtYWxpemVQYXJ0cyIsIm5ld1ZhbHVlIiwic2V0VmFsdWVQYXJ0cyIsImFkdmVudCIsInBhcnRzIiwibWluVGVzdCIsIm1heFRlc3QiLCJ0ZXN0VmFsdWUiLCJ0cmlnZ2VyIiwic2lnblBvc2l0aW9uIiwiYVNpZ25MZW4iLCJoYXNOZWciLCJ2YWx1ZUxlbiIsImV4cGFuZFNlbGVjdGlvbk9uU2lnbiIsImNoZWNrUGFzdGUiLCJ2YWx1ZVBhcnRzQmVmb3JlUGFzdGUiLCJvbGRQYXJ0cyIsIm1vZGlmaWVkTGVmdFBhcnQiLCJzdWJzdHIiLCJza2lwQWx3YXlzIiwic051bWJlciIsInByZXZlbnREZWZhdWx0IiwibmVnTGVuIiwiYVN1ZmZpeExlbiIsInN0YXJ0SnVtcCIsInByb2Nlc3NUcmFpbGluZyIsImNhcmV0Rml4IiwiQm9vbGVhbiIsInByb2Nlc3NBbHdheXMiLCJ0aHJvd0lucHV0IiwicHJvY2Vzc0tleXByZXNzIiwiY0NvZGUiLCJmcm9tQ2hhckNvZGUiLCJmb3JtYXRRdWljayIsImxlZnRMZW5ndGgiLCJrdUNvZGUiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiaW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwiaW5BcnJheSIsInRlc3RJbnB1dCIsImxvY2FsZU91dHB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsImlucHV0VmFsdWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJtZXRob2RzIiwib3B0aW9ucyIsInRhZ0RhdGEiLCIkaW5wdXQiLCJpcyIsImFsbG93ZWRUYWdMaXN0IiwiY3VycmVudEVsZW1lbnRUYWciLCJleHRlbmQiLCJmbiIsImRlZmF1bHRzIiwicnVuT25jZSIsInRhZ0xpc3QiLCJrZXkiLCJhU2NhbGUiLCJzY2FsZUZhY3RvciIsInNjYWxlU3VmZml4IiwiYUZvcm0iLCJzZXRWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImF0dHIiLCJ0ZXN0ZWRDdXJyZW50VmFsdWUiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJJbmZpbml0eSIsImFuRGVmYXVsdCIsImlzTnVtZXJpYyIsImVEZWMiLCJ0b1N0cmlwIiwib24iLCIkc2V0dGluZ3MiLCJuU2VwIiwiaW5WYWwiLCJsYXN0VmFsIiwib25FbXB0eSIsInJlYWRPbmx5Iiwic2tpcCIsInRhYiIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsInByZXBhcmUiLCJpc1ZhbGlkIiwib2xkUmF3VmFsdWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJwYXN0ZWRUZXh0Iiwib3JpZ2luYWxFdmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidmFsdWVPZiIsImNsb3Nlc3QiLCJ1blNldE9uU3VibWl0IiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJvZmYiLCJ3aXBlIiwic2V0IiwidmFsdWVJbiIsImF0dGVtcHRlZFZhbHVlIiwidW5TZXQiLCJyZVNldCIsImVxIiwiZ2V0Rm9ybWF0dGVkIiwiZ2V0U3RyaW5nIiwiZ2V0QXJyYXkiLCJnZXRTZXR0aW5ncyIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsInNlbmRDdXN0b21FdmVudCIsImF1dG9VbmZvcm1hdCIsInVzZXJPcHRpb25zIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJ0ZXN0UG9zaXRpdmVJbnRlZ2VyIiwidGVzdE51bWVyaWNhbENoYXJhY3RlcnMiLCJ0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiIsImRwVk1pbiIsImRwVk1heCIsInZNaW5NYXhEZWNpbWFsUGxhY2VzIiwiZXJyb3IiLCJjcmVhdGVDdXN0b21FdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJwYXJhbXMiLCJldnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsIkV2ZW50IiwiZm9ybWF0IiwidW5Gb3JtYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjtBQUNBLElBQUlDLGlCQUFKO0FBQ0EsSUFBSUMseUJBQUo7O0FBRUE7O0FBRUMsV0FBU0MsT0FBVCxFQUFrQjtBQUNmO0FBQ0osUUFBSSxJQUFKLEVBQWdEO0FBQzVDO0FBQ0FDLFFBQUEsaUNBQU8sQ0FBQyxzQkFBRCxDQUFQLG9DQUFtQkQsT0FBbkI7QUFDSCxLQUhELE1BR08sSUFBSSxRQUFPRSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCQSxPQUFPQyxPQUF6QyxFQUFrRDtBQUNyRDtBQUNBRCxlQUFPQyxPQUFQLEdBQWlCSCxRQUFRSSxRQUFRLFFBQVIsQ0FBUixDQUFqQjtBQUNILEtBSE0sTUFHQTtBQUNIO0FBQ0FKLGdCQUFRSyxPQUFPQyxNQUFmO0FBQ0g7QUFDQSxDQVpBLEVBWUMsYUFBSztBQUNIOzs7QUFHQSxRQUFNQyxVQUFVO0FBQ1pDLG1CQUFnQixDQURKO0FBRVpDLGFBQWdCLENBRko7QUFHWkMsZUFBZ0IsRUFISjtBQUlaQyxlQUFnQixFQUpKO0FBS1pDLGNBQWdCLEVBTEo7QUFNWkMsYUFBZ0IsRUFOSjtBQU9aQyxvQkFBZ0IsRUFQSjtBQVFaQyxrQkFBZ0IsRUFSSjtBQVNaQyxhQUFnQixFQVRKO0FBVVpDLGVBQWdCLEVBVko7QUFXWkMsZ0JBQWdCLEVBWEo7QUFZWkMsa0JBQWdCLEVBWko7QUFhWkMsYUFBZ0IsRUFiSjtBQWNaQyxjQUFnQixFQWRKO0FBZVpDLG1CQUFnQixFQWZKO0FBZ0JaQyxpQkFBZ0IsRUFoQko7QUFpQlpDLG9CQUFnQixFQWpCSjtBQWtCWkMsbUJBQWdCLEVBbEJKO0FB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QVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNTyxNQUFNelYsU0FBUzBWLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBRCxnQkFBSUUsZUFBSixDQUFvQkosS0FBcEIsRUFBMkJDLE9BQU9KLE9BQWxDLEVBQTJDSSxPQUFPSCxVQUFsRCxFQUE4REcsT0FBT04sTUFBckU7QUFDQSxtQkFBT08sR0FBUDtBQUNIOztBQUVETixvQkFBWWxXLFNBQVosR0FBd0JsSSxPQUFPNmUsS0FBUCxDQUFhM1csU0FBckM7QUFDQWxJLGVBQU9vZSxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQXRsR0EsQ0FBRDs7QUF3bEdBOzs7a0JBR2U7QUFDWFUsWUFBVXhmLFVBREM7QUFFWHlmLGNBQVV4ZixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLHNCQUpXLEVBSUQ7QUFDVkMsc0NBTFcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIGF1dG9OdW1lcmljLmpzXG4qIEBhdXRob3I6IEJvYiBLbm90aGVcbiogQGNvbnRyaWJ1dG9yczogU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnNcbiogQHZlcnNpb246IDIuMCAtIDIwMTYtMTEtMTYgVVRDLTEwIDIzOjAwXG4qXG4qIENyZWF0ZWQgYnkgUm9iZXJ0IEouIEtub3RoZSBvbiAyMDA5LTA4LTA5LiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbipcbiogQ29weXJpZ2h0IChjKSAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xuKlxuKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxubGV0IGF1dG9Gb3JtYXQ7XG5sZXQgYXV0b1VuRm9ybWF0O1xubGV0IGdldERlZmF1bHRDb25maWc7XG5sZXQgdmFsaWRhdGU7XG5sZXQgYXJlU2V0dGluZ3NWYWxpZDtcblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS9Db21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG59IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG59XG59KCQgPT4ge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGtleUNvZGUgPSB7XG4gICAgICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgICAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICAgICAgRW50ZXI6ICAgICAgICAgIDEzLFxuICAgICAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICAgICAgQWx0OiAgICAgICAgICAgIDE4LFxuICAgICAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICAgICAgRXNjOiAgICAgICAgICAgIDI3LFxuICAgICAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICAgICAgUGFnZURvd246ICAgICAgIDM0LFxuICAgICAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICAgICAgTGVmdEFycm93OiAgICAgIDM3LFxuICAgICAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICAgICAgRG93bkFycm93OiAgICAgIDQwLFxuICAgICAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICAgICAgbnVtMDogICAgICAgICAgIDQ4LFxuICAgICAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICAgICAgbnVtMzogICAgICAgICAgIDUxLFxuICAgICAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICAgICAgbnVtNjogICAgICAgICAgIDU0LFxuICAgICAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICAgICAgbnVtOTogICAgICAgICAgIDU3LFxuICAgICAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICAgICAgYzogICAgICAgICAgICAgIDY3LFxuICAgICAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICAgICAgZjogICAgICAgICAgICAgIDcwLFxuICAgICAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICAgICAgaTogICAgICAgICAgICAgIDczLFxuICAgICAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICAgICAgbDogICAgICAgICAgICAgIDc2LFxuICAgICAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICAgICAgbzogICAgICAgICAgICAgIDc5LFxuICAgICAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICAgICAgcjogICAgICAgICAgICAgIDgyLFxuICAgICAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICAgICAgdTogICAgICAgICAgICAgIDg1LFxuICAgICAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICAgICAgeDogICAgICAgICAgICAgIDg4LFxuICAgICAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICAgICAgV2luZG93czogICAgICAgIDkxLFxuICAgICAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICAgICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgICAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICAgICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICAgICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICAgICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICAgICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICAgICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICAgICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICAgICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICAgICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICAgICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICAgICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICAgICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICAgICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICAgICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICAgICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICAgICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICAgICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICAgICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICAgICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICAgICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICAgICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICAgICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICAgICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICAgICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICAgICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICAgICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICAgICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICAgICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICAgICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICAgICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICAgICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICAgICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICAgICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICAgICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICAgICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICAgICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICAgICAgQ29tbWFuZDogICAgICAgIDIyNCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGFyclxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzRGVjaW1hbHMoc3RyKSB7XG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cbiAgICAgKiBSZXR1cm4gYG51bGxgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxpbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBnZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gdGhhdC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGF0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyBtZXNzYWdlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSwgZGVidWcgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSB3YXJuaW5nIG1lc3NhZ2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCBzdXBwcmVzc1dhcm5pbmdzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJ1biBjYWxsYmFja3MgaW4gcGFyYW1ldGVycyBpZiBhbnlcbiAgICAgKiBhbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIGxvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoaywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIHZNaW4gdk1heCBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY0xlbmd0aCh2TWluLCB2TWF4KSB7XG4gICAgICAgIGxldCB2TWF4TGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHZNaW5MZW5ndGggPSAwO1xuICAgICAgICBpZiAodk1heFsxXSkge1xuICAgICAgICAgICAgdk1heExlbmd0aCA9IHZNYXhbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2TWluWzFdKSB7XG4gICAgICAgICAgICB2TWluTGVuZ3RoID0gdk1pblsxXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodk1heExlbmd0aCwgdk1pbkxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyaW5nIHVzZXIgZGVmaW5lZCBvcHRpb25zIGZvciBmdXJ0aGVyIHVzYWdlXG4gICAgICogbWVyZ2UgdGhlbSB3aXRoIGRlZmF1bHRzIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvQ29kZSgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzKCR0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IHZNYXggPSBzZXR0aW5ncy52TWF4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIHNldHRpbmdzLmFOZWcgPSBzZXR0aW5ncy52TWluIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2TWF4WzBdID0gdk1heFswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB2TWluWzBdID0gdk1pblswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBzZXR0aW5ncy5tSW50UG9zID0gTWF0aC5tYXgodk1heFswXS5sZW5ndGgsIDEpO1xuICAgICAgICBzZXR0aW5ncy5tSW50TmVnID0gTWF0aC5tYXgodk1pblswXS5sZW5ndGgsIDEpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IE51bWJlcihzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gc2V0dGluZ3Muc2NhbGVEZWNpbWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleVxuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjID09PSBudWxsICYmIHNldHRpbmdzLm1EZWMgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gJy4nICYmIHNldHRpbmdzLmFTZXAgIT09ICcsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdERlYyA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYURlYyA9PT0gJywnICYmIHNldHRpbmdzLmFTZXAgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdERlYyA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHJlZ2V4cHMgZm9yIGF1dG9TdHJpcFxuICAgICAgICBjb25zdCBhTmVnUmVnID0gc2V0dGluZ3MuYU5lZyA/YChbLVxcXFwke3NldHRpbmdzLmFOZWd9XT8pYCA6JygtPyknO1xuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7KHNldHRpbmdzLmFOZWc/YFxcXFwke3NldHRpbmdzLmFOZWd9YDonJyl9XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZF0uKj8oXFxcXGR8XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZClgKTtcbiAgICAgICAgc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAoXFxcXGRcXFxcJHtzZXR0aW5ncy5hRGVjfT8pW15cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXVxcXFxEKiRgKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcbiAgICAgICAgc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmFEZWN9PyhcXFxcZCtcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKyl8KFxcXFxkKig/OlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQqKT8pKWApO1xuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdHJpcCBhbGwgdW53YW50ZWQgY2hhcmFjdGVycyBhbmQgbGVhdmUgb25seSBhIG51bWJlciBhbGVydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9TdHJpcChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYVNpZ24gIT09ICcnKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU2lnbiwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU3VmZml4KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc3VmZml4XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3MuYVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTdWZmaXgsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcblxuICAgICAgICBpZiAoKHNldHRpbmdzLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnICE9PSAncCcpKSAmJiBjb250YWlucyhzLCAnLScpICYmIHMgIT09ICcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XG5cbiAgICAgICAgLy8gdGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsdERlYywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sWmVybyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MuYU5lZykpIHtcbiAgICAgICAgICAgICAgICBuU2lnbiA9IHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gYCR7blNpZ259JHttb2RpZmllZEludGVnZXJQYXJ0fSR7aXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpPycnOnNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3MubFplcm8gPT09ICdkZW55JykgfHwgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnICYmIHNldHRpbmdzLm9uT2ZmID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgICAgIGxldCBzdHJpcFJlZyA9IGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkKWA7XG4gICAgICAgICAgICBzdHJpcFJlZyA9IG5ldyBSZWdFeHAoc3RyaXBSZWcpO1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzdHJpcFJlZywgJyQxJDInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBsYWNlcyBvciByZW1vdmVzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoKHNldHRpbmdzLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpKSB7XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBsb2NhbGUgZm9ybWF0IHRvIEphdmFzY3JpcHQgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWQgb2YgY3VycmVuY3kgc2lnbnMgYWxsb3dlZFxuICAgICAqICcxMjM0LjU2JyAgICBPS1xuICAgICAqICctMTIzNC41NicgICBPS1xuICAgICAqICcxMjM0LjU2LScgICBPS1xuICAgICAqICcxMjM0LDU2JyAgICBPS1xuICAgICAqICctMTIzNCw1NicgICBPS1xuICAgICAqICcxMjM0LDU2LScgICBPS1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Mb2NhbGUocykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudFxuICAgICAqIHNlZSBcImxvY2FsZU91dHB1dFwiIG9wdGlvbiBmb3IgZGV0ZXJtaW5lXG4gICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcbiAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzIGJlIFwiLSxcIlxuICAgICAqIFwiLi1cIiA9PiBubm5uLm5uIG9yIG5ubm4ubm4tXG4gICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcuLScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJywnIHx8IGxvY2FsZSA9PT0gJy0sJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlID09PSAnLC0nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIG51bWJlciBzdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHJlYWwgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZml4TnVtYmVyKHMsIGFEZWMsIGFOZWcpIHtcbiAgICAgICAgaWYgKGFEZWMgJiYgYURlYyAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFEZWMsICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFOZWcgJiYgYU5lZyAhPT0gJy0nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFOZWcsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgcyArPSAnMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIHJlYWwgbnVtYmVyIHRvIGJlIGNvbnZlcnRlZCB0byBvdXIgZm9ybWF0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlc2VudE51bWJlcihzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYU5lZyAmJiBzZXR0aW5ncy5hTmVnICE9PSAnLScpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyAmJiBzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpdiwgc2V0dGluZ3MsIHNpZ25PbkVtcHR5KSB7XG4gICAgICAgIGlmIChpdiA9PT0gJycgfHwgaXYgPT09IHNldHRpbmdzLmFOZWcpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5wTmVnID09PSAnbCcpID8gaXYgKyBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFTdWZmaXggOiBzZXR0aW5ncy5hU2lnbiArIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIG91ciBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR3JvdXAoaXYsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdHJpcCkge1xuICAgICAgICAgICAgaXYgPSBhdXRvU3RyaXAoaXYsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMoaXYsICctJykpIHtcbiAgICAgICAgICAgIGl2ID0gJy0nICsgaXY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1wdHkgPSBjaGVja0VtcHR5KGl2LCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGlzTmVnID0gY29udGFpbnMoaXYsICctJyk7XG4gICAgICAgIGlmIChpc05lZykge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXAgPSAnJztcbiAgICAgICAgc2V0dGluZ3MuZEdyb3VwID0gc2V0dGluZ3MuZEdyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcyJykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcycycpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzQnKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpdi5zcGxpdChzZXR0aW5ncy5hbHREZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2VwICE9PSAnJykge1xuICAgICAgICAgICAgLy8gcmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuYVNlcH0kMmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MubURlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdob2xlIG51bWJlcnMgb25seVxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduICsgaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWcgKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgaXYgKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFOZWcgKyBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFOZWcgKyBpdiArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgKHNldHRpbmdzLnJhd1ZhbHVlIDwgMCB8fCBpdi5jaGFyQXQoMCkgPT09ICctJykpIHtcbiAgICAgICAgICAgIGl2ID0gbmVnYXRpdmVCcmFja2V0KGl2LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBpdiArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgbm90IG5lZWRlZCB6ZXJvc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCByRGVjKSB7XG4gICAgICAgIGxldCByZWdleDtcbiAgICAgICAgc3dpdGNoIChyRGVjKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLlxcZCg/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcLlxcXFxkeyR7ckRlY319KD86XFxcXGQqWzEtOV0pPykwKmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2ltYWwgcGxhY2VzLCB3ZSBkb24ndCBuZWVkIGEgZGVjaW1hbCBwb2ludCBhdCB0aGUgZW5kXG4gICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgaWYgKHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3VuZCBudW1iZXIgYWZ0ZXIgc2V0dGluZyBieSBwYXN0aW5nIG9yICQoKS5hdXRvTnVtZXJpY1NldCgpXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiBmb3Igcm91bmQgdGhlIG51bWJlclxuICAgICAqIHBsZWFzZSBub3RlIHRoaXMgaGFuZGxlZCBhcyB0ZXh0IC0gSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXNcbiAgICAgKiBhbHNvIHRoaXMgb2ZmZXJzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMgdGhhdCBhcmUgbm90IGVhc2lseSBhY2NvbXBsaXNoZWQgaW4gSmF2YVNjcmlwdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Sb3VuZChpdiwgc2V0dGluZ3MpIHsgLy8gdmFsdWUgdG8gc3RyaW5nXG4gICAgICAgIGl2ID0gKGl2ID09PSAnJykgPyAnMCcgOiBpdi50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubVJvdW5kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdDSEYnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnRDA1Jykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5tUm91bmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLnJvdW5kKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1UwNSc6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGguY2VpbChpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5mbG9vcihpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpdiwgJy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJy4wMCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAtIGl2LmluZGV4T2YoJy4nKSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdiArICcwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICBsZXQgckRlYztcblxuICAgICAgICAvL0ZJWE1FIGBzZXR0aW5ncy5hUGFkYCBzaG91bGQgbmV2ZXIgYmUgJ251bGwnIHNpbmNlIHRoZSBkZWZhdWx0IGlzICd0cnVlJ1xuICAgICAgICBpZiAodHlwZW9mKHNldHRpbmdzLmFQYWQpID09PSAnYm9vbGVhbicgfHwgc2V0dGluZ3MuYVBhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgckRlYyA9IHNldHRpbmdzLmFQYWQ/c2V0dGluZ3MubURlYzowO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgckRlYyA9IE51bWJlcihzZXR0aW5ncy5hUGFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaXYgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGlmIChpdi5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgblNpZ24gPSAnLSc7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gdGhhdCB3aWxsIGJlIGFkZGVkIGJhY2sgbGF0ZXIgaWYgcmVxdWlyZWRcbiAgICAgICAgICAgIGl2ID0gaXYucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgdG8gYmUgYSBkb3QpXG4gICAgICAgIGlmICghaXYubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaXYgPSAnMCcgKyBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGl2KSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpdikgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpdi5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGl2Lmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgLy8gVmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gKGRQb3MgPT09IC0xKSA/IGl2Lmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIENoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpdi5sZW5ndGggLSAxKSAtIHZkUG9zO1xuICAgICAgICBpZiAoY0RlYyA8PSBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpdjtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgIGlmIChkUG9zID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgemVyb3MgPSAnMDAwMDAwJztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHJEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvcy5zdWJzdHJpbmcoMCwgckRlYyAtIGNEZWMpO1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHJEZWMpIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPT09IDAgJiYgckRlYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBjb25zdCByTGVuZ3RoID0gZFBvcyArIHNldHRpbmdzLm1EZWM7IC8vVE9ETyBNb2RpZnkgYGRQb3NgIGhlcmUgaWYgaXQncyBub3QgaW50ZW5kZWQgdGhhdCBpdCBjYW4gYmUgZXF1YWwgdG8gJy0xJ1xuICAgICAgICBjb25zdCB0Um91bmQgPSBOdW1iZXIoaXYuY2hhckF0KHJMZW5ndGggKyAxKSk7XG4gICAgICAgIGNvbnN0IG9kZCA9IChpdi5jaGFyQXQockxlbmd0aCkgPT09ICcuJykgPyAoaXYuY2hhckF0KHJMZW5ndGggLSAxKSAlIDIpIDogKGl2LmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xuICAgICAgICBsZXQgaXZBcnJheSA9IGl2LnN1YnN0cmluZygwLCByTGVuZ3RoICsgMSkuc3BsaXQoJycpO1xuICAgICAgICBpZiAoKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3MubVJvdW5kID09PSAncycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgIC8vRklYTUUgVGhlIG9wdGlvbnMgJ2EnIGlzIG5ldmVyIHRlc3RlZCBoZXJlXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdkFycmF5LmpvaW4oJycpLCByRGVjKTtcblxuICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXN0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlRGVjaW1hbChzLCBzZXR0aW5ncywgcGFzdGUpIHtcbiAgICAgICAgY29uc3QgYURlYyA9IHNldHRpbmdzLmFEZWM7XG4gICAgICAgIGNvbnN0IG1EZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICBzID0gKHBhc3RlID09PSAncGFzdGUnKSA/IGF1dG9Sb3VuZChzLCBzZXR0aW5ncykgOiBzO1xuICAgICAgICBpZiAoYURlYyAmJiBtRGVjKSB7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoYURlYyk7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIGRlY2ltYWwgcGFydCB0byBzYXRpc2Z5aW5nIGxlbmd0aCBzaW5jZSB3ZSB3b3VsZCByb3VuZCBpdCBhbnl3YXlcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBtRGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1EZWMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgbURlYyk7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBgJHtpbnRlZ2VyUGFydH0ke2FEZWN9JHttb2RpZmllZERlY2ltYWxQYXJ0fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHBhcnNlIHZNaW4sIHZNYXggJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiB2TWluOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlU3RyKG4pIHtcbiAgICAgICAgY29uc3QgeCA9IHt9O1xuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBuTDtcbiAgICAgICAgbGV0IGo7XG5cbiAgICAgICAgLy8gTWludXMgemVybz9cbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgICAgICBuID0gJy0wJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLiAxIHBvc2l0aXZlLCAtMSBuZWdhdGl2ZVxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XG4gICAgICAgICAgICB4LnMgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChlID4gLTEpIHtcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgLy8gSW50ZWdlclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcbiAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmMgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5MIC09IDE7XG5cbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcbiAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzXG4gICAgICogVGhpcyB1c2VzIHRoZSBwYXJzZWQgc3RyaW5ncyBmb3IgdGhlIGFib3ZlIHBhcnNlU3RyIGZ1bmN0aW9uXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAgICAgKiBNYW55IHRoYW5rcyB0byBNaWtlXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVzdE1pbk1heCh5LCB4KSB7XG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xuICAgICAgICBjb25zdCB5YyA9IHkuYztcbiAgICAgICAgbGV0IGkgPSB4LnM7XG4gICAgICAgIGxldCBqID0geS5zO1xuICAgICAgICBsZXQgayA9IHguZTtcbiAgICAgICAgbGV0IGwgPSB5LmU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCF4Y1swXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhOZWcgPSBpIDwgMDtcblxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xuICAgICAgICBpZiAoayAhPT0gbCkge1xuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBrID0geGMubGVuZ3RoO1xuICAgICAgICBsID0geWMubGVuZ3RoO1xuICAgICAgICBqID0gKGsgPCBsKSA/IGsgOiBsO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcbiAgICAgICAgZm9yIChpICs9IDE7IGkgPCBqOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChrID09PSBsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2tpbmcgdGhhdCBudW1iZXIgc2F0aXNmeSBmb3JtYXQgY29uZGl0aW9uc1xuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqIGFuZCB0aGUgc3RyaW5nIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgdGhlIGRpZ2l0cyBpbiBzZXR0aW5ncy52TWluIGFuZCBzZXR0aW5ncy52TWF4XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0NoZWNrKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNaW4pO1xuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNYXgpO1xuICAgICAgICBjb25zdCB2YWxQYXJzZSA9IHBhcnNlU3RyKHMpO1xuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mub0xpbWl0cykge1xuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhhbmtzIHRvIEFudGhvbnkgJiBFdmFuIENcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR2V0KG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZSgvXFxbL2csICdcXFxcWycpLnJlcGxhY2UoL10vZywgJ1xcXFxdJyk7XG4gICAgICAgICAgICBvYmogPSAnIycgKyBvYmoucmVwbGFjZSgvKDp8XFwuKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSBtb2RpZmljYXRpb24gdG8gcmVwbGFjZSB0aGUgYWJvdmUgMiBsaW5lc1xuICAgICAgICAgICAgLy8gb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyhbOyYsXFwuXFwrXFwqXFx+JzpcIlxcIVxcXiMkJUBcXFtcXF1cXChcXCk9PlxcfF0pL2csICdcXFxcJDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkKG9iaik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdG8gYXR0YWNoIGRhdGEgdG8gdGhlIGVsZW1lbnRcbiAgICAgKiBhbmQgaW1pdGF0ZSB0aGUgaG9sZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKCR0aGF0LCBzZXR0aW5ncywgdXBkYXRlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob2xkZXIgPSBkYXRhLmhvbGRlcjtcbiAgICAgICAgaWYgKChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSB8fCB1cGRhdGUpIHtcbiAgICAgICAgICAgIGhvbGRlciA9IG5ldyBBdXRvTnVtZXJpY0hvbGRlcigkdGhhdC5nZXQoMCksIHNldHRpbmdzKTtcbiAgICAgICAgICAgIGRhdGEuaG9sZGVyID0gaG9sZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYyAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hUGFkO1xuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5CcmFja2V0O1xuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmFTZXA7XG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuYVNpZ247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkIC0gdGFrZW4gZnJvbSBtb2Rlcm5penJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsIHRvRG8pIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKCR0aGlzWzBdLm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZCgkdGhpc1swXS5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KCR0aGlzWzBdLm5hbWUpfWAgOmBBVVRPXyR7JHRoaXNbMF0uaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIHNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKC0xICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXV0b051bWVyaWNIb2xkZXIodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgIH1cblxuICAgIEF1dG9OdW1lcmljSG9sZGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICB0aGlzLmNtZEtleSA9IGUubWV0YUtleTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuXG4gICAgICAgICAgICAvLyBrZXlwcmVzcyBldmVudCBvdmVyd3JpdGVzIG1lYW5pbmdmdWwgdmFsdWUgb2YgZS5rZXlDb2RlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtkQ29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2hpY2ggPSBlLndoaWNoO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyU3RyaXBlZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCBzZXR0aW5nc0Nsb25lKTtcblxuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGFEZWMsXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGxlZnQgPT09ICcnIHx8IGxlZnQgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgc2V0dGluZ3NDbG9uZS5sWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmFEZWN9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIGtlZXBpbmcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBhZHZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgYWR2ZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4cGFuZFNlbGVjdGlvbk9uU2lnblxuICAgICAgICAgKiByZXR1cm5zIHNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBhU2lnbiA9IHNldHRpbmdzQ2xvbmUuYVNpZ247XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xuICAgICAgICAgICAgaWYgKGFTaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAgICAgKiBwcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5zaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIGF1dG9TdHJpcChsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIGlmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIHNraXBBbHdheXMoZSkge1xuICAgICAgICAgICAgY29uc3Qga2RDb2RlID0gdGhpcy5rZENvZGU7XG4gICAgICAgICAgICBjb25zdCB3aGljaCA9IHRoaXMud2hpY2g7XG4gICAgICAgICAgICBjb25zdCBjdHJsS2V5ID0gdGhpcy5jdHJsS2V5O1xuICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gdGhpcy5jbWRLZXk7XG5cbiAgICAgICAgICAgIC8vIGNhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgaWYgKCgoY3RybEtleSB8fCBjbWRLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoc2hpZnRLZXkgJiYga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgRngga2V5cywgd2luZG93cyBrZXlzLCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgoa2RDb2RlID49IGtleUNvZGUuRjEgJiYga2RDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIGtkQ29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLlRhYiAmJiBrZENvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgICh3aGljaCA9PT0gMCB8fCB3aGljaCA9PT0ga2RDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdCBhbGwgKGEpXG4gICAgICAgICAgICBpZiAoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBrZENvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gdGhpcy5zZXR0aW5ncy5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTdWZmaXhMZW4gPSB0aGlzLnNldHRpbmdzLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwU2lnbiA9IHRoaXMuc2V0dGluZ3MucFNpZ247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBOZWcgPSB0aGlzLnNldHRpbmdzLnBOZWc7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAocE5lZyA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBhU2lnbkxlbiA+IDApP2FTaWduTGVuICsgMTphU2lnbkxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIGFTdWZmaXhMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVN1ZmZpeExlbiArIGFTaWduTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChhU2lnbkxlbiA+IDApP3ZhbHVlTGVuIC0gKGFTaWduTGVuICsgbmVnTGVuICsgYVN1ZmZpeExlbik6dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgKGtkQ29kZSA9PT0ga2V5Q29kZS5jIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXG4gICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCBrZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN0cmxLZXkgfHwgY21kS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNlcCA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFEZWMgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYURlYztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYVNlcCB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXJ0SnVtcCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtkQ29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIGtkQ29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSArIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgLSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzQWx3YXlzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiAoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5wcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgaW5zZXJ0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzS2V5cHJlc3MoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgY0NvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMud2hpY2gpO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcbiAgICAgICAgICAgIGlmIChjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hRGVjIHx8IChzZXR0aW5nc0Nsb25lLmFsdERlYyAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hbHREZWMpIHx8ICgoY0NvZGUgPT09ICcuJyB8fCBjQ29kZSA9PT0gJywnKSAmJiB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLm1EZWMgfHwgIXNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIGFOZWcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFEZWMpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmFEZWMsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0cnkgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51c1xuICAgICAgICAgICAgaWYgKGNDb2RlID49ICcwJyAmJiBjQ29kZSA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hTmVnICYmIGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnZNYXggPD0gMCAmJiBzZXR0aW5nc0Nsb25lLnZNaW4gPCBzZXR0aW5nc0Nsb25lLnZNYXggJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBjQ29kZSwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aXRoIGtlZXBpbmcgb2YgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRRdWljayhlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrdUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcblxuICAgICAgICAgICAgLy8gbm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuYVNlcCAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTZXAgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2VwKSkpICYmXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuYVNpZ24gPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2lnbikpKSkge1xuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmFEZWMpO1xuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhzdWJQYXJ0cywgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF1dG9Hcm91cCh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkgJiYgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuYVNpZ24uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnRBcltpXS5tYXRjaCgnXFxcXGQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBjdXJzb3IgcG9zaXRpb24gaW4gZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IHZhbHVlLm1hdGNoKGxlZnRSZWcpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3TGVmdFswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGp1c3QgYmVmb3JlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhhdCkpO1xuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICAgICAgICAgIGlmICghJGlucHV0ICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhlIHN0YXRpYyBjb25maWd1cmF0aW9uIG9iamVjdHMgb3V0IG9mIHRoYXQgYmxvY2ssIGFuZCBob2lzdCB0aGVtIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZpbGVcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2InLFxuICAgICAgICAgICAgICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdjaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAnY29uc3QnLFxuICAgICAgICAgICAgICAgICAgICAnZGQnLFxuICAgICAgICAgICAgICAgICAgICAnZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICdkZm4nLFxuICAgICAgICAgICAgICAgICAgICAnZHQnLFxuICAgICAgICAgICAgICAgICAgICAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAnaDEnLFxuICAgICAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgICAgICAgICAnaDQnLFxuICAgICAgICAgICAgICAgICAgICAnaDUnLFxuICAgICAgICAgICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgICAgICAgICAnaW5zJyxcbiAgICAgICAgICAgICAgICAgICAgJ2tkYicsXG4gICAgICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICAgICAgICAncScsXG4gICAgICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3NhbXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICd1JyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IEJvb2xlYW4odmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGBhU2NhbGVgIHNldHRpbmdzIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU2NhbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlRmFjdG9yID0gK3NldHRpbmdzLmFTY2FsZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlRGVjaW1hbCA9IChzZXR0aW5ncy5hU2NhbGVbMV0pID8gK3NldHRpbmdzLmFTY2FsZVsxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY2FsZVN1ZmZpeCA9IChzZXR0aW5ncy5hU2NhbGVbMl0pID8gc2V0dGluZ3MuYVNjYWxlWzJdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgICAgICAgICAgICBrZWVwT3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgbGV0IGhvbGRlciA9IGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gcm91dGluZSB0byBmb3JtYXQgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSA9PT0gZmFsc2UgJiYgc2V0dGluZ3MuYUZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IHRoZSBkZXYsIGJ1dCBub3QgZGlyZWN0bHkgYXMgYW4gYXR0cmlidXRlIGluIHRoZSBodG1sLCB0aGVuIGl0IHRha2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmVjZWRlbmNlIGFuZCBzaG91bGQgZ2V0IGZvcm1hdHRlZCBvbiBpbml0IChpZiB0aGF0IHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiBgc2V0dGluZ3MuYUZvcm1gKSkuIE5vdGU7IHRoaXMgaXMgdHJ1ZSB3aGF0ZXZlciB0aGUgZGV2ZWxvcGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBoYXMgc2V0IGZvciBgZGF0YS1hbi1kZWZhdWx0YCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMgOiBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgYW5EZWZhdWx0YCBhbHRvZ2V0aGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYUZvcm0gJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7IC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHRlc3RlZEN1cnJlbnRWYWx1ZSkgJiYgSW5maW5pdHkgIT09IHRlc3RlZEN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgdGVzdGVkQ3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBwYWdlIHJlbG9hZCBmcm9tIGJhY2sgYnV0dG9uLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAtIEFTUC5uZXQgZm9ybSBwb3N0IGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBleGFtcGxlOiA8YXNwOlRleHRCb3ggcnVuYXQ9XCJzZXJ2ZXJcIiBpZD1cInNvbWVJRFwiIHRleHQ9XCIxMjM0LjU2XCIgZGF0YS1hbi1kZWZhdWx0PVwiMTIzNC41NlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCcsIGJhc2VkIG9uIHRoZSBsb2NhbGUgdXNlZCBieSB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsICYmIHNldHRpbmdzLmFuRGVmYXVsdC50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgJHRoaXMuYXR0cigndHlwZScpID09PSAnaGlkZGVuJyAmJiAhJC5pc051bWVyaWMoY3VycmVudFZhbHVlLnJlcGxhY2UoJywnLCAnLicpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgIT09IG51bGwgJiYgc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTY2FsZSAmJiBzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gbmVnYXRpdmVCcmFja2V0KGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAoKHNldHRpbmdzLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnICE9PSAncCcpKSAmJiBzZXR0aW5ncy5hTmVnICE9PSAnJyAmJiBjb250YWlucyhjdXJyZW50VmFsdWUsICctJykpPyctJyArIGF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk6YXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLndFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoc2V0dGluZ3MuYVNpZ24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSAkdGhpcy50ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJ1bk9uY2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy9UT0RPIEV4dHJhY3QgdGhlIGV2ZW50IGxpc3RlbmVycyB0byBhbm90aGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gaW5wdXQgdHlwZXMgc3VwcG9ydGVkIFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXNpbi5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmICRzZXR0aW5ncy5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChuZWdhdGl2ZUJyYWNrZXQoJHRoaXMudmFsKCksICRzZXR0aW5ncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNpZ24gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuZURlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLmVEZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRzZXR0aW5ncy5hU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gYXV0b1N0cmlwKCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKSAhPT0gJHNldHRpbmdzLnJhd1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pblZhbCA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIuaW5WYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIuaW5WYWwsICRzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9uRW1wdHkgIT09IG51bGwgJiYgb25FbXB0eSAhPT0gJycpICYmICRzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXlkb3duLmF1dG9OdW1lcmljJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIC8vIFRoZSBjb2RlIGJlbG93IGFsbG93cyB0aGUgXCJlbnRlclwiIGtleWRvd24gdG8gdGhyb3cgYSBjaGFuZ2UoKSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5Q29kZS5FbnRlciAmJiBob2xkZXIuaW5WYWwgIT09ICR0aGlzLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2tpcEFsd2F5cyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50VmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93cyBpbnB1dCBldmVudCBpbiBkZWxldGlvbiBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigna2V5cHJlc3MuYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZml4IGZvciBTaGlmdCAmJiBpbnNlcnQgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5ICYmIGUua2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gaG9sZGVyLnByb2Nlc3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIucHJvY2Vzc0Fsd2F5cygpIHx8IGhvbGRlci5wcm9jZXNzS2V5cHJlc3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleXVwLmF1dG9OdW1lcmljJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IGhvbGRlci5za2lwQWx3YXlzKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFiID0gaG9sZGVyLmtkQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5rZENvZGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBjYXJldCB3aGVuIG9ubHkgdGhlIGN1cnJlbmN5IHNpZ24gaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzWzBdLnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWIgPT09IGtleUNvZGUuVGFiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAkdGhpcy52YWwoKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzWzBdLnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24gIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmVEZWMgIT09IG51bGwgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2ZvY3Vzb3V0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5vbk9mZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCAkc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MublNlcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2VwID0gJHNldHRpbmdzLm9TZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTaWduID0gJHNldHRpbmdzLm9TaWduO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5lRGVjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVBhZCA9ICRzZXR0aW5ncy5vUGFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5uQnJhY2tldCA9ICRzZXR0aW5ncy5vQnJhY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1N0cmlwKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsICRzZXR0aW5ncykgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZml4TnVtYmVyKHZhbHVlLCAkc2V0dGluZ3MuYURlYywgJHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5hU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyAkc2V0dGluZ3Muc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAoJHNldHRpbmdzLmFTY2FsZSAmJiAkc2V0dGluZ3MuYVNjYWxlWzFdKSA/ICskc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogJHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByZXNlbnROdW1iZXIodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3Mud0VtcHR5ID09PSAnemVybycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCgnMCcsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwZWRWYWx1ZSA9IGNoZWNrRW1wdHkodmFsdWUsICRzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IG9yaWdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9ICgkc2V0dGluZ3Muc2NhbGVTdWZmaXgpID8gZ3JvdXBlZFZhbHVlICsgJHNldHRpbmdzLnNjYWxlU3VmZml4IDogZ3JvdXBlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gaG9sZGVyLmluVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ3Bhc3RlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9GSVhNRSBBZnRlciBhIHBhc3RlLCB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSBmYXIgcmlnaHQgb2YgdGhlIGlucHV0LCBpdCBzaG91bGQgYmUgc2V0IHRvIHNvbWV0aGluZyBsaWtlIGBuZXdDYXJldFBvc2l0aW9uID0gb2xkQ2FyZXRQb3NpdGlvbiArIHBhc3RlVGV4dC5sZW5ndGg7YCwgd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9ycyBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9TdHJpcCh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5hRGVjLCAnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRSYXdWYWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBjdXJyZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RlZFRleHQgPSBwcmVwYXJlKGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChwYXN0ZWRUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcHJlcGFyZShwcmVmaXggKyBOdW1iZXIocGFzdGVkVGV4dCkudmFsdWVPZigpICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZChuZXdWYWx1ZSkgJiYgTnVtYmVyKG9sZFJhd1ZhbHVlKS52YWx1ZU9mKCkgIT09IE51bWJlcihuZXdWYWx1ZSkudmFsdWVPZigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jbG9zZXN0KCdmb3JtJykub24oJ3N1Ym1pdC5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy51blNldE9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byByZW1vdmUgc2V0dGluZ3MgYW5kIHN0b3AgYXV0b051bWVyaWMoKSAtIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJkZXN0cm95XCIpOyAvLyBkZXN0cm95cyBhdXRvTnVtZXJpY1xuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub2ZmKCcuYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIGNsZWFyIHRoZSB2YWx1ZSBhbmQgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcIndpcGVcIik7IC8vIHJlbW92ZXMgc2Vzc2lvbiBzdG9yYWdlIGFuZCBjb29raWVzIGZyb20gbWVtb3J5XG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHdpcGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5nc1xuICAgICAgICAgKiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGlmIG5lZWRlZFxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2FTZXA6IFwiLlwiLCBhRGVjOiBcIixcIiwgYVNpZ246ICfigqwgJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gdXBkYXRlcyB0aGUgc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwidXBkYXRlXCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY2FsZUZhY3RvciA9ICtzZXR0aW5ncy5hU2NhbGVbMF07XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlRGVjaW1hbCA9IChzZXR0aW5ncy5hU2NhbGVbMV0pID8gK3NldHRpbmdzLmFTY2FsZVsxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlU3VmZml4ID0gKHNldHRpbmdzLmFTY2FsZVsyXSkgPyBzZXR0aW5ncy5hU2NhbGVbMl0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2VlcE9yaWdpbmFsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09IHNldHRpbmdzLmFTZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYURlYzogXCIke3NldHRpbmdzLmFEZWN9XCIgYW5kIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwOiBcIiR7c2V0dGluZ3MuYVNlcH1cIiBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3NldCcsICd2YWx1ZScpOyAvLyBmb3JtYXRzIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXG4gICAgICAgICAqL1xuICAgICAgICBzZXQodmFsdWVJbikge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVJbiA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZCh2YWx1ZUluKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlSW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGJlaW5nIHNldCBpcyBub3QgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGlmICghJC5pc051bWVyaWMoTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCBoYXMgY2F1c2VkIGEgZXJyb3IgdG8gYmUgdGhyb3duYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmICghc2V0dGluZ3MuZURlYyB8fCAhc2V0dGluZ3MuYVNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IHNldHRpbmdzLnNjYWxlRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5hU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3RvciAmJiAoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCB8fCBzZXR0aW5ncy5hU2NhbGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3MgZm9yIHRoaXMgZWxlbWVudGAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gZ2V0IHRoZSB1bmZvcm1hdHRlZCB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIHBhcmFtZXRlclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpOyBubyBwYXJhbWV0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBsb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5hU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzLmFEZWMsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgTnVtZXJpYyBTdHJpbmdcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgcmV0dXJuIGBOdW1iZXIodmFsdWUpYCBzaW5jZSB0aGUgZ29hbCBvZiBgZ2V0YCBpcyB0byBnZXQgdGhlIHJhdyBqYXZhc2NyaXB0IHZhbHVlP1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0aGlzKSB8fCB0aGlzLmxlbmd0aCAhPT0gMSB8fCAhdGhpc1swXS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhdXRvTnVtZXJpYyBmdW5jdGlvblxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICAvL1RPRE8gRmlyc3QgdmFsaWRhdGUgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LCBiZWZvcmUgdXNpbmcgYGluaXRgICh3aXRoIGB2YWxpZGF0ZSgpYClcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2AsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyBhcmUgcHVibGljIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZzpcbiAgICAgKiBIVE1MNSBkYXRhIGF0dHJpYnV0ZXNcbiAgICAgKiBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcbiAgICAgKiBVc2UgalF1ZXJ5J3MgYCQuZXh0ZW5kYCBtZXRob2QgZm9yIGdsb2JhbCBjaGFuZ2VzIC0gYWxzbyBhIGdyZWF0IHdheSB0byBwYXNzIEFTUC5ORVQgY3VycmVudCBjdWx0dXJlIHNldHRpbmdzXG4gICAgICovXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyogYWxsb3dlZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgICAgICogYXBvc3Ryb3BoZSBpcyBlc2NhcGVkID0gXCJcXFwiXCJcbiAgICAgICAgICogc3BhY2UgPSBcIiBcIlxuICAgICAgICAgKiBub25lID0gXCJcIlxuICAgICAgICAgKiBOT1RFOiBkbyBub3QgdXNlIG51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgYVNlcDogJywnLFxuXG4gICAgICAgIC8qIHdoZW4gdHJ1ZSA9PiB3aGVuIHRoZSBpbnB1dCBoYXMgZm9jdXMgb25seSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgblNlcDogZmFsc2UsXG5cbiAgICAgICAgLyogZGlnaXRhbCBncm91cGluZyBmb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB1c2VkIGluIEZvcm1hdFxuICAgICAgICAgKiBkR3JvdXA6IFwiMlwiLCByZXN1bHRzIGluIDk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzXG4gICAgICAgICAqIGRHcm91cDogXCIyc1wiLCByZXN1bHRzIGluIDk5LDk5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtocyBzY2FsZWRcbiAgICAgICAgICogZEdyb3VwOiBcIjNcIiwgcmVzdWx0cyBpbiA5OTksOTk5LDk5OSBkZWZhdWx0XG4gICAgICAgICAqIGRHcm91cDogXCI0XCIsIHJlc3VsdHMgaW4gOTk5OSw5OTk5LDk5OTkgdXNlZCBpbiBzb21lIEFzaWFuIGNvdW50cmllc1xuICAgICAgICAgKi9cbiAgICAgICAgZEdyb3VwOiAnMycsXG5cbiAgICAgICAgLyogYWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgICAgICogY29tbWEgPSBcIixcIlxuICAgICAgICAgKi9cbiAgICAgICAgYURlYzogJy4nLFxuXG4gICAgICAgIC8qIGFsbG93IHRvIGRlY2xhcmUgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Igd2hpY2ggaXMgYXV0b21hdGljYWxseSByZXBsYWNlZCBieSBhRGVjXG4gICAgICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICogYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlIGEgcGVyaW9kICdmdWxsIHN0b3AnIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlcnMgKFNwYWluIGlzIGFuIGV4YW1wbGUpXG4gICAgICAgICAqL1xuICAgICAgICBhbHREZWM6IG51bGwsXG5cbiAgICAgICAgLyogYVNpZ24gPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxuICAgICAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBhU2lnbjogXCIkXCJcbiAgICAgICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICckICdcbiAgICAgICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyAkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYVNpZ246ICcnLFxuXG4gICAgICAgIC8qIHBTaWduID0gcGxhY2VtZW50IG9mIGN1cnJlbmN5IHNpZ24gYXMgYSBwPXByZWZpeCBvciBzPXN1ZmZpeFxuICAgICAgICAgKiBmb3IgcHJlZml4IHBTaWduOiBcInBcIiAoZGVmYXVsdClcbiAgICAgICAgICogZm9yIHN1ZmZpeCBwU2lnbjogXCJzXCJcbiAgICAgICAgICovXG4gICAgICAgIHBTaWduOiAncCcsXG5cbiAgICAgICAgLyogcGxhY2VtZW50IG9mIG5lZ2F0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGFTaWduIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcbiAgICAgICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgICogLSQxLDIzNC41NiA9PiB7YVNpZ246IFwiJFwifVxuICAgICAgICAgKiAkLTEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwiclwifVxuICAgICAgICAgKiAtMSwyMzQuNTYkID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJwXCJ9XG4gICAgICAgICAqIDEsMjM0LjU2LSAgPT4ge3BOZWc6IFwic1wifVxuICAgICAgICAgKiAkMSwyMzQuNTYtID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwic1wifVxuICAgICAgICAgKiAxLDIzNC41Ni0kID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIn1cbiAgICAgICAgICogMSwyMzQuNTYkLSA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCIsIHBOZWc6IFwiclwifVxuICAgICAgICAgKi9cbiAgICAgICAgcE5lZzogJ2wnLFxuXG4gICAgICAgIC8qIEFkZGl0aW9uYWwgc3VmZml4XG4gICAgICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTdWZmaXg6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBhU3VmZml4OiAnIGRvbGxhcnMnXG4gICAgICAgICAqIE51bWVyaWMgY2hhcmFjdGVycyBhbmQgbmVnYXRpdmUgc2lnbiBub3QgYWxsb3dlZCdcbiAgICAgICAgICovXG4gICAgICAgIGFTdWZmaXg6ICcnLFxuXG4gICAgICAgIC8qIE92ZXJyaWRlIG1pbiBtYXggbGltaXRzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiY2VpbGluZ1wiIGFkaGVyZXMgdG8gdk1heCBhbmQgaWdub3JlcyB2TWluIHNldHRpbmdzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIHZNaW4gYW5kIGlnbm9yZXMgdk1heCBzZXR0aW5nc1xuICAgICAgICAgKiBvTGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCB2TWluICYgdk1heFxuICAgICAgICAgKi9cbiAgICAgICAgb0xpbWl0czogbnVsbCxcblxuICAgICAgICAvKiBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBsYXJnZXIgdGhhbiB2TWluXG4gICAgICAgICAqL1xuICAgICAgICB2TWF4OiAnOTk5OTk5OTk5OTk5OS45OScsXG5cbiAgICAgICAgLyogbWluaW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgc21hbGxlciB0aGFuIHZNYXhcbiAgICAgICAgICovXG4gICAgICAgIHZNaW46ICctOTk5OTk5OTk5OTk5OS45OScsXG5cbiAgICAgICAgLyogTWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgPSB1c2VkIHRvIG92ZXJyaWRlIGRlY2ltYWwgcGxhY2VzIHNldCBieSB0aGUgdk1pbiAmIHZNYXggdmFsdWVzXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGV4YW1wbGUgbURlYzogXCIzXCIsXG4gICAgICAgICAqL1xuICAgICAgICBtRGVjOiBudWxsLFxuXG4gICAgICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAgICAgKiB7ZURlYzogXCI1XCJ9IGFuZCB0aGUgZGVmYXVsdCAyIGRlY2ltYWwgcGxhY2VzIHdpdGggZm9jdXMgXCIxLDAwMC4xMjM0NVwiIHdpdGhvdXQgZm9jdXMgXCIxLDAwMC4xMlwiIHRoZSByZXN1bHRzIGRlcGVuZHMgb24gdGhlIHJvdW5kaW5nIG1ldGhvZCB1c2VkXG4gICAgICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgKi9cbiAgICAgICAgZURlYzogbnVsbCxcblxuICAgICAgICAvKiBTY2FsZWQgbnVtYmVyIGRpc3BsYXllZCB3aGVuIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXMgZXhhbXBsZSB3aXRoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAqIHthU2NhbGU6IFtcIjEwMDBcIiwgXCIwXCIsIFwiS1wiXX0gID0+IHdpdGggZm9jdXMgXCIxLDAwMC4wMFwiIHdpdGhvdXQgZm9jdXMgXCIxS1wiXG4gICAgICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxuICAgICAgICAgKiBkaXZpc29yIHZhbHVlIC0gZG9lcyBub3QgbmVlZCB0byBiZSB3aG9sZSBudW1iZXIgLSBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSBhbmQgc2NhbGVkIHZhbHVlLlxuICAgICAgICAgKiBkZWNpbWFsIHBsYWNlcyBcIm9wdGlvbmFsXCIgd2hlbiBub3QgaW4gZm9jdXMgLSBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyBmb2N1c1xuICAgICAgICAgKiBTeW1ib2wgXCJvcHRpb25hbFwiIGRpc3BsYXllZCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzIC0gTk9URTogaWYgYSBzeW1ib2wgaXMgdXNlZCB5b3UgTVVTVCBhbHNvIHNwZWNpZnkgdGhlIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGV4YW1wbGUgbURlYzogXCIzXCJcbiAgICAgICAgICovXG4gICAgICAgIGFTY2FsZTogbnVsbCxcblxuICAgICAgICAvKiBTZXQgdG8gdHJ1ZSB0byBhbGxvdyB0aGUgZURlYyB2YWx1ZSB0byBiZSBzYXZlZCB3aXRoIHNlc3Npb25TdG9yYWdlXG4gICAgICAgICAqIGlmIGllIDYgb3IgNyB0aGUgdmFsdWUgd2lsbCBiZSBzYXZlZCBhcyBhIHNlc3Npb24gY29va2llXG4gICAgICAgICAqL1xuICAgICAgICBhU3RvcjogZmFsc2UsXG5cbiAgICAgICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICAgICAqIG1Sb3VuZDogXCJTXCIsIFJvdW5kLUhhbGYtVXAgU3ltbWV0cmljIChkZWZhdWx0KVxuICAgICAgICAgKiBtUm91bmQ6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcbiAgICAgICAgICogbVJvdW5kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAgICAgKiBtUm91bmQ6IFwiYVwiLCBSb3VuZC1IYWxmLURvd24gQXN5bW1ldHJpYyAobG93ZXIgY2FzZSBhKVxuICAgICAgICAgKiBtUm91bmQ6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcbiAgICAgICAgICogbVJvdW5kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICAgICAqIG1Sb3VuZDogXCJEXCIsIFJvdW5kIERvd24gXCJSb3VuZC1Ub3dhcmQtWmVyb1wiIC0gc2FtZSBhcyB0cnVuY2F0ZVxuICAgICAgICAgKiBtUm91bmQ6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcbiAgICAgICAgICogbVJvdW5kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAgICAgKiBtUm91bmQ6IFwiTjA1XCIgUm91bmRzIHRvIHRoZSBuZWFyZXN0IC4wNSA9PiBzYW1lIGFzIFwiQ0hGXCIgdXNlZCBpbiAxLjlYIGFuZCBzdGlsbCB2YWxpZFxuICAgICAgICAgKiBtUm91bmQ6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XG4gICAgICAgICAqIG1Sb3VuZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAgICAgKi9cbiAgICAgICAgbVJvdW5kOiAncycsXG5cbiAgICAgICAgLyogY29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXG4gICAgICAgICAqIGFQYWQ6IHRydWUgLSBhbHdheXMgUGFkIGRlY2ltYWxzIHdpdGggemVyb3NcbiAgICAgICAgICogYVBhZDogZmFsc2UgLSBkb2VzIG5vdCBwYWQgd2l0aCB6ZXJvcy5cbiAgICAgICAgICogTm90ZTogc2V0dGluZyBhUGFkIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ21EZWMnIHNldHRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBhUGFkOiB0cnVlLFxuXG4gICAgICAgIC8qIEFkZHMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzIChpZS4gdHJhbnNmb3JtcyAnLSQgOTk5Ljk5JyB0byAnKDk5OS45OSknKVxuICAgICAgICAgKiBUaG9zZSBicmFja2V0cyBhcmUgdmlzaWJsZSBvbmx5IHdoZW4gdGhlIGZpZWxkIGRvZXMgTk9UIGhhdmUgdGhlIGZvY3VzLlxuICAgICAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAgICAgKiBuQnJhY2tldDogbnVsbCAtIChkZWZhdWx0KVxuICAgICAgICAgKiBuQnJhY2tldDogJygsKScsIG5CcmFja2V0OiAnWyxdJywgbkJyYWNrZXQ6ICc8LD4nIG9yIG5CcmFja2V0OiAneyx9J1xuICAgICAgICAgKi9cbiAgICAgICAgbkJyYWNrZXQ6IG51bGwsXG5cbiAgICAgICAgLyogRGlzcGxheWVkIG9uIGVtcHR5IHN0cmluZyBcIlwiXG4gICAgICAgICAqIHdFbXB0eTogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgICAgICogd0VtcHR5OiBcInByZXNzXCIgLSBjdXJyZW5jeSBzaWduIGRpc3BsYXlzIG9uIGFueSBrZXkgYmVpbmcgcHJlc3NlZFxuICAgICAgICAgKiB3RW1wdHk6IFwiYWx3YXlzXCIgLSBhbHdheXMgZGlzcGxheXMgdGhlIGN1cnJlbmN5IHNpZ24gb25seVxuICAgICAgICAgKiB3RW1wdHk6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICovXG4gICAgICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIHRvIGRpc3BsYXkgdGhlIGN1cnJlbmN5IHNpZ24gb25seSBvbiBob3ZlciAoaWYgdGhlIGlucHV0IGlzIGVtcHR5KVxuICAgICAgICB3RW1wdHk6ICdmb2N1cycsXG5cbiAgICAgICAgLyogY29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICAgICAqIGxaZXJvOiBcImFsbG93XCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gWmVyb3Mgd2lsbCBiZSB0cnVuY2F0ZWQgd2hlbiBlbnRlcmluZyBhZGRpdGlvbmFsIGRpZ2l0cy4gT24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSBkZWxldGVkLlxuICAgICAgICAgKiBsWmVybzogXCJkZW55XCIsIC0gYWxsb3dzIG9ubHkgb25lIGxlYWRpbmcgemVybyBvbiB2YWx1ZXMgbGVzcyB0aGFuIG9uZVxuICAgICAgICAgKiBsWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGxaZXJvOiAnYWxsb3cnLFxuXG4gICAgICAgIC8qIGRldGVybWluZSBpZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIGZvcm1hdHRlZCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogdHJ1ZSA9IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgYUZvcm06IHRydWUsXG5cbiAgICAgICAgLyogZGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QgYWxsIGtleWJvYXJkIGNvbW1hbmQgd2lsbCBzZWxlY3RcbiAgICAgICAgICogdGhlIGNvbXBsZXRlIGlucHV0IHRleHQgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxuICAgICAgICAgKiBpZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgc051bWJlcjogZmFsc2UsXG5cbiAgICAgICAgLyogaGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAgICAgKiBzaG91bGQgYmUgdGhlIHZhbHVlIG9mIHRoZSB1bmZvcm1hdHRlZCBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAqIGV4YW1wbGVzOlxuICAgICAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2FuRGVmYXVsdDogXCJcIn1cbiAgICAgICAgICogdmFsdWU9MTIzNC41NiB7YW5EZWZhdWx0OiAnMTIzNC41Nid9XG4gICAgICAgICAqL1xuICAgICAgICBhbkRlZmF1bHQ6IG51bGwsXG5cbiAgICAgICAgLyogcmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxuICAgICAgICAgKiB0aGlzIG91dHB1dCBmb3JtYXQ6IHBvc2l0aXZlIG5ubm4ubm4sIG5lZ2F0aXZlIC1ubm5uLm5uXG4gICAgICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcbiAgICAgICAgICovXG4gICAgICAgIHVuU2V0T25TdWJtaXQ6IGZhbHNlLFxuXG4gICAgICAgIC8qIGFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICAgICAqIG51bGwgPT4gbm5ubi5ubiBvciAtbm5ubi5ubiBkZWZhdWx0XG4gICAgICAgICAqIFwiLFwiICA9PiBubm5uLG5uIG9yIC1ubm5uLG5uIGNhbiBhbHNvIGJlIFwiLSxcIlxuICAgICAgICAgKiBcIi4tXCIgPT4gbm5ubi5ubiBvciBubm5uLm5uLVxuICAgICAgICAgKiBcIiwtXCIgPT4gbm5ubixubiBvciBubm5uLG5uLVxuICAgICAgICAgKi9cbiAgICAgICAgbG9jYWxlT3V0cHV0OiBudWxsLFxuXG4gICAgICAgIC8qIGVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uXG4gICAgICAgICAqIHRydWUgPT4gYWxsIGVycm9ycyBhcmUgdGhyb3duIC0gaGVscGZ1bCBpbiBzaXRlIGRldmVsb3BtZW50XG4gICAgICAgICAqIGZhbHNlID0+IHRocm93cyBlcnJvcnMgd2hlbiBjYWxsaW5nIG1ldGhvZHMgcHJpb3IgdG8gdGhlIHN1cHBvcnRlZCBlbGVtZW50IGhhcyBiZWVuIGluaXRpYWxpemVkIGJlIGF1dG9OdW1lcmljXG4gICAgICAgICAqL1xuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgfTtcblxuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzO1xuXG4gICAgLyoqXG4gICAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50IHRyaWdnZXJcbiAgICAgKi9cbiAgICBhdXRvRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZNYXggPSBzZXR0aW5ncy52TWF4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGNvbnN0IHZNaW4gPSAoIXNldHRpbmdzLnZNaW4gJiYgc2V0dGluZ3Mudk1pbiAhPT0gMCkgPyBbXSA6IHNldHRpbmdzLnZNaW4udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcblxuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBzZW5kQ3VzdG9tRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3NgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdXRvVW5Gb3JtYXQgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NhbGVPdXRwdXQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLmxvY2FsZU91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBkZWJ1ZyA9IHRydWU7IC8vIFRoZSBlcnJvciBoZXJlIG11c3QgYWx3YXlzIGJlIHRocm93biwgc2luY2UgYSBiYWRseSBjb25maWd1cmVkIG9wdGlvbnMgb2JqZWN0IHdpbGwgbGVhZCB0byB3cm9uZyByZXN1bHRzLCBpZiBhbnkuXG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIWlzT2JqZWN0KHVzZXJPcHRpb25zKSB8fCBpc0VtcHR5T2JqKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB1c2VyIGNhbiBjaG9vc2UgaWYgdGhlIGB1c2VyT3B0aW9uc2AgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIG9yIG5vdFxuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1c2VyT3B0aW9ucztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5hU2VwLCBbJywnLCAnLicsICcgJywgJyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhU2VwJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcsJywgJy4nLCAnICcgb3IgZW1wdHkgKCcnKSwgWyR7b3B0aW9ucy5hU2VwfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMublNlcCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5TZXApKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgJ25TZXAnIG9wdGlvbiBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5uU2VwfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZEdyb3VwKSkgeyAvLyBpc05hTihwYXJzZUludChvcHRpb25zLmRHcm91cCkpIC8vREVCVUdcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaWdpdGFsIGdyb3VwaW5nIGZvciB0aG91c2FuZCBzZXBhcmF0b3Igb3B0aW9uICdkR3JvdXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRHcm91cH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuYURlYywgWycsJywgJy4nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJyBvciAnLCcsIFske29wdGlvbnMuYURlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuYURlYyA9PT0gb3B0aW9ucy5hU2VwKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnYURlYycgWyR7b3B0aW9ucy5hRGVjfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2FTZXAnIFske29wdGlvbnMuYVNlcH1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbHREZWMpICYmICFpc1N0cmluZyhvcHRpb25zLmFsdERlYykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhbHRlcm5hdGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYWx0RGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmFsdERlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFTaWduICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hU2lnbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdhU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hU2lnbn1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucFNpZ24sIFsncCcsICdzJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAncFNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMucFNpZ259XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnBOZWcsIFsncCcsICdzJywgJ2wnLCAnciddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgbmVnYXRpdmUgc2lnbiBvcHRpb24gJ3BOZWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpIG9yICdyJyAocmlnaHQpLCBbJHtvcHRpb25zLnBOZWd9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyA9IC9bMC05XSsvO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuYVN1ZmZpeCkgfHwgKG9wdGlvbnMuYVN1ZmZpeCAhPT0gJycgJiYgKGNvbnRhaW5zKG9wdGlvbnMuYVN1ZmZpeCwgJy0nKSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuYVN1ZmZpeCkpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnYVN1ZmZpeCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuYVN1ZmZpeH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub0xpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm9MaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb0xpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm9MaW1pdHN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcbiAgICAgICAgY29uc3QgdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspPyQvO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMudk1heCkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy52TWF4KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICd2TWF4JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy52TWF4fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNaW4pIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1pbikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1pbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1pbn1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMudk1pbikgPiBwYXJzZUZsb2F0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ3ZNaW4nIFske29wdGlvbnMudk1pbn1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiYgKCFpc1N0cmluZyhvcHRpb25zLm1EZWMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5tRGVjKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ21EZWMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLm1EZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYVBhZCAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FQYWQnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnbURlYycgc2V0dGluZyBbJHtvcHRpb25zLm1EZWN9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBhIHdhcm5pbmcgbWVzc2FnZSBpbiB0aGUgY29uc29sZSBpZiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgaW4gdk1pbi92TWF4IGlzIG92ZXJyaWRkZW4gYnkgbURlYyAoYW5kIG5vdCBpZiBtRGVjIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZGVjaW1hbCB1c2VkIGluIHZNaW4vdk1heClcbiAgICAgICAgbGV0IGRwVk1pbiA9IGRlY2ltYWxQbGFjZXMob3B0aW9ucy52TWluKTtcbiAgICAgICAgbGV0IGRwVk1heCA9IGRlY2ltYWxQbGFjZXMob3B0aW9ucy52TWF4KTtcbiAgICAgICAgZHBWTWluID0gaXNOdWxsKGRwVk1pbik/MDpkcFZNaW47XG4gICAgICAgIGRwVk1heCA9IGlzTnVsbChkcFZNYXgpPzA6ZHBWTWF4O1xuICAgICAgICBjb25zdCB2TWluTWF4RGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KGRwVk1pbiwgZHBWTWF4KTtcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5tRGVjKSAmJlxuICAgICAgICAgICAgKChoYXNEZWNpbWFscyhvcHRpb25zLnZNaW4pIHx8IGhhc0RlY2ltYWxzKG9wdGlvbnMudk1heCkpICYmIHZNaW5NYXhEZWNpbWFsUGxhY2VzICE9PSBOdW1iZXIob3B0aW9ucy5tRGVjKSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ21EZWMnIHRvIFske29wdGlvbnMubURlY31dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICd2TWluJyBbJHtvcHRpb25zLnZNaW59XSBhbmQgJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZURlYykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmVEZWMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5lRGVjKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdlRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5lRGVjfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImVEZWNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcIm1EZWNcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICFpc051bGwob3B0aW9ucy5tRGVjKSAmJiBOdW1iZXIob3B0aW9ucy5tRGVjKSA8IE51bWJlcihvcHRpb25zLmVEZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZURlYycgWyR7b3B0aW9ucy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSAnbURlYycgWyR7b3B0aW9ucy5tRGVjfV0gdmFsdWUuYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9GSVhNRSBGaW5pc2ggdGhlIGFTY2FsZSogb3B0aW9uc1xuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFTdG9yKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdhU3RvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYVN0b3J9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm1Sb3VuZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAnbVJvdW5kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMubVJvdW5kfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYVBhZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFQYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY29udHJvbCBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhUGFkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hUGFkfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uQnJhY2tldCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm5CcmFja2V0LCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduQnJhY2tldCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uQnJhY2tldH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMud0VtcHR5LCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICd3RW1wdHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy53RW1wdHl9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmxaZXJvLCBbJ2FsbG93JywgJ2RlbnknLCAna2VlcCddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxaZXJvfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYUZvcm0pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hRm9ybSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdhRm9ybScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYUZvcm19XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zTnVtYmVyKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc051bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzTnVtYmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zTnVtYmVyfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbkRlZmF1bHQpICYmIChvcHRpb25zLmFuRGVmYXVsdCAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5hbkRlZmF1bHQpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdhbkRlZmF1bHQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLmFuRGVmYXVsdH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuU2V0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51blNldE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuU2V0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuU2V0T25TdWJtaXR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmxvY2FsZU91dHB1dCkgJiYgIWlzSW5BcnJheShvcHRpb25zLmxvY2FsZU91dHB1dCwgW1xuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ2xvY2FsZU91dHB1dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgZW1wdHksICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMubG9jYWxlT3V0cHV0fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZGVidWcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5kZWJ1ZykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2RlYnVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5kZWJ1Z31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlU2V0dGluZ3NWYWxpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICAvKiBsZXQgZXZlbnRJbmZvID0gbmV3IEN1c3RvbUV2ZW50SW5pdCgpOyAvL1RoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCwgYnV0IElFIGRvZXMgbm90IHN1cHBvcnQgJ0N1c3RvbUV2ZW50SW5pdCcgeWV0XG4gICAgICAgIGV2ZW50SW5mby5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9KSgpO1xufSkpO1xuXG4vKipcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxuICAgIGdldERlZmF1bHRDb25maWcsXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxuICAgIGFyZVNldHRpbmdzVmFsaWQsIC8vYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xuXG4gICAgLy9UT0RPIENvbXBsZXRlIHRoZSBpbnRlcmZhY2Ugd2l0aCBmdW5jdGlvbnMgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyA6XG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxuICAgIC8vc2V0ICAgICAgICAgIDogYW4uc2V0KHZhbHVlLCBpbnB1dClcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxuICAgIC8vZ2V0Rm9ybWF0dGVkIDogYW4uZ2V0Rm9ybWF0dGVkKGlucHV0KVxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cbiAgICAvL3NldHRpbmdzICAgICA6IGFuLnNldHRpbmdzKGlucHV0KVxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcbiAgICAvL2Rlc3Ryb3kgICAgICA6IGFuLmRlc3Ryb3koaW5wdXQpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-16 UTC-10 23:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the given parameter is as String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle) || needle === '' || needle === null) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message, debug) {\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n        if (settings.scaleDecimal) {\n            settings.mDec = settings.scaleDecimal;\n        }\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * converts the ISO numeric string to the locale decimal and minus sign placement\n     * see \"localeOutput\" option for determine\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        if (typeof settings.aPad === 'boolean' || settings.aPad === null) {\n            rDec = settings.aPad ? settings.mDec : 0;\n        } else {\n            rDec = Number(settings.aPad);\n        }\n\n        // Checks if the iv (input Value)is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // removes the negative sign will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // append a zero if first character is not a digit (then it is likely to be a dot\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // determines if the value is zero - if zero no negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // trims leading zero's needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // checks decimal places to determine if rounding is required :\n        // check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 's' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'A' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'A' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // return rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * truncates the decimal part of a number\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function originalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n\n        return settings;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i, miniParts) {\n                    miniParts = formParts[i].split('=');\n                    var scElement = $.inArray(i, scIndex);\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (miniParts[1] !== null) {\n                                miniParts[1] = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = miniParts.join('=');\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attached the settings (default and options passed as a parameter\n         * $(someSelector).autoNumeric('init');           // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {option}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric();                 // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric({option});         // initiate autoNumeric with options\n         * options passes as a parameter example '{aSep: \".\", aDec: \",\", aSign: '€ '}\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // attempt to grab HTML5 data, if they don't exist we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // attempt to grab \"autoNumeric\" settings, if they don't exist returns \"undefined\"\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab settings, create them from defaults and passed options\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u']\n                    });\n\n                    // Merge defaults, tagData and options\n                    if (settings.aDec === settings.aSep) {\n                        throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                    }\n\n                    $.each(settings, function (key, value) {\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n                        if (typeof value === 'number' && key !== 'aScale') {\n                            settings[key] = value.toString();\n                        }\n                    });\n\n                    if (settings.aScale !== null) {\n                        settings.scaleFactor = +settings.aScale[0];\n                        settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                        settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                    }\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec & nSep options are being used\n                settings = originalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                // checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric', settings.debug);\n                }\n\n                // checks for non-supported tags\n                if (!isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.prop('tagName').toLowerCase() !== 'input') {\n                    throwError('The <' + $this.prop('tagName').toLowerCase() + '> tag is not supported by autoNumeric', settings.debug);\n                }\n\n                //TODO Replace the two next tests with a `validateOptions()` function\n                // checks if the decimal and thousand are characters are the same\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                }\n\n                // checks the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n                if (settings.eDec < settings.mDec && settings.eDec !== null) {\n                    throwError('autoNumeric will not function properly when the extended decimal places eDec [' + settings.eDec + '] is greater than the mDec [' + settings.mDec + '] value', settings.debug);\n                }\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n                        /* checks for page reload from back button\n                         * also checks for ASP.net form post back\n                         * the following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                         * example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                         */\n                        if (settings.anDefault && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                            if (settings.eDec && settings.aStor) {\n                                settings.rawValue = autoSave($this, settings, 'get');\n                            }\n                            if (settings.aScale && settings.aStor) {\n                                settings.rawValue = autoSave($this, settings, 'get');\n                            }\n                            if (!settings.aStor) {\n                                var toStrip = void 0;\n                                if (settings.nBracket !== null && settings.aNeg !== '') {\n                                    settings.onOff = true;\n                                    toStrip = negativeBracket(currentValue, settings);\n                                } else {\n                                    toStrip = currentValue;\n                                }\n                                settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                            }\n                            setValue = false;\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                        }\n\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.aScale) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n                            $this.change();\n                            holder.inVal = $this.val();\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.aScale) {\n                                    value = value / $settings.scaleFactor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.aScale && $settings.aScale[1] ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSuffix ? groupedValue + $settings.scaleSuffix : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * method to update settings - can be call as many times\n         * $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         * options passed as a parameter example '{aSep: \".\", aDec: \",\", aSign: '€ '}\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n                if (settings.aScale !== null) {\n                    settings.scaleFactor = +settings.aScale[0];\n                    settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                    settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                }\n                settings = originalSettings(settings);\n                getHolder($this, settings, true);\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (!settings.eDec || !settings.aScale)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.aScale && !settings.onOff) {\n                                value = value / settings.scaleFactor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.aScale === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec !== null || settings.aScale !== null)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSuffix) {\n                    value = value + settings.scaleSuffix;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.aScale) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            //TODO Make sure `this[0]` exists as well as `.value` before trying to access those\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * autoNumeric function\n     */\n    $.fn.autoNumeric = function (method) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n        }\n\n        if (methods[method]) {\n            return methods[method].apply(this, args);\n        }\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            return methods.init.apply(this, args);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /**\n     * Defaults are public - these can be overridden by the following:\n     * HTML5 data attributes\n     * Options passed by the 'init' or 'update' methods\n     * Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n     */\n    $.fn.autoNumeric.defaults = {\n        /* allowed thousand separator characters\n         * comma = \",\"\n         * period \"full stop\" = \".\"\n         * apostrophe is escaped = \"\\\"\"\n         * space = \" \"\n         * none = \"\"\n         * NOTE: do not use numeric characters\n         */\n        aSep: ',',\n\n        /* when true => when the input has focus only the decimal character is visible\n         */\n        nSep: false,\n\n        /* digital grouping for the thousand separator used in Format\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n         * dGroup: \"3\", results in 999,999,999 default\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n         */\n        dGroup: '3',\n\n        /* allowed decimal separator characters\n         * period \"full stop\" = \".\"\n         * comma = \",\"\n         */\n        aDec: '.',\n\n        /* allow to declare alternative decimal separator which is automatically replaced by aDec\n         * developed for countries the use a comma \",\" as the decimal character\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\n         * Must be in quotes aSign: \"$\"\n         * space to the right of the currency symbol aSign: '$ '\n         * space to the left of the currency symbol aSign: ' $'\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\n         * for prefix pSign: \"p\" (default)\n         * for suffix pSign: \"s\"\n         */\n        pSign: 'p',\n\n        /* placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n         * -1,234.56  => default no options required\n         * -$1,234.56 => {aSign: \"$\"}\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n         * 1,234.56-  => {pNeg: \"s\"}\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n         * Numeric characters and negative sign not allowed'\n         */\n        aSuffix: '',\n\n        /* override min max limits'\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n         * oLimits: \"ignore\" ignores both vMin & vMax\n         */\n        oLimits: null,\n\n        /* maximum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be larger than vMin\n         */\n        vMax: '9999999999999.99',\n\n        /* minimum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be smaller than vMax\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n         * value must be enclosed in quotes example mDec: \"3\",\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n         * the \"get\" method returns the extended decimal places\n         */\n        eDec: null,\n\n        /* Scaled number displayed when input does not have focus example with the following:\n         * {aScale: [\"1000\", \"0\", \"K\"]}  => with focus \"1,000.00\" without focus \"1K\"\n         * [\"divisor\", \"decimal places\", \"symbol\"]\n         * divisor value - does not need to be whole number - please understand that Javascript has limited accuracy in math\n         * the \"get\" method returns the full value and scaled value.\n         * decimal places \"optional\" when not in focus - if omitted the decimal places will be the same when the input has focus\n         * Symbol \"optional\" displayed when the input does not have focus - NOTE: if a symbol is used you MUST also specify the decimal places\n         * value must be enclosed in quotes example mDec: \"3\"\n         */\n        aScale: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\n         * if ie 6 or 7 the value will be saved as a session cookie\n         */\n        aStor: false,\n\n        /* method used for rounding\n         * mRound: \"s\", Round-Half-Up Symmetric (default)\n         * mRound: \"A\", Round-Half-Up Asymmetric\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n         * mRound: \"A\", Round-Half-Down Asymmetric (lower case a)\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n         * mRound: \"U05\" Rounds up to next .05\n         * mRound: \"D05\" Rounds down to next .05\n         */\n        mRound: 's',\n\n        /* controls decimal padding\n         * aPad: true - always Pad decimals with zeros\n         * aPad: false - does not pad with zeros.\n         * aPad: `some number` - pad decimals with zero to number different from mDec\n         * thanks to Jonas Johansson for the suggestion\n         */\n        aPad: true,\n\n        /* places brackets on negative value -$ 999.99 to (999.99)\n         * visible only when the field does NOT have focus the left and right symbols should be enclosed in quotes and separated by a comma\n         * nBracket: null - (default)\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\n         * wEmpty: \"always\" - always displays the currency sign only\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n         */\n        wEmpty: 'focus',\n\n        /* controls leading zero behavior\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n         * lZero: \"deny\", - allows only one leading zero on values less than one\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n         */\n        lZero: 'allow',\n\n        /* determine if the default value will be formatted on page ready.\n         * true = automatically formats the default value on page ready\n         * false = will not format the default value\n         */\n        aForm: true,\n\n        /* determine if the select all keyboard command will select\n         * the complete input text or only the input numeric value\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n         */\n        sNumber: false,\n\n        /* helper option for ASP.NET postback\n         * should be the value of the unformatted default value\n         * examples:\n         * no default value=\"\" {anDefault: \"\"}\n         * value=1234.56 {anDefault: '1234.56'}\n         */\n        anDefault: null,\n\n        /* removes formatting on submit event\n         * this output format: positive nnnn.nn, negative -nnnn.nn\n         * review the 'unSet' method for other formats\n         */\n        unSetOnSubmit: false,\n\n        /* allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n         * null => nnnn.nn or -nnnn.nn default\n         * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n         * \".-\" => nnnn.nn or nnnn.nn-\n         * \",-\" => nnnn,nn or nnnn,nn-\n         */\n        localeOutput: null,\n\n        /* error handling function\n         * true => all errors are thrown - helpful in site development\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\n        eventInfo.detail = detail;\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig\n\n};\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJpc1VuZGVmaW5lZCIsInZhbHVlIiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImlzQXJyYXkiLCJhcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJBcnJheSIsIkVycm9yIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibGVuZ3RoIiwidGV4dCIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJkZWJ1ZyIsInJ1bkNhbGxiYWNrcyIsIiR0aGlzIiwic2V0dGluZ3MiLCIkIiwiZWFjaCIsInZhbCIsImF1dG9OdW1lcmljIiwiZGVjTGVuZ3RoIiwidk1pbiIsInZNYXgiLCJ2TWF4TGVuZ3RoIiwidk1pbkxlbmd0aCIsIk1hdGgiLCJtYXgiLCJhdXRvQ29kZSIsInNwbGl0IiwiYU5lZyIsInJlcGxhY2UiLCJtSW50UG9zIiwibUludE5lZyIsIm1EZWMiLCJvRGVjIiwiTnVtYmVyIiwic2NhbGVEZWNpbWFsIiwiYWx0RGVjIiwiYURlYyIsImFTZXAiLCJhTmVnUmVnIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsInNraXBGaXJzdEF1dG9TdHJpcCIsIlJlZ0V4cCIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZCIsImFsbG93ZWRBdXRvU3RyaXAiLCJudW1SZWdBdXRvU3RyaXAiLCJhdXRvU3RyaXAiLCJhU2lnbiIsImFTdWZmaXgiLCJwTmVnIiwicFNpZ24iLCJ0cmFpbGluZ05lZ2F0aXZlIiwibWF0Y2giLCJqb2luIiwibFplcm8iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwiZGVjaW1hbFBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwiY2hhckF0Iiwic2xpY2UiLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwibkJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpdiIsInNpZ25PbkVtcHR5Iiwid0VtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnIiwiZGlnaXRhbEdyb3VwIiwiZEdyb3VwIiwidGVzdCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsIml2Um91bmRlZCIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsIm1Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwicmVzdWx0IiwiYVBhZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsIm9MaW1pdHMiLCJhdXRvR2V0Iiwib2JqIiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiaG9sZGVyIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJvcmlnaW5hbFNldHRpbmdzIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImF1dG9TYXZlIiwidG9EbyIsImFTdG9yIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCJmb3JtYXR0ZWQiLCJzZXR0aW5nc0Nsb25lIiwiaW5pdCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwid2hpY2giLCJwcm9jZXNzZWQiLCJzZXRTZWxlY3Rpb24iLCJzZXRSZWFsIiwibWluIiwic2V0UG9zaXRpb24iLCJwb3MiLCJnZXRCZWZvcmVBZnRlciIsImxlZnQiLCJyaWdodCIsImdldEJlZm9yZUFmdGVyU3RyaXBlZCIsIm5vcm1hbGl6ZVBhcnRzIiwibmV3VmFsdWUiLCJzZXRWYWx1ZVBhcnRzIiwiYWR2ZW50IiwicGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsInRyaWdnZXIiLCJzaWduUG9zaXRpb24iLCJhU2lnbkxlbiIsImhhc05lZyIsInZhbHVlTGVuIiwiZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2hlY2tQYXN0ZSIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsInN1YnN0ciIsInNraXBBbHdheXMiLCJzTnVtYmVyIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJhU3VmZml4TGVuIiwic3RhcnRKdW1wIiwicHJvY2Vzc1RyYWlsaW5nIiwiY2FyZXRGaXgiLCJCb29sZWFuIiwicHJvY2Vzc0Fsd2F5cyIsInRocm93SW5wdXQiLCJwcm9jZXNzS2V5cHJlc3MiLCJjQ29kZSIsImZyb21DaGFyQ29kZSIsImZvcm1hdFF1aWNrIiwibGVmdExlbmd0aCIsImt1Q29kZSIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJfZ2V0U3RyaW5nT3JBcnJheSIsImdldEFycmF5QmVoYXZpb3IiLCJmb3JtSW5kZXgiLCJpbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJpbkFycmF5IiwidGVzdElucHV0IiwibG9jYWxlT3V0cHV0Iiwic2VyaWFsaXplIiwiZm9ybVBhcnRzIiwibWV0aG9kcyIsIm9wdGlvbnMiLCJ0YWdEYXRhIiwiJGlucHV0IiwiaXMiLCJleHRlbmQiLCJmbiIsImRlZmF1bHRzIiwicnVuT25jZSIsInRhZ0xpc3QiLCJrZXkiLCJhU2NhbGUiLCJzY2FsZUZhY3RvciIsInNjYWxlU3VmZml4IiwicHJvcCIsInRvTG93ZXJDYXNlIiwiZURlYyIsImFGb3JtIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJhbkRlZmF1bHQiLCJhdHRyIiwiaXNOdW1lcmljIiwidG9TdHJpcCIsIm9uIiwiJHNldHRpbmdzIiwiblNlcCIsImluVmFsIiwibGFzdFZhbCIsIm9uRW1wdHkiLCJyZWFkT25seSIsInNraXAiLCJ0YWIiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJwcmVwYXJlIiwiaXNWYWxpZCIsImlzTmFOIiwib2xkUmF3VmFsdWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJwYXN0ZWRUZXh0Iiwib3JpZ2luYWxFdmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidmFsdWVPZiIsImNsb3Nlc3QiLCJ1blNldE9uU3VibWl0IiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJvZmYiLCJ3aXBlIiwic2V0IiwidmFsdWVJbiIsImF0dGVtcHRlZFZhbHVlIiwidW5TZXQiLCJyZVNldCIsImVxIiwiZ2V0Rm9ybWF0dGVkIiwiZ2V0U3RyaW5nIiwiZ2V0QXJyYXkiLCJnZXRTZXR0aW5ncyIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsInNlbmRDdXN0b21FdmVudCIsImF1dG9VbmZvcm1hdCIsImNyZWF0ZUN1c3RvbUV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsInBhcmFtcyIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiRXZlbnQiLCJmb3JtYXQiLCJ1bkZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsSUFBSUEsbUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBOztBQUVDLFdBQVNDLE9BQVQsRUFBa0I7QUFDZjtBQUNKLFFBQUksSUFBSixFQUFnRDtBQUM1QztBQUNBQyxRQUFBLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxvQ0FBbUJELE9BQW5CO0FBQ0gsS0FIRCxNQUdPLElBQUksUUFBT0UsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QkEsT0FBT0MsT0FBekMsRUFBa0Q7QUFDckQ7QUFDQUQsZUFBT0MsT0FBUCxHQUFpQkgsUUFBUUksUUFBUSxRQUFSLENBQVIsQ0FBakI7QUFDSCxLQUhNLE1BR0E7QUFDSDtBQUNBSixnQkFBUUssT0FBT0MsTUFBZjtBQUNIO0FBQ0EsQ0FaQSxFQVlDLGFBQUs7QUFDSDs7O0FBR0EsUUFBTUMsVUFBVTtBQUNaQyxtQkFBZ0IsQ0FESjtB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YUFBckIsQ0FBWjtBQUNBRCxnQkFBSUUsZUFBSixDQUFvQkosS0FBcEIsRUFBMkJDLE9BQU9KLE9BQWxDLEVBQTJDSSxPQUFPSCxVQUFsRCxFQUE4REcsT0FBT04sTUFBckU7QUFDQSxtQkFBT08sR0FBUDtBQUNIOztBQUVETixvQkFBWS9VLFNBQVosR0FBd0JySCxPQUFPNmMsS0FBUCxDQUFheFYsU0FBckM7QUFDQXJILGVBQU9vYyxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQTl0RkEsQ0FBRDs7QUFndUZBOzs7a0JBR2U7QUFDWFUsWUFBVXRkLFVBREM7QUFFWHVkLGNBQVV0ZCxZQUZDO0FBR1hDOztBQUhXLEMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBhdXRvTnVtZXJpYy5qc1xuKiBAYXV0aG9yOiBCb2IgS25vdGhlXG4qIEBjb250cmlidXRvcnM6IFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzXG4qIEB2ZXJzaW9uOiAyLjAgLSAyMDE2LTExLTE2IFVUQy0xMCAyMzowMFxuKlxuKiBDcmVhdGVkIGJ5IFJvYmVydCBKLiBLbm90aGUgb24gMjAwOS0wOC0wOS4gUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vQm9iS25vdGhlL2F1dG9OdW1lcmljXG4qXG4qIENvcHlyaWdodCAoYykgMjAwOSBSb2JlcnQgSi4gS25vdGhlIGh0dHA6Ly93d3cuZGVjb3JwbGFuaXQuY29tL3BsdWdpbi9cbipcbiogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xuXG4vKiBnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvL1RPRE8gVGhpcyBzdXJlbHkgY2FuIGJlIGltcHJvdmVkIGJ5IGxldHRpbmcgd2VicGFjayB0YWtlIGNhcmUgb2YgZ2VuZXJhdGluZyB0aGlzIFVNRCBwYXJ0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbn0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbn1cbn0oJCA9PiB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXG4gICAgICovXG4gICAgY29uc3Qga2V5Q29kZSA9IHtcbiAgICAgICAgQmFja3NwYWNlOiAgICAgIDgsXG4gICAgICAgIFRhYjogICAgICAgICAgICA5LFxuICAgICAgICBFbnRlcjogICAgICAgICAgMTMsXG4gICAgICAgIFNoaWZ0OiAgICAgICAgICAxNixcbiAgICAgICAgQ3RybDogICAgICAgICAgIDE3LFxuICAgICAgICBBbHQ6ICAgICAgICAgICAgMTgsXG4gICAgICAgIFBhdXNlQnJlYWs6ICAgICAxOSxcbiAgICAgICAgQ2Fwc0xvY2s6ICAgICAgIDIwLFxuICAgICAgICBFc2M6ICAgICAgICAgICAgMjcsXG4gICAgICAgIFNwYWNlOiAgICAgICAgICAzMixcbiAgICAgICAgUGFnZVVwOiAgICAgICAgIDMzLFxuICAgICAgICBQYWdlRG93bjogICAgICAgMzQsXG4gICAgICAgIEVuZDogICAgICAgICAgICAzNSxcbiAgICAgICAgSG9tZTogICAgICAgICAgIDM2LFxuICAgICAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXG4gICAgICAgIFVwQXJyb3c6ICAgICAgICAzOCxcbiAgICAgICAgUmlnaHRBcnJvdzogICAgIDM5LFxuICAgICAgICBEb3duQXJyb3c6ICAgICAgNDAsXG4gICAgICAgIEluc2VydDogICAgICAgICA0NSxcbiAgICAgICAgRGVsZXRlOiAgICAgICAgIDQ2LFxuICAgICAgICBudW0wOiAgICAgICAgICAgNDgsXG4gICAgICAgIG51bTE6ICAgICAgICAgICA0OSxcbiAgICAgICAgbnVtMjogICAgICAgICAgIDUwLFxuICAgICAgICBudW0zOiAgICAgICAgICAgNTEsXG4gICAgICAgIG51bTQ6ICAgICAgICAgICA1MixcbiAgICAgICAgbnVtNTogICAgICAgICAgIDUzLFxuICAgICAgICBudW02OiAgICAgICAgICAgNTQsXG4gICAgICAgIG51bTc6ICAgICAgICAgICA1NSxcbiAgICAgICAgbnVtODogICAgICAgICAgIDU2LFxuICAgICAgICBudW05OiAgICAgICAgICAgNTcsXG4gICAgICAgIGE6ICAgICAgICAgICAgICA2NSxcbiAgICAgICAgYjogICAgICAgICAgICAgIDY2LFxuICAgICAgICBjOiAgICAgICAgICAgICAgNjcsXG4gICAgICAgIGQ6ICAgICAgICAgICAgICA2OCxcbiAgICAgICAgZTogICAgICAgICAgICAgIDY5LFxuICAgICAgICBmOiAgICAgICAgICAgICAgNzAsXG4gICAgICAgIGc6ICAgICAgICAgICAgICA3MSxcbiAgICAgICAgaDogICAgICAgICAgICAgIDcyLFxuICAgICAgICBpOiAgICAgICAgICAgICAgNzMsXG4gICAgICAgIGo6ICAgICAgICAgICAgICA3NCxcbiAgICAgICAgazogICAgICAgICAgICAgIDc1LFxuICAgICAgICBsOiAgICAgICAgICAgICAgNzYsXG4gICAgICAgIG06ICAgICAgICAgICAgICA3NyxcbiAgICAgICAgbjogICAgICAgICAgICAgIDc4LFxuICAgICAgICBvOiAgICAgICAgICAgICAgNzksXG4gICAgICAgIHA6ICAgICAgICAgICAgICA4MCxcbiAgICAgICAgcTogICAgICAgICAgICAgIDgxLFxuICAgICAgICByOiAgICAgICAgICAgICAgODIsXG4gICAgICAgIHM6ICAgICAgICAgICAgICA4MyxcbiAgICAgICAgdDogICAgICAgICAgICAgIDg0LFxuICAgICAgICB1OiAgICAgICAgICAgICAgODUsXG4gICAgICAgIHY6ICAgICAgICAgICAgICA4NixcbiAgICAgICAgdzogICAgICAgICAgICAgIDg3LFxuICAgICAgICB4OiAgICAgICAgICAgICAgODgsXG4gICAgICAgIHk6ICAgICAgICAgICAgICA4OSxcbiAgICAgICAgejogICAgICAgICAgICAgIDkwLFxuICAgICAgICBXaW5kb3dzOiAgICAgICAgOTEsXG4gICAgICAgIFJpZ2h0Q2xpY2s6ICAgICA5MyxcbiAgICAgICAgbnVtcGFkMDogICAgICAgIDk2LFxuICAgICAgICBudW1wYWQxOiAgICAgICAgOTcsXG4gICAgICAgIG51bXBhZDI6ICAgICAgICA5OCxcbiAgICAgICAgbnVtcGFkMzogICAgICAgIDk5LFxuICAgICAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxuICAgICAgICBudW1wYWQ1OiAgICAgICAgMTAxLFxuICAgICAgICBudW1wYWQ2OiAgICAgICAgMTAyLFxuICAgICAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxuICAgICAgICBudW1wYWQ4OiAgICAgICAgMTA0LFxuICAgICAgICBudW1wYWQ5OiAgICAgICAgMTA1LFxuICAgICAgICBNdWx0aXBseU51bXBhZDogMTA2LFxuICAgICAgICBQbHVzTnVtcGFkOiAgICAgMTA3LFxuICAgICAgICBNaW51c051bXBhZDogICAgMTA5LFxuICAgICAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxuICAgICAgICBTbGFzaE51bXBhZDogICAgMTExLFxuICAgICAgICBGMTogICAgICAgICAgICAgMTEyLFxuICAgICAgICBGMjogICAgICAgICAgICAgMTEzLFxuICAgICAgICBGMzogICAgICAgICAgICAgMTE0LFxuICAgICAgICBGNDogICAgICAgICAgICAgMTE1LFxuICAgICAgICBGNTogICAgICAgICAgICAgMTE2LFxuICAgICAgICBGNjogICAgICAgICAgICAgMTE3LFxuICAgICAgICBGNzogICAgICAgICAgICAgMTE4LFxuICAgICAgICBGODogICAgICAgICAgICAgMTE5LFxuICAgICAgICBGOTogICAgICAgICAgICAgMTIwLFxuICAgICAgICBGMTA6ICAgICAgICAgICAgMTIxLFxuICAgICAgICBGMTE6ICAgICAgICAgICAgMTIyLFxuICAgICAgICBGMTI6ICAgICAgICAgICAgMTIzLFxuICAgICAgICBOdW1Mb2NrOiAgICAgICAgMTQ0LFxuICAgICAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxuICAgICAgICBNeUNvbXB1dGVyOiAgICAgMTgyLFxuICAgICAgICBNeUNhbGN1bGF0b3I6ICAgMTgzLFxuICAgICAgICBTZW1pY29sb246ICAgICAgMTg2LFxuICAgICAgICBFcXVhbDogICAgICAgICAgMTg3LFxuICAgICAgICBDb21tYTogICAgICAgICAgMTg4LFxuICAgICAgICBIeXBoZW46ICAgICAgICAgMTg5LFxuICAgICAgICBEb3Q6ICAgICAgICAgICAgMTkwLFxuICAgICAgICBTbGFzaDogICAgICAgICAgMTkxLFxuICAgICAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxuICAgICAgICBMZWZ0QnJhY2tldDogICAgMjE5LFxuICAgICAgICBCYWNrc2xhc2g6ICAgICAgMjIwLFxuICAgICAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxuICAgICAgICBRdW90ZTogICAgICAgICAgMjIyLFxuICAgICAgICBDb21tYW5kOiAgICAgICAgMjI0LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYXMgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpIHx8IG5lZWRsZSA9PT0gJycgfHwgbmVlZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGFyclxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSBlcnJvcnMgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UsIGRlYnVnKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIGNhbGxiYWNrcyBpbiBwYXJhbWV0ZXJzIGlmIGFueVxuICAgICAqIGFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrcygkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgdk1pbiB2TWF4IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpIHtcbiAgICAgICAgbGV0IHZNYXhMZW5ndGggPSAwO1xuICAgICAgICBsZXQgdk1pbkxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh2TWF4WzFdKSB7XG4gICAgICAgICAgICB2TWF4TGVuZ3RoID0gdk1heFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZNaW5bMV0pIHtcbiAgICAgICAgICAgIHZNaW5MZW5ndGggPSB2TWluWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2TWF4TGVuZ3RoLCB2TWluTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJpbmcgdXNlciBkZWZpbmVkIG9wdGlvbnMgZm9yIGZ1cnRoZXIgdXNhZ2VcbiAgICAgKiBtZXJnZSB0aGVtIHdpdGggZGVmYXVsdHMgYXBwcm9wcmlhdGVseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Db2RlKCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgc2V0dGluZ3MuYU5lZyA9IHNldHRpbmdzLnZNaW4gPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZNYXhbMF0gPSB2TWF4WzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHZNaW5bMF0gPSB2TWluWzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heCh2TWF4WzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heCh2TWluWzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICAgICAgc2V0dGluZ3Mub0RlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gTnVtYmVyKHNldHRpbmdzLm1EZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURlY2ltYWwpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBzZXR0aW5ncy5zY2FsZURlY2ltYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgPT09IG51bGwgJiYgc2V0dGluZ3MubURlYyA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLicgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJywnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLCcgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FjaGUgcmVnZXhwcyBmb3IgYXV0b1N0cmlwXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5hTmVnID9gKFstXFxcXCR7c2V0dGluZ3MuYU5lZ31dPylgIDonKC0/KSc7XG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHsoc2V0dGluZ3MuYU5lZz9gXFxcXCR7c2V0dGluZ3MuYU5lZ31gOicnKX1cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXS4qPyhcXFxcZHxcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmFEZWN9PylbXlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdXFxcXEQqJGApO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuYURlY30/KFxcXFxkK1xcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQrKXwoXFxcXGQqKD86XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCopPykpYCk7XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0cmlwIGFsbCB1bndhbnRlZCBjaGFyYWN0ZXJzIGFuZCBsZWF2ZSBvbmx5IGEgbnVtYmVyIGFsZXJ0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1N0cmlwKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2lnbiAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTaWduLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWZmaXhcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5hU3VmZml4KSkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVN1ZmZpeCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgcmVwbGFjZSBhbnl0aGluZyBiZWZvcmUgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xuXG4gICAgICAgIGlmICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIGNvbnRhaW5zKHMsICctJykgJiYgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyB0aGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGVkIGNoYXJhY3RlcnNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWx0RGVjLCBzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBvbmx5IG51bWJlciBzdHJpbmdcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcbiAgICAgICAgcyA9IG0gPyBbbVsxXSwgbVsyXSwgbVszXV0uam9pbignJykgOiAnJztcbiAgICAgICAgaWYgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5hTmVnKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5sWmVybyA9PT0gJ2RlbnknKSB8fCAoc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycgJiYgc2V0dGluZ3Mub25PZmYgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxuICAgICAgICAgICAgbGV0IHN0cmlwUmVnID0gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGQpYDtcbiAgICAgICAgICAgIHN0cmlwUmVnID0gbmV3IFJlZ0V4cChzdHJpcFJlZyk7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHN0cmlwUmVnLCAnJDEkMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGxhY2VzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICgoc2V0dGluZ3MucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdEJyYWNrZXQsIGxhc3RCcmFja2V0XSA9IHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XG4gICAgICAgICAgICAgICAgcyA9IGZpcnN0QnJhY2tldCArIHMgKyBsYXN0QnJhY2tldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub25PZmYgJiYgcy5jaGFyQXQoMCkgPT09IGZpcnN0QnJhY2tldCkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGxvY2FsZSBmb3JtYXQgdG8gSmF2YXNjcmlwdCBudW1lcmljIHN0cmluZ1xuICAgICAqIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBwZXJpb2Qgb3IgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZCBvZiBjdXJyZW5jeSBzaWducyBhbGxvd2VkXG4gICAgICogJzEyMzQuNTYnICAgIE9LXG4gICAgICogJy0xMjM0LjU2JyAgIE9LXG4gICAgICogJzEyMzQuNTYtJyAgIE9LXG4gICAgICogJzEyMzQsNTYnICAgIE9LXG4gICAgICogJy0xMjM0LDU2JyAgIE9LXG4gICAgICogJzEyMzQsNTYtJyAgIE9LXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUxvY2FsZShzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBpZiAoY29udGFpbnMocywgJy0nKSAmJiBzLmxhc3RJbmRleE9mKCctJykgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgIHMgPSAnLScgKyBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50XG4gICAgICogc2VlIFwibG9jYWxlT3V0cHV0XCIgb3B0aW9uIGZvciBkZXRlcm1pbmVcbiAgICAgKiBudWxsID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gZGVmYXVsdFxuICAgICAqIFwiLFwiICA9PiBubm5uLG5uIG9yIC1ubm5uLG5uIGNhbiBhbHMgYmUgXCItLFwiXG4gICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgKiBcIiwtXCIgPT4gbm5ubixubiBvciBubm5uLG5uLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJy4tJykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlID09PSAnLCcgfHwgbG9jYWxlID09PSAnLSwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcsLScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5zKHZhbHVlLCAnLScpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXhOdW1iZXIocywgYURlYywgYU5lZykge1xuICAgICAgICBpZiAoYURlYyAmJiBhRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYURlYywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYU5lZyAmJiBhTmVnICE9PSAnLScpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYU5lZywgJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgcmVhbCBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIG91ciBmb3JtYXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICYmIHNldHRpbmdzLmFOZWcgIT09ICctJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICYmIHNldHRpbmdzLmFEZWMgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmFEZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0byBjaGVjayBmb3IgZW1wdHkgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGl2LCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGl2ID09PSAnJyB8fCBpdiA9PT0gc2V0dGluZ3MuYU5lZykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLndFbXB0eSA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLnBOZWcgPT09ICdsJykgPyBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYVN1ZmZpeCA6IHNldHRpbmdzLmFTaWduICsgaXYgKyBzZXR0aW5ncy5hU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Hcm91cChpdiwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpdiA9IGF1dG9TdHJpcChpdiwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhpdiwgJy0nKSkge1xuICAgICAgICAgICAgaXYgPSAnLScgKyBpdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaXYsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaXNOZWcgPSBjb250YWlucyhpdiwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnKSB7XG4gICAgICAgICAgICBpdiA9IGl2LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cCA9ICcnO1xuICAgICAgICBzZXR0aW5ncy5kR3JvdXAgPSBzZXR0aW5ncy5kR3JvdXAudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzInKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzJzJykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnNCcpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaXYuc3BsaXQoc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTZXAgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyByZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5hU2VwfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgIT09IDAgJiYgIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gam9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2hvbGUgbnVtYmVycyBvbmx5XG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZyArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IGl2ICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYU5lZyArIGl2ICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGl2LmNoYXJBdCgwKSA9PT0gJy0nKSkge1xuICAgICAgICAgICAgaXYgPSBuZWdhdGl2ZUJyYWNrZXQoaXYsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHJEZWMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcbiAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAockRlYyA9PT0gMCkge1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdW5kIG51bWJlciBhZnRlciBzZXR0aW5nIGJ5IHBhc3Rpbmcgb3IgJCgpLmF1dG9OdW1lcmljU2V0KClcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIGZvciByb3VuZCB0aGUgbnVtYmVyXG4gICAgICogcGxlYXNlIG5vdGUgdGhpcyBoYW5kbGVkIGFzIHRleHQgLSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlc1xuICAgICAqIGFsc28gdGhpcyBvZmZlcnMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcyB0aGF0IGFyZSBub3QgZWFzaWx5IGFjY29tcGxpc2hlZCBpbiBKYXZhU2NyaXB0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1JvdW5kKGl2LCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcbiAgICAgICAgaXYgPSAoaXYgPT09ICcnKSA/ICcwJyA6IGl2LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tUm91bmQgPT09ICdOMDUnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0NIRicgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdEMDUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1Sb3VuZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ04wNSc6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGgucm91bmQoaXYgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5jZWlsKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLmZsb29yKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGl2LCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXYgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoIC0gaXYuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXZSb3VuZGVkID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgIGxldCByRGVjO1xuXG4gICAgICAgIGlmICh0eXBlb2Yoc2V0dGluZ3MuYVBhZCkgPT09ICdib29sZWFuJyB8fCBzZXR0aW5ncy5hUGFkID09PSBudWxsKSB7XG4gICAgICAgICAgICByRGVjID0gc2V0dGluZ3MuYVBhZD9zZXR0aW5ncy5tRGVjOjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByRGVjID0gTnVtYmVyKHNldHRpbmdzLmFQYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpdiAoaW5wdXQgVmFsdWUpaXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBpZiAoaXYuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIGEgemVybyBpZiBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90XG4gICAgICAgIGlmICghaXYubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaXYgPSAnMCcgKyBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIHplcm8gLSBpZiB6ZXJvIG5vIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGl2KSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW1zIGxlYWRpbmcgemVybydzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpdikgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpdi5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGl2Lmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgLy8gdmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gKGRQb3MgPT09IC0xKSA/IGl2Lmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIGNoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBjaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpdi5sZW5ndGggLSAxKSAtIHZkUG9zO1xuICAgICAgICBpZiAoY0RlYyA8PSBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpdjtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgIGlmIChkUG9zID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHJEZWMgLSBjRGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgY29uc3Qgckxlbmd0aCA9IGRQb3MgKyBzZXR0aW5ncy5tRGVjOyAvL1RPRE8gTW9kaWZ5IGBkUG9zYCBoZXJlIGlmIGl0J3Mgbm90IGludGVuZGVkIHRoYXQgaXQgY2FuIGJlIGVxdWFsIHRvICctMSdcbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGl2LmNoYXJBdChyTGVuZ3RoICsgMSkpO1xuICAgICAgICBjb25zdCBvZGQgPSAoaXYuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGl2LmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpdi5jaGFyQXQockxlbmd0aCkgJSAyKTtcbiAgICAgICAgbGV0IGl2QXJyYXkgPSBpdi5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyByZXR1cm4gcm91bmRlZCB2YWx1ZVxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHJEZWMpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XG4gICAgICAgIGNvbnN0IGFEZWMgPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICBjb25zdCBtRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xuICAgICAgICAgICAgb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyg6fFxcLikvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50XG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoYXQuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hUGFkO1xuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5CcmFja2V0O1xuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmFTZXA7XG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuYVNpZ247XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICogdGFrZW4gZnJvbSBRdWlya3Ntb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZCAtIHRha2VuIGZyb20gbW9kZXJuaXpyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmFnZVRlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCB0b0RvKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9ICgkdGhpc1swXS5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoJHRoaXNbMF0ubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudCgkdGhpc1swXS5uYW1lKX1gIDpgQVVUT18keyR0aGlzWzBdLmlkfWA7XG4gICAgICAgICAgICBsZXQgZGF0ZTtcbiAgICAgICAgICAgIGxldCBleHBpcmVzO1xuXG4gICAgICAgICAgICAvLyBzZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XG4gICAgICAgICAgICBpZiAoc3RvcmFnZVRlc3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1dG9OdW1lcmljSG9sZGVyKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICB9XG5cbiAgICBBdXRvTnVtZXJpY0hvbGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQoZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgICAgICAgICAgdGhpcy5jbWRLZXkgPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcblxuICAgICAgICAgICAgLy8ga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndoaWNoID0gZS53aGljaDtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5zZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlclN0cmlwZWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XG4gICAgICAgICAgICBsZWZ0ID0gYXV0b1N0cmlwKGxlZnQsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb2VzXG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgc2V0dGluZ3NDbG9uZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhRGVjLFxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnJyB8fCBsZWZ0ID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIHNldHRpbmdzQ2xvbmUubFplcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5hRGVjfWApKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSBrZWVwaW5nIHBvc2l0aW9uIG9mIGN1cnNvclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgYWR2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLm5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gdHJ1bmNhdGVEZWNpbWFsKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUsIGFkdmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSB0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciBleHBhbmRTZWxlY3Rpb25PblNpZ25cbiAgICAgICAgICogcmV0dXJucyBzaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzaWduUG9zaXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgYVNpZ24gPSBzZXR0aW5nc0Nsb25lLmFTaWduO1xuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcbiAgICAgICAgICAgIGlmIChhU2lnbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5hTmVnICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05lZyA/IFsxLCBhU2lnbkxlbiArIDFdIDogWzAsIGFTaWduTGVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlTGVuIC0gYVNpZ25MZW4sIHZhbHVlTGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFsxMDAwLCAtMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgICAgICogcHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuc2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2lnblBvc2l0aW9uWzFdLCBzZWxlY3Rpb24uZW5kLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugc2VsZWN0IHdpdGggd2hvbGUgc2lnblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgZmlyc3RcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBhdXRvU3RyaXAobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgJ3Bhc3RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5c1xuICAgICAgICAgKiBpZiByZXR1cm5zIHRydWUsIGZ1cnRoZXIgcHJvY2Vzc2luZyBpcyBub3QgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBza2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2ggPSB0aGlzLndoaWNoO1xuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xuXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcbiAgICAgICAgICAgIGlmICgoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKHNoaWZ0S2V5ICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2lwIEZ4IGtleXMsIHdpbmRvd3Mga2V5cywgb3RoZXIgc3BlY2lhbCBrZXlzXG4gICAgICAgICAgICBpZiAoKGtkQ29kZSA+PSBrZXlDb2RlLkYxICYmIGtkQ29kZSA8PSBrZXlDb2RlLkYxMikgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiBrZENvZGUgPD0ga2V5Q29kZS5SaWdodENsaWNrKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5UYWIgJiYga2RDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlIDwga2V5Q29kZS5CYWNrc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAod2hpY2ggPT09IDAgfHwgd2hpY2ggPT09IGtkQ29kZSkpIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3QgYWxsIChhKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYga2RDb2RlID09PSBrZXlDb2RlLmEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IHRoaXMuc2V0dGluZ3MuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWNvbnRhaW5zKHRoaXMudGhhdC52YWx1ZSwgJy0nKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU3VmZml4TGVuID0gdGhpcy5zZXR0aW5ncy5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcFNpZ24gPSB0aGlzLnNldHRpbmdzLnBTaWduO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwTmVnID0gdGhpcy5zZXR0aW5ncy5wTmVnO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHBOZWcgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgYVNpZ25MZW4gPiAwKT9hU2lnbkxlbiArIDE6YVNpZ25MZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBhU3VmZml4TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTdWZmaXhMZW4gKyBhU2lnbkxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoYVNpZ25MZW4gPiAwKT92YWx1ZUxlbiAtIChhU2lnbkxlbiArIG5lZ0xlbiArIGFTdWZmaXhMZW4pOnZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChhU2lnbkxlbiArIGFTdWZmaXhMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY29weSAoYylcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIChrZENvZGUgPT09IGtleUNvZGUuYyB8fCBrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwga2RDb2RlID09PSBrZXlDb2RlLmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdHJsS2V5IHx8IGNtZEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyB8fCBrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTZXAgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNlcDtcbiAgICAgICAgICAgICAgICBjb25zdCBhRGVjID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFEZWM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRKdW1wID0gdGhpcy5zZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgKyAxKSA9PT0gYURlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RhcnRKdW1wICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZENvZGUgPj0ga2V5Q29kZS5QYWdlRG93biAmJiBrZENvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmxlbmd0aCAtIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgKyBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpIC0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnIHx8IHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnModGhpcy52YWx1ZSwgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMucHJvY2Vzc1RyYWlsaW5nKFtsZWZ0LCByaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGluc2VydGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0tleXByZXNzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5tRGVjIHx8ICFzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBhTmVnIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5hRGVjLCByaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGlmICgoY0NvZGUgPT09ICctJyB8fCBjQ29kZSA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgIT09ICdwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBzaWduIG9mIG51bWJlciwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gJy0nIHx8IGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdHJ5IHRvIGluc2VydCBkaWdpdCBiZWZvcmUgbWludXNcbiAgICAgICAgICAgIGlmIChjQ29kZSA+PSAnMCcgJiYgY0NvZGUgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS52TWF4IDw9IDAgJiYgc2V0dGluZ3NDbG9uZS52TWluIDwgc2V0dGluZ3NDbG9uZS52TWF4ICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNDb2RlICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgY0NvZGUsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBhbnkgb3RoZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2l0aCBrZWVwaW5nIG9mIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybWF0UXVpY2soZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga3VDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XG5cbiAgICAgICAgICAgIC8vIG5vIGdyb3VwaW5nIHNlcGFyYXRvciBhbmQgbm8gY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmFTZXAgID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2VwICE9PSAnJyAgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNlcCkpKSAmJlxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmFTaWduID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNpZ24pKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgW3N1YlBhcnRzXSA9IGxlZnRMZW5ndGguc3BsaXQoc2V0dGluZ3NDbG9uZS5hRGVjKTtcbiAgICAgICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMoc3ViUGFydHMsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgblNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIHN1YlBhcnRzID0gc3ViUGFydHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCA9IG5TaWduICsgbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdXRvR3JvdXAodGhpcy52YWx1ZSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgcmVnZXhwIHdoaWNoIHNlYXJjaGVzIGZvciBjdXJzb3IgcG9zaXRpb24gZnJvbSB1bmZvcm1hdHRlZCBsZWZ0IHBhcnRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QXIgPSBsZWZ0LnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycgfHwgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgIT09ICdwJykpICYmIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmFTaWduLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZUNociA9IFsnXFxcXCcsICdeJywgJyQnLCAnLicsICd8JywgJz8nLCAnKicsICcrJywgJygnLCAnKScsICdbJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pUGFydHMgPSBzaWduUGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGluZyB0aGUgZXNjYXBlZCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBqdXN0IGJlZm9yZSBzaWduIHdoaWNoIGlzIGluIHByZWZpeCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHNldHRpbmdzQ2xvbmUuYU5lZykgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSkgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAmJiBzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGggKyAodmFsdWUuY2hhckF0KDApID09PSAnLScgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU2lnbiAmJiBzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBmYWN0b3Jpc2UgdGhlIGBnZXRTdHJpbmcoKWAgYW5kIGBnZXRBcnJheSgpYCBmdW5jdGlvbnMgc2luY2UgdGhleSBzaGFyZSBxdWl0ZSBhIGxvdCBvZiBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoYXQpKTtcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuICAgICAgICAgICAgJC5lYWNoKGZvcm1GaWVsZHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXQnLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRTdHJpbmcoKSBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybVBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgbWluaVBhcnRzID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbmlQYXJ0c1sxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0c1sxXSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0Jywgc2V0dGluZ3MubG9jYWxlT3V0cHV0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1QYXJ0c1tpXSA9IG1pbmlQYXJ0cy5qb2luKCc9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaGVkIHRoZSBzZXR0aW5ncyAoZGVmYXVsdCBhbmQgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb259KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbn0pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKiBvcHRpb25zIHBhc3NlcyBhcyBhIHBhcmFtZXRlciBleGFtcGxlICd7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiB0aGV5IGRvbid0IGV4aXN0IHdlJ2xsIGdldCBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcblxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRlZCBpbnB1dCB0eXBlXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBncmFiIFwiYXV0b051bWVyaWNcIiBzZXR0aW5ncywgaWYgdGhleSBkb24ndCBleGlzdCByZXR1cm5zIFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZ3JhYiBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSBkZWZhdWx0cyBhbmQgcGFzc2VkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzLCB0YWdEYXRhLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk9mZiAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bk9uY2UgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0Rml4ICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMaXN0ICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjYXB0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2l0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb25zdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGZuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2gxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2g0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tkYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzYW1wbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb25nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgZGVmYXVsdHMsIHRhZ0RhdGEgYW5kIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09IHNldHRpbmdzLmFTZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGFEZWMgWyR7c2V0dGluZ3MuYURlY31dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIGFTZXAgWyR7c2V0dGluZ3MuYVNlcH1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXJgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSBCb29sZWFuKHZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYga2V5ICE9PSAnYVNjYWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY2FsZUZhY3RvciA9ICtzZXR0aW5ncy5hU2NhbGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY2FsZURlY2ltYWwgPSAoc2V0dGluZ3MuYVNjYWxlWzFdKSA/ICtzZXR0aW5ncy5hU2NhbGVbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NhbGVTdWZmaXggPSAoc2V0dGluZ3MuYVNjYWxlWzJdKSA/IHNldHRpbmdzLmFTY2FsZVsyXSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSBvcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgaW5wdXQgdHlwZXNcbiAgICAgICAgICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgaW5wdXQgdHlwZSBcIiR7JHRoaXMucHJvcCgndHlwZScpfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBub24tc3VwcG9ydGVkIHRhZ3NcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgIT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIDwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2UgdGhlIHR3byBuZXh0IHRlc3RzIHdpdGggYSBgdmFsaWRhdGVPcHRpb25zKClgIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBhcmUgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjIFske3NldHRpbmdzLmFEZWN9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwIFske3NldHRpbmdzLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJlRGVjXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJtRGVjXCJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA8IHNldHRpbmdzLm1EZWMgJiYgc2V0dGluZ3MuZURlYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBlRGVjIFske3NldHRpbmdzLmVEZWN9XSBpcyBncmVhdGVyIHRoYW4gdGhlIG1EZWMgWyR7c2V0dGluZ3MubURlY31dIHZhbHVlYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgdG8gZm9ybWF0IGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgPT09IGZhbHNlICYmIHNldHRpbmdzLmFGb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogY2hlY2tzIGZvciBwYWdlIHJlbG9hZCBmcm9tIGJhY2sgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhbHNvIGNoZWNrcyBmb3IgQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYW5EZWZhdWx0ICYmIHNldHRpbmdzLmFuRGVmYXVsdC50b1N0cmluZygpICE9PSBjdXJyZW50VmFsdWUpIHx8IChzZXR0aW5ncy5hbkRlZmF1bHQgPT09IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBjdXJyZW50VmFsdWUgIT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHx8IChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgJiYgc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTY2FsZSAmJiBzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKSA/ICctJyArIGF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncykgOiBhdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mud0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChzZXR0aW5ncy5hU2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSAmJiAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGlucHV0IHR5cGVzIHN1cHBvcnRlZCBcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2ZvY3VzaW4uYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAkc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwobmVnYXRpdmVCcmFja2V0KCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MublNlcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2VwID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTaWduID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5lRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3MuYVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IGF1dG9TdHJpcCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSkgIT09ICRzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gaG9sZGVyLmluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FbXB0eSA9IGNoZWNrRW1wdHkoaG9sZGVyLmluVmFsLCAkc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiAkc2V0dGluZ3Mud0VtcHR5ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKG9uRW1wdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigna2V5ZG93bi5hdXRvTnVtZXJpYycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIudGhhdC5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiAvLyBUaGUgY29kZSBiZWxvdyBhbGxvd3MgdGhlIFwiZW50ZXJcIiBrZXlkb3duIHRvIHRocm93IGEgY2hhbmdlKCkgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLmluVmFsICE9PSAkdGhpcy52YWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pblZhbCA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIucHJvY2Vzc0Fsd2F5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgaW4gZGVsZXRpb24gY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleXByZXNzLmF1dG9OdW1lcmljJywgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGZpeCBmb3IgU2hpZnQgJiYgaW5zZXJ0IHBhc3RlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2tpcEFsd2F5cyhlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnByb2Nlc3NBbHdheXMoKSB8fCBob2xkZXIucHJvY2Vzc0tleXByZXNzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50VmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRocm93cyBpbnB1dCBldmVudCBvbiBhZGRpbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXl1cC5hdXRvTnVtZXJpYycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuc2tpcEFsd2F5cyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYiA9IGhvbGRlci5rZENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIua2RDb2RlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoLCBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFiID09PSBrZXlDb2RlLlRhYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgJHRoaXMudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmVzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHRvIHByZXNlcnZlIHRoZSBkYXRhIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5lRGVjICE9PSBudWxsICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdmb2N1c291dC5hdXRvTnVtZXJpYycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgJHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLm5TZXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICRzZXR0aW5ncy5vU2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICRzZXR0aW5ncy5vU2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuZURlYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFQYWQgPSAkc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubkJyYWNrZXQgPSAkc2V0dGluZ3Mub0JyYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCAkc2V0dGluZ3MpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgJHNldHRpbmdzLmFEZWMsICRzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuYVNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gJHNldHRpbmdzLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gKCRzZXR0aW5ncy5hU2NhbGUgJiYgJHNldHRpbmdzLmFTY2FsZVsxXSkgPyArJHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6ICRzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkc2V0dGluZ3MucmF3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLndFbXB0eSA9PT0gJ3plcm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQoJzAnLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCAkc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoJHNldHRpbmdzLnNjYWxlU3VmZml4KSA/IGdyb3VwZWRWYWx1ZSArICRzZXR0aW5ncy5zY2FsZVN1ZmZpeCA6IGdyb3VwZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoZ3JvdXBlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci5pblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIuaW5WYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdwYXN0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRklYTUUgQWZ0ZXIgYSBwYXN0ZSwgdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgZmFyIHJpZ2h0IG9mIHRoZSBpbnB1dCwgaXQgc2hvdWxkIGJlIHNldCB0byBzb21ldGhpbmcgbGlrZSBgbmV3Q2FyZXRQb3NpdGlvbiA9IG9sZENhcmV0UG9zaXRpb24gKyBwYXN0ZVRleHQubGVuZ3RoO2AsIHdoaWxlIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmUodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvU3RyaXAodGV4dCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUpLnJlcGxhY2UoaG9sZGVyLnNldHRpbmdzQ2xvbmUuYURlYywgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNWYWxpZCh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQgIT09ICcnICYmICFpc05hTih0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkUmF3VmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCwgY3VycmVudFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXN0ZWRUZXh0ID0gcHJlcGFyZShlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQocGFzdGVkVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHByZXBhcmUocHJlZml4ICsgTnVtYmVyKHBhc3RlZFRleHQpLnZhbHVlT2YoKSArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQobmV3VmFsdWUpICYmIE51bWJlcihvbGRSYXdWYWx1ZSkudmFsdWVPZigpICE9PSBOdW1iZXIobmV3VmFsdWUpLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuY2xvc2VzdCgnZm9ybScpLm9uKCdzdWJtaXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MudW5TZXRPblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gcmVtb3ZlIHNldHRpbmdzIGFuZCBzdG9wIGF1dG9OdW1lcmljKCkgLSBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gZGVzdHJveXMgYXV0b051bWVyaWNcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZignLmF1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgYW5kIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyByZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3aXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVwZGF0ZSBzZXR0aW5ncyAtIGNhbiBiZSBjYWxsIGFzIG1hbnkgdGltZXNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwidXBkYXRlXCIsIHtvcHRpb25zfSk7IC8vIHVwZGF0ZXMgdGhlIHNldHRpbmdzXG4gICAgICAgICAqIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGV4YW1wbGUgJ3thU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJ1cGRhdGVcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zY2FsZUZhY3RvciA9ICtzZXR0aW5ncy5hU2NhbGVbMF07XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlRGVjaW1hbCA9IChzZXR0aW5ncy5hU2NhbGVbMV0pID8gK3NldHRpbmdzLmFTY2FsZVsxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlU3VmZml4ID0gKHNldHRpbmdzLmFTY2FsZVsyXSkgPyBzZXR0aW5ncy5hU2NhbGVbMl0gOiAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSBvcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjOiBcIiR7c2V0dGluZ3MuYURlY31cIiBhbmQgdGhvdXNhbmQgc2VwYXJhdG9yIGFTZXA6IFwiJHtzZXR0aW5ncy5hU2VwfVwiIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXJgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3NldCcsICd2YWx1ZScpOyAvLyBmb3JtYXRzIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXG4gICAgICAgICAqL1xuICAgICAgICBzZXQodmFsdWVJbikge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVJbiA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZCh2YWx1ZUluKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlSW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGJlaW5nIHNldCBpcyBub3QgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGlmICghJC5pc051bWVyaWMoTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCBoYXMgY2F1c2VkIGEgZXJyb3IgdG8gYmUgdGhyb3duYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmICghc2V0dGluZ3MuZURlYyB8fCAhc2V0dGluZ3MuYVNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IHNldHRpbmdzLnNjYWxlRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5hU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3RvciAmJiAoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCB8fCBzZXR0aW5ncy5hU2NhbGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3MgZm9yIHRoaXMgZWxlbWVudGAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gZ2V0IHRoZSB1bmZvcm1hdHRlZCB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIHBhcmFtZXRlclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpOyBubyBwYXJhbWV0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBsb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5hU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzLmFEZWMsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgTnVtZXJpYyBTdHJpbmdcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgcmV0dXJuIGBOdW1iZXIodmFsdWUpYCBzaW5jZSB0aGUgZ29hbCBvZiBgZ2V0YCBpcyB0byBnZXQgdGhlIHJhdyBqYXZhc2NyaXB0IHZhbHVlP1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvL1RPRE8gTWFrZSBzdXJlIGB0aGlzWzBdYCBleGlzdHMgYXMgd2VsbCBhcyBgLnZhbHVlYCBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aG9zZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhdXRvTnVtZXJpYyBmdW5jdGlvblxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgYXJlIHB1YmxpYyAtIHRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmc6XG4gICAgICogSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXG4gICAgICogT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzXG4gICAgICogVXNlIGpRdWVyeSdzIGAkLmV4dGVuZGAgbWV0aG9kIGZvciBnbG9iYWwgY2hhbmdlcyAtIGFsc28gYSBncmVhdCB3YXkgdG8gcGFzcyBBU1AuTkVUIGN1cnJlbnQgY3VsdHVyZSBzZXR0aW5nc1xuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qIGFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgICAgICogY29tbWEgPSBcIixcIlxuICAgICAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXG4gICAgICAgICAqIHNwYWNlID0gXCIgXCJcbiAgICAgICAgICogbm9uZSA9IFwiXCJcbiAgICAgICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIGFTZXA6ICcsJyxcblxuICAgICAgICAvKiB3aGVuIHRydWUgPT4gd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzIG9ubHkgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIHZpc2libGVcbiAgICAgICAgICovXG4gICAgICAgIG5TZXA6IGZhbHNlLFxuXG4gICAgICAgIC8qIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcbiAgICAgICAgICogZEdyb3VwOiBcIjJcIiwgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xuICAgICAgICAgKiBkR3JvdXA6IFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXG4gICAgICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxuICAgICAgICAgKiBkR3JvdXA6IFwiNFwiLCByZXN1bHRzIGluIDk5OTksOTk5OSw5OTk5IHVzZWQgaW4gc29tZSBBc2lhbiBjb3VudHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGRHcm91cDogJzMnLFxuXG4gICAgICAgIC8qIGFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgICAgICovXG4gICAgICAgIGFEZWM6ICcuJyxcblxuICAgICAgICAvKiBhbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgYURlY1xuICAgICAgICAgKiBkZXZlbG9wZWQgZm9yIGNvdW50cmllcyB0aGUgdXNlIGEgY29tbWEgXCIsXCIgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAqIGFuZCBoYXZlIGtleWJvYXJkc1xcbnVtZXJpYyBwYWRzIHRoYXQgaGF2ZSBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJzIChTcGFpbiBpcyBhbiBleGFtcGxlKVxuICAgICAgICAgKi9cbiAgICAgICAgYWx0RGVjOiBudWxsLFxuXG4gICAgICAgIC8qIGFTaWduID0gYWxsb3dlZCBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXG4gICAgICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnJCAnXG4gICAgICAgICAqIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICcgJCdcbiAgICAgICAgICovXG4gICAgICAgIGFTaWduOiAnJyxcblxuICAgICAgICAvKiBwU2lnbiA9IHBsYWNlbWVudCBvZiBjdXJyZW5jeSBzaWduIGFzIGEgcD1wcmVmaXggb3Igcz1zdWZmaXhcbiAgICAgICAgICogZm9yIHByZWZpeCBwU2lnbjogXCJwXCIgKGRlZmF1bHQpXG4gICAgICAgICAqIGZvciBzdWZmaXggcFNpZ246IFwic1wiXG4gICAgICAgICAqL1xuICAgICAgICBwU2lnbjogJ3AnLFxuXG4gICAgICAgIC8qIHBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBhU2lnbiBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXG4gICAgICAgICAqIC0kMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIn1cbiAgICAgICAgICogJC0xLDIzNC41NiA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInJcIn1cbiAgICAgICAgICogLTEsMjM0LjU2JCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCIsIHBOZWc6IFwicFwifVxuICAgICAgICAgKiAxLDIzNC41Ni0gID0+IHtwTmVnOiBcInNcIn1cbiAgICAgICAgICogJDEsMjM0LjU2LSA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInNcIn1cbiAgICAgICAgICogMSwyMzQuNTYtJCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCJ9XG4gICAgICAgICAqIDEsMjM0LjU2JC0gPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInJcIn1cbiAgICAgICAgICovXG4gICAgICAgIHBOZWc6ICdsJyxcblxuICAgICAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBhU3VmZml4OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgYVN1ZmZpeDogJyBkb2xsYXJzJ1xuICAgICAgICAgKiBOdW1lcmljIGNoYXJhY3RlcnMgYW5kIG5lZ2F0aXZlIHNpZ24gbm90IGFsbG93ZWQnXG4gICAgICAgICAqL1xuICAgICAgICBhU3VmZml4OiAnJyxcblxuICAgICAgICAvKiBvdmVycmlkZSBtaW4gbWF4IGxpbWl0cydcbiAgICAgICAgICogb0xpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byB2TWF4IGFuZCBpZ25vcmVzIHZNaW4gc2V0dGluZ3NcbiAgICAgICAgICogb0xpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gdk1pbiBhbmQgaWdub3JlcyB2TWF4IHNldHRpbmdzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICAgICAqL1xuICAgICAgICBvTGltaXRzOiBudWxsLFxuXG4gICAgICAgIC8qIG1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIHZNaW5cbiAgICAgICAgICovXG4gICAgICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxuICAgICAgICAgKi9cbiAgICAgICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIixcbiAgICAgICAgICovXG4gICAgICAgIG1EZWM6IG51bGwsXG5cbiAgICAgICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XG4gICAgICAgICAqIHtlRGVjOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAqL1xuICAgICAgICBlRGVjOiBudWxsLFxuXG4gICAgICAgIC8qIFNjYWxlZCBudW1iZXIgZGlzcGxheWVkIHdoZW4gaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1cyBleGFtcGxlIHdpdGggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICoge2FTY2FsZTogW1wiMTAwMFwiLCBcIjBcIiwgXCJLXCJdfSAgPT4gd2l0aCBmb2N1cyBcIjEsMDAwLjAwXCIgd2l0aG91dCBmb2N1cyBcIjFLXCJcbiAgICAgICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICAgICAqIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciAtIHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXG4gICAgICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlIGFuZCBzY2FsZWQgdmFsdWUuXG4gICAgICAgICAqIGRlY2ltYWwgcGxhY2VzIFwib3B0aW9uYWxcIiB3aGVuIG5vdCBpbiBmb2N1cyAtIGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzXG4gICAgICAgICAqIFN5bWJvbCBcIm9wdGlvbmFsXCIgZGlzcGxheWVkIHdoZW4gdGhlIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXMgLSBOT1RFOiBpZiBhIHN5bWJvbCBpcyB1c2VkIHlvdSBNVVNUIGFsc28gc3BlY2lmeSB0aGUgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIlxuICAgICAgICAgKi9cbiAgICAgICAgYVNjYWxlOiBudWxsLFxuXG4gICAgICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBlRGVjIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcbiAgICAgICAgICovXG4gICAgICAgIGFTdG9yOiBmYWxzZSxcblxuICAgICAgICAvKiBtZXRob2QgdXNlZCBmb3Igcm91bmRpbmdcbiAgICAgICAgICogbVJvdW5kOiBcInNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXG4gICAgICAgICAqIG1Sb3VuZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAgICAgKiBtUm91bmQ6IFwic1wiLCBSb3VuZC1IYWxmLURvd24gU3ltbWV0cmljIChsb3dlciBjYXNlIHMpXG4gICAgICAgICAqIG1Sb3VuZDogXCJBXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXG4gICAgICAgICAqIG1Sb3VuZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAgICAgKiBtUm91bmQ6IFwiVVwiLCBSb3VuZCBVcCBcIlJvdW5kLUF3YXktRnJvbS1aZXJvXCJcbiAgICAgICAgICogbVJvdW5kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXG4gICAgICAgICAqIG1Sb3VuZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAgICAgKiBtUm91bmQ6IFwiRlwiLCBSb3VuZCB0byBGbG9vciBcIlRvd2FyZCBOZWdhdGl2ZSBJbmZpbml0eVwiXG4gICAgICAgICAqIG1Sb3VuZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXG4gICAgICAgICAqIG1Sb3VuZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgICAgICogbVJvdW5kOiBcIkQwNVwiIFJvdW5kcyBkb3duIHRvIG5leHQgLjA1XG4gICAgICAgICAqL1xuICAgICAgICBtUm91bmQ6ICdzJyxcblxuICAgICAgICAvKiBjb250cm9scyBkZWNpbWFsIHBhZGRpbmdcbiAgICAgICAgICogYVBhZDogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAgICAgKiBhUGFkOiBmYWxzZSAtIGRvZXMgbm90IHBhZCB3aXRoIHplcm9zLlxuICAgICAgICAgKiBhUGFkOiBgc29tZSBudW1iZXJgIC0gcGFkIGRlY2ltYWxzIHdpdGggemVybyB0byBudW1iZXIgZGlmZmVyZW50IGZyb20gbURlY1xuICAgICAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYVBhZDogdHJ1ZSxcblxuICAgICAgICAvKiBwbGFjZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWUgLSQgOTk5Ljk5IHRvICg5OTkuOTkpXG4gICAgICAgICAqIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIGZvY3VzIHRoZSBsZWZ0IGFuZCByaWdodCBzeW1ib2xzIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICAgICAqIG5CcmFja2V0OiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICAgICAqIG5CcmFja2V0OiAnKCwpJywgbkJyYWNrZXQ6ICdbLF0nLCBuQnJhY2tldDogJzwsPicgb3IgbkJyYWNrZXQ6ICd7LH0nXG4gICAgICAgICAqL1xuICAgICAgICBuQnJhY2tldDogbnVsbCxcblxuICAgICAgICAvKiBEaXNwbGF5ZWQgb24gZW1wdHkgc3RyaW5nIFwiXCJcbiAgICAgICAgICogd0VtcHR5OiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xuICAgICAgICAgKiB3RW1wdHk6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICAgICAqIHdFbXB0eTogXCJhbHdheXNcIiAtIGFsd2F5cyBkaXNwbGF5cyB0aGUgY3VycmVuY3kgc2lnbiBvbmx5XG4gICAgICAgICAqIHdFbXB0eTogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRoIGEgY3VycmVuY3kgc2lnblxuICAgICAgICAgKi9cbiAgICAgICAgd0VtcHR5OiAnZm9jdXMnLFxuXG4gICAgICAgIC8qIGNvbnRyb2xzIGxlYWRpbmcgemVybyBiZWhhdmlvclxuICAgICAgICAgKiBsWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgICAgICogbFplcm86IFwia2VlcFwiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIG9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgcmV0YWluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBsWmVybzogJ2FsbG93JyxcblxuICAgICAgICAvKiBkZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gcGFnZSByZWFkeS5cbiAgICAgICAgICogdHJ1ZSA9IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIHJlYWR5XG4gICAgICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhRm9ybTogdHJ1ZSxcblxuICAgICAgICAvKiBkZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxuICAgICAgICAgKiB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCBvciBvbmx5IHRoZSBpbnB1dCBudW1lcmljIHZhbHVlXG4gICAgICAgICAqIGlmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24gb25seSB0aGUgbnVtZXJpYyB2YWx1ZSB3aWxsIHNlbGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzTnVtYmVyOiBmYWxzZSxcblxuICAgICAgICAvKiBoZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICogZXhhbXBsZXM6XG4gICAgICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7YW5EZWZhdWx0OiBcIlwifVxuICAgICAgICAgKiB2YWx1ZT0xMjM0LjU2IHthbkRlZmF1bHQ6ICcxMjM0LjU2J31cbiAgICAgICAgICovXG4gICAgICAgIGFuRGVmYXVsdDogbnVsbCxcblxuICAgICAgICAvKiByZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgICAgICogcmV2aWV3IHRoZSAndW5TZXQnIG1ldGhvZCBmb3Igb3RoZXIgZm9ybWF0c1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXRPblN1Ym1pdDogZmFsc2UsXG5cbiAgICAgICAgLyogYWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcbiAgICAgICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcbiAgICAgICAgICogXCIsXCIgID0+IG5ubm4sbm4gb3IgLW5ubm4sbm4gY2FuIGFscyBiZSBcIi0sXCJcbiAgICAgICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZU91dHB1dDogbnVsbCxcblxuICAgICAgICAvKiBlcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xuICAgICAgICAgKi9cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG5cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlclxuICAgICAqL1xuICAgIGF1dG9Gb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBzZW5kQ3VzdG9tRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3NgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdXRvVW5Gb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICAvKiBsZXQgZXZlbnRJbmZvID0gbmV3IEN1c3RvbUV2ZW50SW5pdCgpOyAvL1RoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCwgYnV0IElFIGRvZXMgbm90IHN1cHBvcnQgJ0N1c3RvbUV2ZW50SW5pdCcgeWV0XG4gICAgICAgIGV2ZW50SW5mby5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9KSgpO1xufSkpO1xuXG4vKipcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxuICAgIGdldERlZmF1bHRDb25maWcsXG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcbiAgICAvL3ZhbGlkYXRlICAgICA6IGFuLnZhbGlkYXRlKG9wdGlvbnMpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-27 UTC 11:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message) {\n        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * Function to handle warning messages\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * converts the ISO numeric string to the locale decimal and minus sign placement\n     * see \"localeOutput\" option for determine\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros to the first significant digit\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // removes access zeros to the mDec length when aPad is set true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the iv (input Value) is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // Supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // Checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n                }\n\n                // Checks for non-supported tags\n                //TODO Move the static configuration objects out of that block, and hoist them at the start of this file\n                var allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n                var currentElementTag = $this.prop('tagName').toLowerCase();\n                if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n                    throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n                }\n\n                // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: allowedTagList\n                    });\n\n                    // Modify the user settings to make them 'exploitable'\n                    $.each(settings, function (key, value) {\n                        // Convert the string 'true' and 'false' to real Boolean\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n\n                        // Convert numbers in options to strings\n                        //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                        if (typeof value === 'number' && key !== 'aScale') {\n                            settings[key] = value.toString();\n                        }\n                    });\n\n                    // Validate the settings\n                    validate(settings, false); // Throws if necessary\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n\n                        /*\n                         * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                         * precedence and should get formatted on init (if that this input value is a valid number and that the\n                         * developer wants it formatted on init (cf. `settings.aForm`)). Note; this is true whatever the developer\n                         * has set for `data-an-default` in the html (asp.net users).\n                         *\n                         * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n                         * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n                         * changed the input value, and then it means we should not overwrite his own decision to do so.\n                         * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n                         * we should ignore `anDefault` altogether.\n                         */\n                        if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                            // Check if the `value` is valid or not\n                            var testedCurrentValue = parseFloat(currentValue.replace(',', '.')); //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                            if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                                $this.autoNumeric('set', testedCurrentValue);\n                                setValue = false;\n                            } else {\n                                // If not, inform the developer that nothing usable has been provided\n                                throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                            }\n                        } else {\n                            /* Checks for :\n                             * - page reload from back button, and\n                             * - ASP.net form post back\n                             *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                             *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                             */\n                            //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                            if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                                if (settings.eDec !== null && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (settings.scaleDivisor && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (!settings.aStor) {\n                                    var toStrip = void 0;\n                                    if (settings.nBracket !== null && settings.aNeg !== '') {\n                                        settings.onOff = true;\n                                        toStrip = negativeBracket(currentValue, settings);\n                                    } else {\n                                        toStrip = currentValue;\n                                    }\n                                    settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                                }\n                                setValue = false;\n                            }\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                //TODO Extract the event listeners to another function\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.scaleDivisor) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.nSep) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                            $settings.aSuffix = '';\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n                            $this.change();\n                            holder.inVal = $this.val();\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                            $settings.aSuffix = $settings.oSuffix;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.scaleDivisor) {\n                                    value = value / $settings.scaleDivisor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.scaleDivisor && $settings.scaleDecimal ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSymbol ? groupedValue + $settings.scaleSymbol : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * autoNumeric function\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /*\n     * Defaults options are public - these can be overridden by the following:\n     * - HTML5 data attributes\n     * - Options passed by the 'init' or 'update' methods\n     * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n     */\n    $.fn.autoNumeric.defaults = {\n        /* Allowed thousand separator characters\n         * comma = \",\"\n         * period \"full stop\" = \".\"\n         * apostrophe is escaped = \"\\\"\"\n         * space = \" \"\n         * none = \"\"\n         * NOTE: do not use numeric characters\n         */\n        aSep: ',',\n\n        /* When true => removes the thousand seperator, currency symbol & suffix \"focusin\"\n         * example if the input value \"$ 1,999.88 suffix\"\n         * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n         */\n        nSep: false,\n\n        /* Digital grouping for the thousand separator used in Format\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n         * dGroup: \"3\", results in 999,999,999 default\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n         */\n        dGroup: '3',\n\n        /* Allowed decimal separator characters\n         * period \"full stop\" = \".\"\n         * comma = \",\"\n         */\n        aDec: '.',\n\n        /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n         * developed for countries the use a comma \",\" as the decimal character\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\n         * Must be in quotes aSign: \"$\"\n         * space to the right of the currency symbol aSign: '$ '\n         * space to the left of the currency symbol aSign: ' $'\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\n         * for prefix pSign: \"p\" (default)\n         * for suffix pSign: \"s\"\n         */\n        pSign: 'p',\n\n        /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n         * -1,234.56  => default no options required\n         * -$1,234.56 => {aSign: \"$\"}\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n         * 1,234.56-  => {pNeg: \"s\"}\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n         * Numeric characters and negative sign not allowed'\n         */\n        aSuffix: '',\n\n        /* Override min max limits\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n         * oLimits: \"ignore\" ignores both vMin & vMax\n         */\n        oLimits: null,\n\n        /* Maximum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be larger than vMin\n         */\n        vMax: '9999999999999.99',\n\n        /* Minimum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be smaller than vMax\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n         * value must be enclosed in quotes example mDec: \"3\",\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n         * the \"get\" method returns the extended decimal places\n         */\n        eDec: null,\n\n        /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n         * Please note that the non-scaled value is held in data and it is advised that you use the \"aStore\" option to ensure retaining the value         * [\"divisor\", \"decimal places\", \"symbol\"]\n         * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n         * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n         */\n\n        /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n         * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n         * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n         * The \"get\" method returns the full value, including the 'hidden' decimals.\n         */\n        scaleDivisor: null,\n\n        /*\n         * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n         * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n         */\n        scaleDecimal: null,\n\n        /*\n         * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n         * This is optional too.\n         */\n        scaleSymbol: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\n         * if ie 6 or 7 the value will be saved as a session cookie\n         */\n        aStor: false,\n\n        /* method used for rounding\n         * mRound: \"S\", Round-Half-Up Symmetric (default)\n         * mRound: \"A\", Round-Half-Up Asymmetric\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n         * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n         * mRound: \"U05\" Rounds up to next .05\n         * mRound: \"D05\" Rounds down to next .05\n         */\n        mRound: 'S',\n\n        /* Controls decimal padding\n         * aPad: true - always Pad decimals with zeros\n         * aPad: false - does not pad with zeros.\n         * Note: setting aPad to 'false' will override the 'mDec' setting.\n         *\n         * thanks to Jonas Johansson for the suggestion\n         */\n        aPad: true,\n\n        /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n         * Those brackets are visible only when the field does NOT have the focus.\n         * The left and right symbols should be enclosed in quotes and separated by a comma\n         * nBracket: null - (default)\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\n         * wEmpty: \"always\" - always displays the currency sign only\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n         */\n        //TODO Add an option to display the currency sign only on hover (if the input is empty)\n        wEmpty: 'focus',\n\n        /* Controls leading zero behavior\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n         * lZero: \"deny\", - allows only one leading zero on values less than one\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n         */\n        lZero: 'allow',\n\n        /* Determine if the default value will be formatted on initialization.\n         * true = automatically formats the default value on initialization\n         * false = will not format the default value\n         */\n        aForm: true,\n\n        /* Determine if the select all keyboard command will select\n         * the complete input text or only the input numeric value\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n         */\n        sNumber: false,\n\n        /* Helper option for ASP.NET postback\n         * should be the value of the unformatted default value\n         * examples:\n         * no default value=\"\" {anDefault: \"\"}\n         * value=1234.56 {anDefault: '1234.56'}\n         */\n        anDefault: null,\n\n        /* Removes formatting on submit event\n         * this output format: positive nnnn.nn, negative -nnnn.nn\n         * review the 'unSet' method for other formats\n         */\n        unSetOnSubmit: false,\n\n        /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n         * null => nnnn.nn or -nnnn.nn default\n         * \",\"  => nnnn,nn or -nnnn,nn can also be \"-,\"\n         * \".-\" => nnnn.nn or nnnn.nn-\n         * \",-\" => nnnn,nn or nnnn,nn-\n         */\n        localeOutput: null,\n\n        /* Error handling function\n         * true => all errors are thrown - helpful in site development\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.', debug);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, $.fn.autoNumeric.defaults, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.', debug);\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.', debug);\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.', debug);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.', debug);\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.', debug);\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.', debug);\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.', debug);\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.', debug);\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.', debug);\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.', debug);\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.', debug);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.', debug);\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.', debug);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.', debug);\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.', debug);\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.', debug);\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.', debug);\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.', debug);\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.', debug);\n        }\n\n        if (!isNull(options.localeOutput) && !isInArray(options.localeOutput, ['.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'localeOutput\\' is invalid ; it should either be empty, \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.localeOutput + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.', debug);\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\n        eventInfo.detail = detail;\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJpc051bGwiLCJ2YWx1ZSIsImlzVW5kZWZpbmVkIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc1RydWVPckZhbHNlU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzT2JqZWN0IiwicmVmZXJlbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJoYXNEZWNpbWFscyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJkZWNpbWFsUGxhY2VzIiwibGVuZ3RoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwidGV4dCIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJkZWJ1ZyIsIndhcm5pbmciLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3MiLCIkdGhpcyIsInNldHRpbmdzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsImRlY0xlbmd0aCIsInZNaW4iLCJ2TWF4Iiwidk1heExlbmd0aCIsInZNaW5MZW5ndGgiLCJNYXRoIiwibWF4IiwiYXV0b0NvZGUiLCJhTmVnIiwicmVwbGFjZSIsIm1JbnRQb3MiLCJtSW50TmVnIiwibURlYyIsIm9EZWMiLCJOdW1iZXIiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJhbHREZWMiLCJhRGVjIiwiYVNlcCIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsImF1dG9TdHJpcCIsImFTaWduIiwiYVN1ZmZpeCIsInBOZWciLCJwU2lnbiIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJsWmVybyIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwiY2hhckF0Iiwic2xpY2UiLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwibkJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpdiIsInNpZ25PbkVtcHR5Iiwid0VtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnIiwiZGlnaXRhbEdyb3VwIiwiZEdyb3VwIiwidGVzdCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsIml2Um91bmRlZCIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsIm1Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwicmVzdWx0IiwiYVBhZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsIm9MaW1pdHMiLCJhdXRvR2V0IiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiaG9sZGVyIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwT3JpZ2luYWxTZXR0aW5ncyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsIm9TdWZmaXgiLCJyZWFkQ29va2llIiwibmFtZSIsIm5hbWVFUSIsImNhIiwiY29va2llIiwic3RvcmFnZVRlc3QiLCJtb2QiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiYXV0b1NhdmUiLCJ0b0RvIiwiYVN0b3IiLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsImZvcm1hdHRlZCIsInNldHRpbmdzQ2xvbmUiLCJpbml0IiwiY3RybEtleSIsImNtZEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInR5cGUiLCJrZENvZGUiLCJ3aGljaCIsInByb2Nlc3NlZCIsInNldFNlbGVjdGlvbiIsInNldFJlYWwiLCJtaW4iLCJzZXRQb3NpdGlvbiIsInBvcyIsImdldEJlZm9yZUFmdGVyIiwibGVmdCIsInJpZ2h0IiwiZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkIiwibm9ybWFsaXplUGFydHMiLCJuZXdWYWx1ZSIsInNldFZhbHVlUGFydHMiLCJhZHZlbnQiLCJwYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwidHJpZ2dlciIsInNpZ25Qb3NpdGlvbiIsImFTaWduTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJleHBhbmRTZWxlY3Rpb25PblNpZ24iLCJjaGVja1Bhc3RlIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0Iiwic3Vic3RyIiwic2tpcEFsd2F5cyIsInNOdW1iZXIiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsImFTdWZmaXhMZW4iLCJzdGFydEp1bXAiLCJwcm9jZXNzVHJhaWxpbmciLCJjYXJldEZpeCIsIkJvb2xlYW4iLCJwcm9jZXNzQWx3YXlzIiwidGhyb3dJbnB1dCIsInByb2Nlc3NLZXlwcmVzcyIsImNDb2RlIiwiZnJvbUNoYXJDb2RlIiwiZm9ybWF0UXVpY2siLCJsZWZ0TGVuZ3RoIiwia3VDb2RlIiwic3ViUGFydHMiLCJsZWZ0QXIiLCJzaGlmdCIsInB1c2giLCJzaWduUGFydHMiLCJlc2NhcGVDaHIiLCJlc2NhcGVkUGFydHMiLCJtaW5pUGFydHMiLCJsZWZ0UmVnIiwibmV3TGVmdCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsImluQXJyYXkiLCJ0ZXN0SW5wdXQiLCJsb2NhbGVPdXRwdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJpbnB1dFZhbHVlIiwibW9kaWZpZWRJbnB1dFZhbHVlIiwibWV0aG9kcyIsIm9wdGlvbnMiLCJ0YWdEYXRhIiwiJGlucHV0IiwiaXMiLCJhbGxvd2VkVGFnTGlzdCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZXh0ZW5kIiwiZm4iLCJkZWZhdWx0cyIsInJ1bk9uY2UiLCJ0YWdMaXN0Iiwia2V5IiwiYUZvcm0iLCJzZXRWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImF0dHIiLCJ0ZXN0ZWRDdXJyZW50VmFsdWUiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJJbmZpbml0eSIsImFuRGVmYXVsdCIsImlzTnVtZXJpYyIsImVEZWMiLCJ0b1N0cmlwIiwib24iLCIkc2V0dGluZ3MiLCJuU2VwIiwiaW5WYWwiLCJsYXN0VmFsIiwib25FbXB0eSIsInJlYWRPbmx5Iiwic2tpcCIsInRhYiIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsInNjYWxlU3ltYm9sIiwiY2hhbmdlIiwicHJlcGFyZSIsImlzVmFsaWQiLCJvbGRSYXdWYWx1ZSIsInByZWZpeCIsInN1ZmZpeCIsInBhc3RlZFRleHQiLCJvcmlnaW5hbEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJ2YWx1ZU9mIiwiY2xvc2VzdCIsInVuU2V0T25TdWJtaXQiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJ2YWx1ZUluIiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwibWV0aG9kIiwiYXJncyIsImFwcGx5Iiwic2VuZEN1c3RvbUV2ZW50IiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJkcFZNaW4iLCJkcFZNYXgiLCJ2TWluTWF4RGVjaW1hbFBsYWNlcyIsImVycm9yIiwiY3JlYXRlQ3VzdG9tRXZlbnQiLCJldmVudE5hbWUiLCJkZXRhaWwiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50IiwicGFyYW1zIiwiZXZ0IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJFdmVudCIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQSxJQUFJQSxtQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBOztBQUVDLFdBQVNDLE9BQVQsRUFBa0I7QUFDZjtBQUNKLFFBQUksSUFBSixFQUFnRDtBQUM1QztBQUNBQyxRQUFBLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxvQ0FBbUJELE9BQW5CO0FBQ0gsS0FIRCxNQUdPLElBQUksUUFBT0UsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QkEsT0FBT0MsT0FBekMsRUFBa0Q7QUFDckQ7QUFDQUQsZUFBT0MsT0FBUCxHQUFpQkgsUUFBUUksUUFBUSxRQUFSLENBQVIsQ0FBakI7QUFDSCxLQUhNLE1BR0E7QUFDSDtBQUNBSixnQkFBUUssT0FBT0MsTUFBZjtBQUNIO0FBQ0EsQ0FaQSxFQVlDLGFBQUs7QUFDSDs7O0FBR0EsUUFBTUMsVUFBVTtBQUNaQyxtQkFBZ0IsQ0FESjtBQUVaQyxhQUFnQixDQUZKO0FBR1pDLGVBQWdCLEVBSEo7QUFJWkMsZUFBZ0IsRUFKSjtBQUtaQyxjQUFnQixFQUxKO0FBTVpDLGFBQWdCLEVBTko7QUFPWkMsb0JBQWdCLEVBUEo7QUFRWkMsa0JBQWdCLEVBUko7QUFTWkMsYUFBZ0IsRUFUSjtBQVVaQyxlQUFnQixFQVZKO0FBV1pDLGdCQUFnQixFQVhKO0FBWVpDLGtCQUFnQixFQVpKO0FBYVpDLGFBQWdCLEVBYko7QUFjWkMsY0FBZ0IsRUFkSjtBQWVaQyxtQkFBZ0IsRUFmSjtBQWdCWkMsaUJBQWdCLEVBaEJKO0FBaUJaQyxvQkFB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LFlBQVc7QUFDUixZQUFJLE9BQU9wZSxPQUFPcWUsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQVNBLFdBQVQsQ0FBcUJJLEtBQXJCLEVBQTRCQyxNQUE1QixFQUFvQztBQUNoQ0EscUJBQVNBLFVBQVUsRUFBRUosU0FBUyxLQUFYLEVBQWtCQyxZQUFZLEtBQTlCLEVBQXFDSCxRQUFRLEtBQUssQ0FBbEQsRUFBbkI7QUFDQSxnQkFBTU8sTUFBTTFWLFNBQVMyVixXQUFULENBQXFCLGFBQXJCLENBQVo7QUFDQUQsZ0JBQUlFLGVBQUosQ0FBb0JKLEtBQXBCLEVBQTJCQyxPQUFPSixPQUFsQyxFQUEyQ0ksT0FBT0gsVUFBbEQsRUFBOERHLE9BQU9OLE1BQXJFO0FBQ0EsbUJBQU9PLEdBQVA7QUFDSDs7QUFFRE4sb0JBQVluVyxTQUFaLEdBQXdCbEksT0FBTzhlLEtBQVAsQ0FBYTVXLFNBQXJDO0FBQ0FsSSxlQUFPcWUsV0FBUCxHQUFxQkEsV0FBckI7QUFDSCxLQWREO0FBZUgsQ0E1bUdBLENBQUQ7O0FBOG1HQTs7O2tCQUdlO0FBQ1hVLFlBQVV6ZixVQURDO0FBRVgwZixjQUFVemYsWUFGQztBQUdYQyxzQ0FIVztBQUlYQyxzQkFKVyxFQUlEO0FBQ1ZDLHNDQUxXLEUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuKiBhdXRvTnVtZXJpYy5qc1xuKiBAYXV0aG9yOiBCb2IgS25vdGhlXG4qIEBjb250cmlidXRvcnM6IFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzXG4qIEB2ZXJzaW9uOiAyLjAgLSAyMDE2LTExLTI3IFVUQyAxMTowMFxuKlxuKiBDcmVhdGVkIGJ5IFJvYmVydCBKLiBLbm90aGUgb24gMjAwOS0wOC0wOS4gUGxlYXNlIHJlcG9ydCBhbnkgYnVncyB0byBodHRwczovL2dpdGh1Yi5jb20vQm9iS25vdGhlL2F1dG9OdW1lcmljXG4qXG4qIENvcHlyaWdodCAoYykgMjAwOSBSb2JlcnQgSi4gS25vdGhlIGh0dHA6Ly93d3cuZGVjb3JwbGFuaXQuY29tL3BsdWdpbi9cbipcbiogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xubGV0IHZhbGlkYXRlO1xubGV0IGFyZVNldHRpbmdzVmFsaWQ7XG5cbi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIC8vVE9ETyBUaGlzIHN1cmVseSBjYW4gYmUgaW1wcm92ZWQgYnkgbGV0dGluZyB3ZWJwYWNrIHRha2UgY2FyZSBvZiBnZW5lcmF0aW5nIHRoaXMgVU1EIHBhcnRcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xufSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBmYWN0b3J5KHdpbmRvdy5qUXVlcnkpO1xufVxufSgkID0+IHtcbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXlDb2RlIGFzIHNlZW4gaW4gRE9NIGV2ZW50cy5cbiAgICAgKi9cbiAgICBjb25zdCBrZXlDb2RlID0ge1xuICAgICAgICBCYWNrc3BhY2U6ICAgICAgOCxcbiAgICAgICAgVGFiOiAgICAgICAgICAgIDksXG4gICAgICAgIEVudGVyOiAgICAgICAgICAxMyxcbiAgICAgICAgU2hpZnQ6ICAgICAgICAgIDE2LFxuICAgICAgICBDdHJsOiAgICAgICAgICAgMTcsXG4gICAgICAgIEFsdDogICAgICAgICAgICAxOCxcbiAgICAgICAgUGF1c2VCcmVhazogICAgIDE5LFxuICAgICAgICBDYXBzTG9jazogICAgICAgMjAsXG4gICAgICAgIEVzYzogICAgICAgICAgICAyNyxcbiAgICAgICAgU3BhY2U6ICAgICAgICAgIDMyLFxuICAgICAgICBQYWdlVXA6ICAgICAgICAgMzMsXG4gICAgICAgIFBhZ2VEb3duOiAgICAgICAzNCxcbiAgICAgICAgRW5kOiAgICAgICAgICAgIDM1LFxuICAgICAgICBIb21lOiAgICAgICAgICAgMzYsXG4gICAgICAgIExlZnRBcnJvdzogICAgICAzNyxcbiAgICAgICAgVXBBcnJvdzogICAgICAgIDM4LFxuICAgICAgICBSaWdodEFycm93OiAgICAgMzksXG4gICAgICAgIERvd25BcnJvdzogICAgICA0MCxcbiAgICAgICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxuICAgICAgICBEZWxldGU6ICAgICAgICAgNDYsXG4gICAgICAgIG51bTA6ICAgICAgICAgICA0OCxcbiAgICAgICAgbnVtMTogICAgICAgICAgIDQ5LFxuICAgICAgICBudW0yOiAgICAgICAgICAgNTAsXG4gICAgICAgIG51bTM6ICAgICAgICAgICA1MSxcbiAgICAgICAgbnVtNDogICAgICAgICAgIDUyLFxuICAgICAgICBudW01OiAgICAgICAgICAgNTMsXG4gICAgICAgIG51bTY6ICAgICAgICAgICA1NCxcbiAgICAgICAgbnVtNzogICAgICAgICAgIDU1LFxuICAgICAgICBudW04OiAgICAgICAgICAgNTYsXG4gICAgICAgIG51bTk6ICAgICAgICAgICA1NyxcbiAgICAgICAgYTogICAgICAgICAgICAgIDY1LFxuICAgICAgICBiOiAgICAgICAgICAgICAgNjYsXG4gICAgICAgIGM6ICAgICAgICAgICAgICA2NyxcbiAgICAgICAgZDogICAgICAgICAgICAgIDY4LFxuICAgICAgICBlOiAgICAgICAgICAgICAgNjksXG4gICAgICAgIGY6ICAgICAgICAgICAgICA3MCxcbiAgICAgICAgZzogICAgICAgICAgICAgIDcxLFxuICAgICAgICBoOiAgICAgICAgICAgICAgNzIsXG4gICAgICAgIGk6ICAgICAgICAgICAgICA3MyxcbiAgICAgICAgajogICAgICAgICAgICAgIDc0LFxuICAgICAgICBrOiAgICAgICAgICAgICAgNzUsXG4gICAgICAgIGw6ICAgICAgICAgICAgICA3NixcbiAgICAgICAgbTogICAgICAgICAgICAgIDc3LFxuICAgICAgICBuOiAgICAgICAgICAgICAgNzgsXG4gICAgICAgIG86ICAgICAgICAgICAgICA3OSxcbiAgICAgICAgcDogICAgICAgICAgICAgIDgwLFxuICAgICAgICBxOiAgICAgICAgICAgICAgODEsXG4gICAgICAgIHI6ICAgICAgICAgICAgICA4MixcbiAgICAgICAgczogICAgICAgICAgICAgIDgzLFxuICAgICAgICB0OiAgICAgICAgICAgICAgODQsXG4gICAgICAgIHU6ICAgICAgICAgICAgICA4NSxcbiAgICAgICAgdjogICAgICAgICAgICAgIDg2LFxuICAgICAgICB3OiAgICAgICAgICAgICAgODcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICA4OCxcbiAgICAgICAgeTogICAgICAgICAgICAgIDg5LFxuICAgICAgICB6OiAgICAgICAgICAgICAgOTAsXG4gICAgICAgIFdpbmRvd3M6ICAgICAgICA5MSxcbiAgICAgICAgUmlnaHRDbGljazogICAgIDkzLFxuICAgICAgICBudW1wYWQwOiAgICAgICAgOTYsXG4gICAgICAgIG51bXBhZDE6ICAgICAgICA5NyxcbiAgICAgICAgbnVtcGFkMjogICAgICAgIDk4LFxuICAgICAgICBudW1wYWQzOiAgICAgICAgOTksXG4gICAgICAgIG51bXBhZDQ6ICAgICAgICAxMDAsXG4gICAgICAgIG51bXBhZDU6ICAgICAgICAxMDEsXG4gICAgICAgIG51bXBhZDY6ICAgICAgICAxMDIsXG4gICAgICAgIG51bXBhZDc6ICAgICAgICAxMDMsXG4gICAgICAgIG51bXBhZDg6ICAgICAgICAxMDQsXG4gICAgICAgIG51bXBhZDk6ICAgICAgICAxMDUsXG4gICAgICAgIE11bHRpcGx5TnVtcGFkOiAxMDYsXG4gICAgICAgIFBsdXNOdW1wYWQ6ICAgICAxMDcsXG4gICAgICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXG4gICAgICAgIERvdE51bXBhZDogICAgICAxMTAsXG4gICAgICAgIFNsYXNoTnVtcGFkOiAgICAxMTEsXG4gICAgICAgIEYxOiAgICAgICAgICAgICAxMTIsXG4gICAgICAgIEYyOiAgICAgICAgICAgICAxMTMsXG4gICAgICAgIEYzOiAgICAgICAgICAgICAxMTQsXG4gICAgICAgIEY0OiAgICAgICAgICAgICAxMTUsXG4gICAgICAgIEY1OiAgICAgICAgICAgICAxMTYsXG4gICAgICAgIEY2OiAgICAgICAgICAgICAxMTcsXG4gICAgICAgIEY3OiAgICAgICAgICAgICAxMTgsXG4gICAgICAgIEY4OiAgICAgICAgICAgICAxMTksXG4gICAgICAgIEY5OiAgICAgICAgICAgICAxMjAsXG4gICAgICAgIEYxMDogICAgICAgICAgICAxMjEsXG4gICAgICAgIEYxMTogICAgICAgICAgICAxMjIsXG4gICAgICAgIEYxMjogICAgICAgICAgICAxMjMsXG4gICAgICAgIE51bUxvY2s6ICAgICAgICAxNDQsXG4gICAgICAgIFNjcm9sbExvY2s6ICAgICAxNDUsXG4gICAgICAgIE15Q29tcHV0ZXI6ICAgICAxODIsXG4gICAgICAgIE15Q2FsY3VsYXRvcjogICAxODMsXG4gICAgICAgIFNlbWljb2xvbjogICAgICAxODYsXG4gICAgICAgIEVxdWFsOiAgICAgICAgICAxODcsXG4gICAgICAgIENvbW1hOiAgICAgICAgICAxODgsXG4gICAgICAgIEh5cGhlbjogICAgICAgICAxODksXG4gICAgICAgIERvdDogICAgICAgICAgICAxOTAsXG4gICAgICAgIFNsYXNoOiAgICAgICAgICAxOTEsXG4gICAgICAgIEJhY2txdW90ZTogICAgICAxOTIsXG4gICAgICAgIExlZnRCcmFja2V0OiAgICAyMTksXG4gICAgICAgIEJhY2tzbGFzaDogICAgICAyMjAsXG4gICAgICAgIFJpZ2h0QnJhY2tldDogICAyMjEsXG4gICAgICAgIFF1b3RlOiAgICAgICAgICAyMjIsXG4gICAgICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nICd0cnVlJyBvciAnZmFsc2UnXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW55IGNhc2VzIGZvciB0aG9zZSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHJ1ZU9yRmFsc2VTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyY2FzZVZhbHVlID09PSAnZmFsc2UnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eVxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3OTkxNS9ob3ctZG8taS10ZXN0LWZvci1hbi1lbXB0eS1qYXZhc2NyaXB0LW9iamVjdCBhbmQgaHR0cDovL2pzcGVyZi5jb20vZW1wdHktb2JqZWN0LXRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICogUmV0dXJuIGBudWxsYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge251bGx8aW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY2ltYWxQYXJ0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSBlcnJvcnMgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UsIGRlYnVnID0gdHJ1ZSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSB3YXJuaW5nIG1lc3NhZ2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCBzdXBwcmVzc1dhcm5pbmdzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJ1biBjYWxsYmFja3MgaW4gcGFyYW1ldGVycyBpZiBhbnlcbiAgICAgKiBhbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKSB7XG4gICAgICAgIC8vIGxvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoaywgdmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbHMgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGZyb20gdGhlIGh0bWw1IGRhdGEgZXhhbXBsZTogZGF0YS1hLXNpZ249XCJmdW5jdGlvbk5hbWVcIlxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIHZNaW4gdk1heCBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY0xlbmd0aCh2TWluLCB2TWF4KSB7XG4gICAgICAgIGxldCB2TWF4TGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHZNaW5MZW5ndGggPSAwO1xuICAgICAgICBpZiAodk1heFsxXSkge1xuICAgICAgICAgICAgdk1heExlbmd0aCA9IHZNYXhbMV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2TWluWzFdKSB7XG4gICAgICAgICAgICB2TWluTGVuZ3RoID0gdk1pblsxXS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodk1heExlbmd0aCwgdk1pbkxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyaW5nIHVzZXIgZGVmaW5lZCBvcHRpb25zIGZvciBmdXJ0aGVyIHVzYWdlXG4gICAgICogbWVyZ2UgdGhlbSB3aXRoIGRlZmF1bHRzIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvQ29kZSgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgcnVuQ2FsbGJhY2tzKCR0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IHZNYXggPSBzZXR0aW5ncy52TWF4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIHNldHRpbmdzLmFOZWcgPSBzZXR0aW5ncy52TWluIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2TWF4WzBdID0gdk1heFswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB2TWluWzBdID0gdk1pblswXS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBzZXR0aW5ncy5tSW50UG9zID0gTWF0aC5tYXgodk1heFswXS5sZW5ndGgsIDEpO1xuICAgICAgICBzZXR0aW5ncy5tSW50TmVnID0gTWF0aC5tYXgodk1pblswXS5sZW5ndGgsIDEpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IGRlY0xlbmd0aCh2TWluLCB2TWF4KTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IE51bWJlcihzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuXG4gICAgICAgIC8vIHNldCBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciBrZXlcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5tRGVjID4gMCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09ICcuJyAmJiBzZXR0aW5ncy5hU2VwICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmFEZWMgPT09ICcsJyAmJiBzZXR0aW5ncy5hU2VwICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWNoZSByZWdleHBzIGZvciBhdXRvU3RyaXBcbiAgICAgICAgY29uc3QgYU5lZ1JlZyA9IHNldHRpbmdzLmFOZWcgP2AoWy1cXFxcJHtzZXR0aW5ncy5hTmVnfV0/KWAgOicoLT8pJztcbiAgICAgICAgc2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG4gICAgICAgIHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ31bXi0keyhzZXR0aW5ncy5hTmVnP2BcXFxcJHtzZXR0aW5ncy5hTmVnfWA6JycpfVxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdLio/KFxcXFxkfFxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQpYCk7XG4gICAgICAgIHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgKFxcXFxkXFxcXCR7c2V0dGluZ3MuYURlY30/KVteXFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZF1cXFxcRCokYCk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XG4gICAgICAgIHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCR7YU5lZ1JlZ30oPzpcXFxcJHtzZXR0aW5ncy5hRGVjfT8oXFxcXGQrXFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCspfChcXFxcZCooPzpcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKik/KSlgKTtcblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RyaXAgYWxsIHVud2FudGVkIGNoYXJhY3RlcnMgYW5kIGxlYXZlIG9ubHkgYSBudW1iZXIgYWxlcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU3RyaXAocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTaWduICE9PSAnJykge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVNpZ24sICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYVN1ZmZpeCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLmFTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU3VmZml4LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgY29udGFpbnMocywgJy0nKSAmJiBzICE9PSAnJykge1xuICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgYW55dGhpbmcgYWZ0ZXIgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAsICckMScpO1xuXG4gICAgICAgIC8vIHRoZW4gcmVtb3ZlIGFueSB1bmludGVyZXN0ZWQgY2hhcmFjdGVyc1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbHREZWMsIHNldHRpbmdzLmFEZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xuICAgICAgICBpZiAoc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycgfHwgc2V0dGluZ3MubFplcm8gPT09ICdrZWVwJykge1xuICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoc2V0dGluZ3MuYURlYyk7XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0O1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKG1vZGlmaWVkSW50ZWdlclBhcnQsIHNldHRpbmdzLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgblNpZ24gPSBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnRQb3MgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgaWYgKG5TaWduICE9PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnROZWcgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IGAke25TaWdufSR7bW9kaWZpZWRJbnRlZ2VyUGFydH0ke2lzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KT8nJzpzZXR0aW5ncy5hRGVjICsgZGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLmxaZXJvID09PSAnZGVueScpIHx8IChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyAmJiBzZXR0aW5ncy5vbk9mZiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyB0aGlzIHJlZ2V4IHZlcnNpb24gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGR8JClgIGVudGlyZWx5IGNsZWFyIHRoZSBpbnB1dCBvbiBibHVyXG4gICAgICAgICAgICBsZXQgc3RyaXBSZWcgPSBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZClgO1xuICAgICAgICAgICAgc3RyaXBSZWcgPSBuZXcgUmVnRXhwKHN0cmlwUmVnKTtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwbGFjZXMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGl2ZUJyYWNrZXQocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3AnKSkge1xuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubkJyYWNrZXQuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgICAgICBzID0gZmlyc3RCcmFja2V0ICsgcyArIGxhc3RCcmFja2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vbk9mZiAmJiBzLmNoYXJBdCgwKSA9PT0gZmlyc3RCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UobGFzdEJyYWNrZXQsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgbG9jYWxlIGZvcm1hdCB0byBKYXZhc2NyaXB0IG51bWVyaWMgc3RyaW5nXG4gICAgICogYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIHBlcmlvZCBvciBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkIG9mIGN1cnJlbmN5IHNpZ25zIGFsbG93ZWRcbiAgICAgKiAnMTIzNC41NicgICAgT0tcbiAgICAgKiAnLTEyMzQuNTYnICAgT0tcbiAgICAgKiAnMTIzNC41Ni0nICAgT0tcbiAgICAgKiAnMTIzNCw1NicgICAgT0tcbiAgICAgKiAnLTEyMzQsNTYnICAgT0tcbiAgICAgKiAnMTIzNCw1Ni0nICAgT0tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTG9jYWxlKHMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIGlmIChjb250YWlucyhzLCAnLScpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgcyA9ICctJyArIHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnRcbiAgICAgKiBzZWUgXCJsb2NhbGVPdXRwdXRcIiBvcHRpb24gZm9yIGRldGVybWluZVxuICAgICAqIG51bGwgPT4gbm5ubi5ubiBvciAtbm5ubi5ubiBkZWZhdWx0XG4gICAgICogXCIsXCIgID0+IG5ubm4sbm4gb3IgLW5ubm4sbm4gY2FuIGFscyBiZSBcIi0sXCJcbiAgICAgKiBcIi4tXCIgPT4gbm5ubi5ubiBvciBubm5uLm5uLVxuICAgICAqIFwiLC1cIiA9PiBubm5uLG5uIG9yIG5ubm4sbm4tXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAobG9jYWxlID09PSAnLi0nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5zKHZhbHVlLCAnLScpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcsJyB8fCBsb2NhbGUgPT09ICctLCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJywtJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgICAgIHZhbHVlID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJlcGFyZSBudW1iZXIgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byByZWFsIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpeE51bWJlcihzLCBhRGVjLCBhTmVnKSB7XG4gICAgICAgIGlmIChhRGVjICYmIGFEZWMgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShhRGVjLCAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhTmVnICYmIGFOZWcgIT09ICctJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShhTmVnLCAnLScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcy5tYXRjaCgvXFxkLykpIHtcbiAgICAgICAgICAgIHMgKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJlcGFyZSByZWFsIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gb3VyIGZvcm1hdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXNlbnROdW1iZXIocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFOZWcgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJy0nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgJiYgc2V0dGluZ3MuYURlYyAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRW1wdHkoaXYsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xuICAgICAgICBpZiAoaXYgPT09ICcnIHx8IGl2ID09PSBzZXR0aW5ncy5hTmVnKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud0VtcHR5ID09PSAnYWx3YXlzJyB8fCBzaWduT25FbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSA/IGl2ICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hU3VmZml4IDogc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBvdXIgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dyb3VwKGl2LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc3RyaXApIHtcbiAgICAgICAgICAgIGl2ID0gYXV0b1N0cmlwKGl2LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGl2LCAnLScpKSB7XG4gICAgICAgICAgICBpdiA9ICctJyArIGl2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtcHR5ID0gY2hlY2tFbXB0eShpdiwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBpc05lZyA9IGNvbnRhaW5zKGl2LCAnLScpO1xuICAgICAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgICAgIGl2ID0gaXYucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1wdHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwID0gJyc7XG4gICAgICAgIHNldHRpbmdzLmRHcm91cCA9IHNldHRpbmdzLmRHcm91cC50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnMicpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnMnMnKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICc0Jykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHszfT8pKykkLztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwbGl0cyB0aGUgc3RyaW5nIGF0IHRoZSBkZWNpbWFsIHN0cmluZ1xuICAgICAgICBsZXQgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpdi5zcGxpdChzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYyAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaXYuc3BsaXQoc2V0dGluZ3MuYWx0RGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYVNlcCAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIHJlLWluc2VydHMgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHdoaWxlIChkaWdpdGFsR3JvdXAudGVzdChpbnRlZ2VyUGFydCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0LnJlcGxhY2UoZGlnaXRhbEdyb3VwLCBgJDEke3NldHRpbmdzLmFTZXB9JDJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyAhPT0gMCAmJiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MubURlYykge1xuICAgICAgICAgICAgICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIHNldHRpbmdzLm1EZWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqb2lucyB0aGUgd2hvbGUgbnVtYmVyIHdpdGggdGhlIGRlY2ltYWwgdmFsdWVcbiAgICAgICAgICAgIGl2ID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5hRGVjICsgZGVjaW1hbFBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB3aG9sZSBudW1iZXJzIG9ubHlcbiAgICAgICAgICAgIGl2ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFOZWcgKyBzZXR0aW5ncy5hU2lnbiArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hTmVnICsgaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIGl2ICsgc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOZWcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBpdiA9IGl2ICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hTmVnICsgaXYgKyBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOZWcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IGl2ICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIGFuZCBwbGFjZXMgYnJhY2tldHNcbiAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIChzZXR0aW5ncy5yYXdWYWx1ZSA8IDAgfHwgaXYuY2hhckF0KDApID09PSAnLScpKSB7XG4gICAgICAgICAgICBpdiA9IG5lZ2F0aXZlQnJhY2tldChpdiwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gaXYgKyBzZXR0aW5ncy5hU3VmZml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYykge1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIHN3aXRjaCAockRlYykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHRvIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdFxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC4oPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIEFsbG93cyBwYWRkaW5nIHdoZW4gbURlYyBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIG1EZWMgbGVuZ3RoIHdoZW4gYVBhZCBpcyBzZXQgdHJ1ZVxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcbiAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAockRlYyA9PT0gMCkge1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdW5kIG51bWJlciBhZnRlciBzZXR0aW5nIGJ5IHBhc3Rpbmcgb3IgJCgpLmF1dG9OdW1lcmljU2V0KClcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIGZvciByb3VuZCB0aGUgbnVtYmVyXG4gICAgICogcGxlYXNlIG5vdGUgdGhpcyBoYW5kbGVkIGFzIHRleHQgLSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlc1xuICAgICAqIGFsc28gdGhpcyBvZmZlcnMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcyB0aGF0IGFyZSBub3QgZWFzaWx5IGFjY29tcGxpc2hlZCBpbiBKYXZhU2NyaXB0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1JvdW5kKGl2LCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcbiAgICAgICAgaXYgPSAoaXYgPT09ICcnKSA/ICcwJyA6IGl2LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tUm91bmQgPT09ICdOMDUnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0NIRicgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdEMDUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1Sb3VuZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ04wNSc6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGgucm91bmQoaXYgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5jZWlsKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLmZsb29yKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGl2LCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXYgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoIC0gaXYuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXZSb3VuZGVkID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgIGxldCByRGVjO1xuXG4gICAgICAgIC8vIHNldHMgdGhlIHRydW5jYXRlIHplcm8gbWV0aG9kXG4gICAgICAgIGlmIChzZXR0aW5ncy5hUGFkKSB7XG4gICAgICAgICAgICByRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJEZWMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpdiAoaW5wdXQgVmFsdWUpIGlzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgaWYgKGl2LmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICctJztcblxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB0aGF0IHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSB0byBiZSBhIGRvdClcbiAgICAgICAgaWYgKCFpdi5tYXRjaCgvXlxcZC8pKSB7XG4gICAgICAgICAgICBpdiA9ICcwJyArIGl2O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBOdW1iZXIoaXYpID09PSAwKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXG4gICAgICAgIGlmICgoTnVtYmVyKGl2KSA+IDAgJiYgc2V0dGluZ3MubFplcm8gIT09ICdrZWVwJykgfHwgKGl2Lmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycpKSB7XG4gICAgICAgICAgICBpdiA9IGl2LnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkUG9zID0gaXYubGFzdEluZGV4T2YoJy4nKTtcblxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdmRQb3MgPSAoZFBvcyA9PT0gLTEpID8gaXYubGVuZ3RoIC0gMSA6IGRQb3M7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGRlY2ltYWwgcGxhY2VzIHRvIGRldGVybWluZSBpZiByb3VuZGluZyBpcyByZXF1aXJlZCA6XG4gICAgICAgIC8vIENoZWNrIGlmIG5vIHJvdW5kaW5nIGlzIHJlcXVpcmVkXG4gICAgICAgIGxldCBjRGVjID0gKGl2Lmxlbmd0aCAtIDEpIC0gdmRQb3M7XG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2O1xuICAgICAgICAgICAgaWYgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCByRGVjIC0gY0RlYyk7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSB6ZXJvcztcbiAgICAgICAgICAgICAgICAgICAgY0RlYyArPSB6ZXJvcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID4gckRlYykge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCByRGVjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiByRGVjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3VuZGVkIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgIGNvbnN0IHJMZW5ndGggPSBkUG9zICsgc2V0dGluZ3MubURlYzsgLy9UT0RPIE1vZGlmeSBgZFBvc2AgaGVyZSBpZiBpdCdzIG5vdCBpbnRlbmRlZCB0aGF0IGl0IGNhbiBiZSBlcXVhbCB0byAnLTEnXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpdi5jaGFyQXQockxlbmd0aCArIDEpKTtcbiAgICAgICAgY29uc3Qgb2RkID0gKGl2LmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpdi5jaGFyQXQockxlbmd0aCAtIDEpICUgMikgOiAoaXYuY2hhckF0KHJMZW5ndGgpICUgMik7XG4gICAgICAgIGxldCBpdkFycmF5ID0gaXYuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG4gICAgICAgIGlmICgodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdTJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIHVwIHN5bW1ldHJpY1xuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAncycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBkb3duIHN5bW1ldHJpY1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnYScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdhJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0InKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPT09IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0MnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIHRvIGNlaWxpbmcgdG93YXJkIHBvc2l0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdGJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCB0byBmbG9vciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xuICAgICAgICBpdkFycmF5ID0gaXZBcnJheS5zbGljZSgwLCByTGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgckRlYyk7XG5cbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XG4gICAgICAgIGNvbnN0IGFEZWMgPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICBjb25zdCBtRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xuICAgICAgICAgICAgb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyg6fFxcLikvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50XG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoYXQuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZWVwT3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5vRGVjICAgICA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYVBhZDtcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uQnJhY2tldDtcbiAgICAgICAgc2V0dGluZ3Mub1NlcCAgICAgPSBzZXR0aW5ncy5hU2VwO1xuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmFTaWduO1xuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkIC0gdGFrZW4gZnJvbSBtb2Rlcm5penJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsIHRvRG8pIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKCR0aGlzWzBdLm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZCgkdGhpc1swXS5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KCR0aGlzWzBdLm5hbWUpfWAgOmBBVVRPXyR7JHRoaXNbMF0uaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIHNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKC0xICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXV0b051bWVyaWNIb2xkZXIodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgIH1cblxuICAgIEF1dG9OdW1lcmljSG9sZGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICB0aGlzLmNtZEtleSA9IGUubWV0YUtleTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuXG4gICAgICAgICAgICAvLyBrZXlwcmVzcyBldmVudCBvdmVyd3JpdGVzIG1lYW5pbmdmdWwgdmFsdWUgb2YgZS5rZXlDb2RlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtkQ29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2hpY2ggPSBlLndoaWNoO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyU3RyaXBlZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCBzZXR0aW5nc0Nsb25lKTtcblxuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGFEZWMsXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGxlZnQgPT09ICcnIHx8IGxlZnQgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgc2V0dGluZ3NDbG9uZS5sWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmFEZWN9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIGtlZXBpbmcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBhZHZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgYWR2ZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4cGFuZFNlbGVjdGlvbk9uU2lnblxuICAgICAgICAgKiByZXR1cm5zIHNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBhU2lnbiA9IHNldHRpbmdzQ2xvbmUuYVNpZ247XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xuICAgICAgICAgICAgaWYgKGFTaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAgICAgKiBwcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5zaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIGF1dG9TdHJpcChsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIGlmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIHNraXBBbHdheXMoZSkge1xuICAgICAgICAgICAgY29uc3Qga2RDb2RlID0gdGhpcy5rZENvZGU7XG4gICAgICAgICAgICBjb25zdCB3aGljaCA9IHRoaXMud2hpY2g7XG4gICAgICAgICAgICBjb25zdCBjdHJsS2V5ID0gdGhpcy5jdHJsS2V5O1xuICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gdGhpcy5jbWRLZXk7XG5cbiAgICAgICAgICAgIC8vIGNhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgaWYgKCgoY3RybEtleSB8fCBjbWRLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoc2hpZnRLZXkgJiYga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgRngga2V5cywgd2luZG93cyBrZXlzLCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgoa2RDb2RlID49IGtleUNvZGUuRjEgJiYga2RDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIGtkQ29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLlRhYiAmJiBrZENvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgICh3aGljaCA9PT0gMCB8fCB3aGljaCA9PT0ga2RDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdCBhbGwgKGEpXG4gICAgICAgICAgICBpZiAoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBrZENvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gdGhpcy5zZXR0aW5ncy5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTdWZmaXhMZW4gPSB0aGlzLnNldHRpbmdzLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwU2lnbiA9IHRoaXMuc2V0dGluZ3MucFNpZ247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBOZWcgPSB0aGlzLnNldHRpbmdzLnBOZWc7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAocE5lZyA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBhU2lnbkxlbiA+IDApP2FTaWduTGVuICsgMTphU2lnbkxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIGFTdWZmaXhMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVN1ZmZpeExlbiArIGFTaWduTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChhU2lnbkxlbiA+IDApP3ZhbHVlTGVuIC0gKGFTaWduTGVuICsgbmVnTGVuICsgYVN1ZmZpeExlbik6dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgKGtkQ29kZSA9PT0ga2V5Q29kZS5jIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXG4gICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCBrZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN0cmxLZXkgfHwgY21kS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNlcCA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFEZWMgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYURlYztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYVNlcCB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXJ0SnVtcCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtkQ29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIGtkQ29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSArIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgLSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzQWx3YXlzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiAoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5wcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgaW5zZXJ0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzS2V5cHJlc3MoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgY0NvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMud2hpY2gpO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcbiAgICAgICAgICAgIGlmIChjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hRGVjIHx8IChzZXR0aW5nc0Nsb25lLmFsdERlYyAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hbHREZWMpIHx8ICgoY0NvZGUgPT09ICcuJyB8fCBjQ29kZSA9PT0gJywnKSAmJiB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLm1EZWMgfHwgIXNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIGFOZWcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFEZWMpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmFEZWMsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0cnkgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51c1xuICAgICAgICAgICAgaWYgKGNDb2RlID49ICcwJyAmJiBjQ29kZSA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hTmVnICYmIGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnZNYXggPD0gMCAmJiBzZXR0aW5nc0Nsb25lLnZNaW4gPCBzZXR0aW5nc0Nsb25lLnZNYXggJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBjQ29kZSwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aXRoIGtlZXBpbmcgb2YgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRRdWljayhlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrdUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcblxuICAgICAgICAgICAgLy8gbm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuYVNlcCAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTZXAgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2VwKSkpICYmXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuYVNpZ24gPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2lnbikpKSkge1xuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmFEZWMpO1xuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhzdWJQYXJ0cywgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF1dG9Hcm91cCh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkgJiYgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuYVNpZ24uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnRBcltpXS5tYXRjaCgnXFxcXGQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBjdXJzb3IgcG9zaXRpb24gaW4gZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IHZhbHVlLm1hdGNoKGxlZnRSZWcpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3TGVmdFswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGp1c3QgYmVmb3JlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhhdCkpO1xuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICAgICAgICAgIGlmICghJGlucHV0ICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhlIHN0YXRpYyBjb25maWd1cmF0aW9uIG9iamVjdHMgb3V0IG9mIHRoYXQgYmxvY2ssIGFuZCBob2lzdCB0aGVtIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZpbGVcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2InLFxuICAgICAgICAgICAgICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdjaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAnY29uc3QnLFxuICAgICAgICAgICAgICAgICAgICAnZGQnLFxuICAgICAgICAgICAgICAgICAgICAnZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICdkZm4nLFxuICAgICAgICAgICAgICAgICAgICAnZHQnLFxuICAgICAgICAgICAgICAgICAgICAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAnaDEnLFxuICAgICAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgICAgICAgICAnaDQnLFxuICAgICAgICAgICAgICAgICAgICAnaDUnLFxuICAgICAgICAgICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgICAgICAgICAnaW5zJyxcbiAgICAgICAgICAgICAgICAgICAgJ2tkYicsXG4gICAgICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICAgICAgICAncScsXG4gICAgICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3NhbXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICd1JyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IEJvb2xlYW4odmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMsIHNjYWxlRGl2aXNvciAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcblxuICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgdG8gZm9ybWF0IGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgPT09IGZhbHNlICYmIHNldHRpbmdzLmFGb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhhdCB0aGlzIGlucHV0IHZhbHVlIGlzIGEgdmFsaWQgbnVtYmVyIGFuZCB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogZGV2ZWxvcGVyIHdhbnRzIGl0IGZvcm1hdHRlZCBvbiBpbml0IChjZi4gYHNldHRpbmdzLmFGb3JtYCkpLiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGFuRGVmYXVsdGAgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBkZXZlbG9wZXIgaXMgdHJ5aW5nIHRvIHByZXZlbnQgcG9zdGJhY2sgcHJvYmxlbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBIZW5jZSwgaWYgYGFuRGVmYXVsdGAgaXMgbm90IG51bGwsIGJ1dCBgaW5wdXQudmFsdWVgIGlzIGEgbnVtYmVyIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGFuRGVmYXVsdGAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFGb3JtICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KCR0aGlzLmF0dHIoJ3ZhbHVlJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdGVkQ3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpOyAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih0ZXN0ZWRDdXJyZW50VmFsdWUpICYmIEluZmluaXR5ICE9PSB0ZXN0ZWRDdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHRlc3RlZEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGluZm9ybSB0aGUgZGV2ZWxvcGVyIHRoYXQgbm90aGluZyB1c2FibGUgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2N1cnJlbnRWYWx1ZX1dIHVzZWQgaW4gdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHZhbHVlIGF1dG9OdW1lcmljIGNhbiB3b3JrIHdpdGguYCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmFuRGVmYXVsdCAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hbkRlZmF1bHQudG9TdHJpbmcoKSAhPT0gY3VycmVudFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjICE9PSBudWxsICYmIHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IG5lZ2F0aXZlQnJhY2tldChjdXJyZW50VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKT8nLScgKyBhdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpOmF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy53RW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmFTaWduKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSAmJiAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBFeHRyYWN0IHRoZSBldmVudCBsaXN0ZW5lcnMgdG8gYW5vdGhlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIGlucHV0IHR5cGVzIHN1cHBvcnRlZCBcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2ZvY3VzaW4uYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAkc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwobmVnYXRpdmVCcmFja2V0KCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5lRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLm5TZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBhdXRvU3RyaXAoJHRoaXMudmFsKCksICRzZXR0aW5ncykpICE9PSAkc2V0dGluZ3MucmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci5pblZhbCwgJHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgJHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleWRvd24uYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogLy8gVGhlIGNvZGUgYmVsb3cgYWxsb3dzIHRoZSBcImVudGVyXCIga2V5ZG93biB0byB0aHJvdyBhIGNoYW5nZSgpIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci5pblZhbCAhPT0gJHRoaXMudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnByb2Nlc3NBbHdheXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IGluIGRlbGV0aW9uIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXlwcmVzcy5hdXRvTnVtZXJpYycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBmaXggZm9yIFNoaWZ0ICYmIGluc2VydCBwYXN0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkgfHwgaG9sZGVyLnByb2Nlc3NLZXlwcmVzcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigna2V5dXAuYXV0b051bWVyaWMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLnNraXBBbHdheXMoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWIgPSBob2xkZXIua2RDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmtkQ29kZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYiA9PT0ga2V5Q29kZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsICR0aGlzLnZhbCgpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXNvdXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsICRzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAkc2V0dGluZ3Mub1NlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNpZ24gPSAkc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTdWZmaXggPSAkc2V0dGluZ3Mub1N1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuZURlYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFQYWQgPSAkc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubkJyYWNrZXQgPSAkc2V0dGluZ3Mub0JyYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCAkc2V0dGluZ3MpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgJHNldHRpbmdzLmFEZWMsICRzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gJHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICRzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gKyRzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiAkc2V0dGluZ3MubURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKCcwJywgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgJHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKCRzZXR0aW5ncy5zY2FsZVN5bWJvbCkgPyBncm91cGVkVmFsdWUgKyAkc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIuaW5WYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLmluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FIEFmdGVyIGEgcGFzdGUsIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIGZhciByaWdodCBvZiB0aGUgaW5wdXQsIGl0IHNob3VsZCBiZSBzZXQgdG8gc29tZXRoaW5nIGxpa2UgYG5ld0NhcmV0UG9zaXRpb24gPSBvbGRDYXJldFBvc2l0aW9uICsgcGFzdGVUZXh0Lmxlbmd0aDtgLCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b1N0cmlwKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmFEZWMsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQsIGN1cnJlbnRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmUoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhc3RlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlKHByZWZpeCArIE51bWJlcihwYXN0ZWRUZXh0KS52YWx1ZU9mKCkgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld1ZhbHVlKSAmJiBOdW1iZXIob2xkUmF3VmFsdWUpLnZhbHVlT2YoKSAhPT0gTnVtYmVyKG5ld1ZhbHVlKS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuU2V0T25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlbW92ZSBzZXR0aW5ncyBhbmQgc3RvcCBhdXRvTnVtZXJpYygpIC0gZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIGRlc3Ryb3lzIGF1dG9OdW1lcmljXG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGFuZCBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gcmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgd2lwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IHVwZGF0ZXMgdGhlIGF1dG9OdW1lcmljIHNldHRpbmdzXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyB1cGRhdGVzIHRoZSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJ1cGRhdGVcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSBzZXR0aW5ncy5hU2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGFEZWM6IFwiJHtzZXR0aW5ncy5hRGVjfVwiIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgYVNlcDogXCIke3NldHRpbmdzLmFTZXB9XCIgYXJlIHRoZSBzYW1lIGNoYXJhY3RlcmAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzdHJpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBmb3JtYXQgdGhlIHZhbHVlIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAndmFsdWUnKTsgLy8gZm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcbiAgICAgICAgICogYW5kIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIChwZXJpb2QpIGNoYXJhY3RlclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHZhbHVlSW4pIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSW4gPT09IG51bGwgfHwgaXNVbmRlZmluZWQodmFsdWVJbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZUluLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBiZWluZyBzZXQgaXMgbm90IG51bWVyaWNcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNOdW1lcmljKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgaGFzIGNhdXNlZCBhIGVycm9yIHRvIGJlIHRocm93bmAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCAmJiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiBtYXggcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgfHwgaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5zY2FsZURpdmlzb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3RvciAmJiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3MgZm9yIHRoaXMgZWxlbWVudGAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gZ2V0IHRoZSB1bmZvcm1hdHRlZCB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIHBhcmFtZXRlclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpOyBubyBwYXJhbWV0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBsb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzLmFEZWMsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgTnVtZXJpYyBTdHJpbmdcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgcmV0dXJuIGBOdW1iZXIodmFsdWUpYCBzaW5jZSB0aGUgZ29hbCBvZiBgZ2V0YCBpcyB0byBnZXQgdGhlIHJhdyBqYXZhc2NyaXB0IHZhbHVlP1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnMCcpIHx8ICEoJ3ZhbHVlJyBpbiB0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhdXRvTnVtZXJpYyBmdW5jdGlvblxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxuICAgICAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXG4gICAgICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcbiAgICAgKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAgICAgKi9cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0ge1xuICAgICAgICAvKiBBbGxvd2VkIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAgICAgKiBhcG9zdHJvcGhlIGlzIGVzY2FwZWQgPSBcIlxcXCJcIlxuICAgICAgICAgKiBzcGFjZSA9IFwiIFwiXG4gICAgICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICAgICAqIE5PVEU6IGRvIG5vdCB1c2UgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBhU2VwOiAnLCcsXG5cbiAgICAgICAgLyogV2hlbiB0cnVlID0+IHJlbW92ZXMgdGhlIHRob3VzYW5kIHNlcGVyYXRvciwgY3VycmVuY3kgc3ltYm9sICYgc3VmZml4IFwiZm9jdXNpblwiXG4gICAgICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAgICAgKiBvbiBcImZvY3VzaW5cIiBpdCBiZWNvbWVzIFwiMTk5OS44OFwiIGFuZCBiYWNrIHRvIFwiJCAxLDk5OS44OCBzdWZmaXhcIiBvbiBmb2N1cyBvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBuU2VwOiBmYWxzZSxcblxuICAgICAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICAgICAqIGRHcm91cDogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgICAgICogZEdyb3VwOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAgICAgKiBkR3JvdXA6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgICAgICogZEdyb3VwOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBkR3JvdXA6ICczJyxcblxuICAgICAgICAvKiBBbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICAgICAqL1xuICAgICAgICBhRGVjOiAnLicsXG5cbiAgICAgICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGFEZWNcbiAgICAgICAgICogZGV2ZWxvcGVkIGZvciBjb3VudHJpZXMgdGhlIHVzZSBhIGNvbW1hIFwiLFwiIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgICAgICovXG4gICAgICAgIGFsdERlYzogbnVsbCxcblxuICAgICAgICAvKiBhU2lnbiA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXG4gICAgICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTaWduOiBcIiRcIlxuICAgICAgICAgKiBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyQgJ1xuICAgICAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnICQnXG4gICAgICAgICAqL1xuICAgICAgICBhU2lnbjogJycsXG5cbiAgICAgICAgLyogcFNpZ24gPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XG4gICAgICAgICAqIGZvciBwcmVmaXggcFNpZ246IFwicFwiIChkZWZhdWx0KVxuICAgICAgICAgKiBmb3Igc3VmZml4IHBTaWduOiBcInNcIlxuICAgICAgICAgKi9cbiAgICAgICAgcFNpZ246ICdwJyxcblxuICAgICAgICAvKiBQbGFjZW1lbnQgb2YgbmVnYXRpdmUgc2lnbiByZWxhdGl2ZSB0byB0aGUgYVNpZ24gb3B0aW9uIGw9bGVmdCwgcj1yaWdodCwgcD1wcmVmaXggJiBzPXN1ZmZpeFxuICAgICAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxuICAgICAgICAgKiAtJDEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCJ9XG4gICAgICAgICAqICQtMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIiwgcE5lZzogXCJyXCJ9XG4gICAgICAgICAqIC0xLDIzNC41NiQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn1cbiAgICAgICAgICogMSwyMzQuNTYtICA9PiB7cE5lZzogXCJzXCJ9XG4gICAgICAgICAqICQxLDIzNC41Ni0gPT4ge2FTaWduOiBcIiRcIiwgcE5lZzogXCJzXCJ9XG4gICAgICAgICAqIDEsMjM0LjU2LSQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wifVxuICAgICAgICAgKiAxLDIzNC41NiQtID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJyXCJ9XG4gICAgICAgICAqL1xuICAgICAgICBwTmVnOiAnbCcsXG5cbiAgICAgICAgLyogQWRkaXRpb25hbCBzdWZmaXhcbiAgICAgICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVN1ZmZpeDogJ2dyb3NzJywgYSBzcGFjZSBpcyBhbGxvd2VkIGFTdWZmaXg6ICcgZG9sbGFycydcbiAgICAgICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYVN1ZmZpeDogJycsXG5cbiAgICAgICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcbiAgICAgICAgICogb0xpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byB2TWF4IGFuZCBpZ25vcmVzIHZNaW4gc2V0dGluZ3NcbiAgICAgICAgICogb0xpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gdk1pbiBhbmQgaWdub3JlcyB2TWF4IHNldHRpbmdzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICAgICAqL1xuICAgICAgICBvTGltaXRzOiBudWxsLFxuXG4gICAgICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIHZNaW5cbiAgICAgICAgICovXG4gICAgICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxuICAgICAgICAgKi9cbiAgICAgICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIixcbiAgICAgICAgICovXG4gICAgICAgIG1EZWM6IG51bGwsXG5cbiAgICAgICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XG4gICAgICAgICAqIHtlRGVjOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAqL1xuICAgICAgICBlRGVjOiBudWxsLFxuXG4gICAgICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJhU3RvcmVcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWUgICAgICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxuICAgICAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWw6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XG4gICAgICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAgICAgKi9cblxuICAgICAgICAvKiBUaGUgYHNjYWxlRGl2aXNvcmAgZGVjaWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxuICAgICAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgICAgICogVGhlIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciBidXQgcGxlYXNlIHVuZGVyc3RhbmQgdGhhdCBKYXZhc2NyaXB0IGhhcyBsaW1pdGVkIGFjY3VyYWN5IGluIG1hdGhcbiAgICAgICAgICogVGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZURpdmlzb3I6IG51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGBzY2FsZURlY2ltYWxgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVEZWNpbWFsOiBudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXG4gICAgICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgdG9vLlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVTeW1ib2w6IG51bGwsXG5cbiAgICAgICAgLyogU2V0IHRvIHRydWUgdG8gYWxsb3cgdGhlIGVEZWMgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxuICAgICAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAgICAgKi9cbiAgICAgICAgYVN0b3I6IGZhbHNlLFxuXG4gICAgICAgIC8qIG1ldGhvZCB1c2VkIGZvciByb3VuZGluZ1xuICAgICAgICAgKiBtUm91bmQ6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgICAgICogbVJvdW5kOiBcIkFcIiwgUm91bmQtSGFsZi1VcCBBc3ltbWV0cmljXG4gICAgICAgICAqIG1Sb3VuZDogXCJzXCIsIFJvdW5kLUhhbGYtRG93biBTeW1tZXRyaWMgKGxvd2VyIGNhc2UgcylcbiAgICAgICAgICogbVJvdW5kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgICAgICogbVJvdW5kOiBcIkJcIiwgUm91bmQtSGFsZi1FdmVuIFwiQmFua2VycyBSb3VuZGluZ1wiXG4gICAgICAgICAqIG1Sb3VuZDogXCJVXCIsIFJvdW5kIFVwIFwiUm91bmQtQXdheS1Gcm9tLVplcm9cIlxuICAgICAgICAgKiBtUm91bmQ6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgICAgICogbVJvdW5kOiBcIkNcIiwgUm91bmQgdG8gQ2VpbGluZyBcIlRvd2FyZCBQb3NpdGl2ZSBJbmZpbml0eVwiXG4gICAgICAgICAqIG1Sb3VuZDogXCJGXCIsIFJvdW5kIHRvIEZsb29yIFwiVG93YXJkIE5lZ2F0aXZlIEluZmluaXR5XCJcbiAgICAgICAgICogbVJvdW5kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgICAgICogbVJvdW5kOiBcIlUwNVwiIFJvdW5kcyB1cCB0byBuZXh0IC4wNVxuICAgICAgICAgKiBtUm91bmQ6IFwiRDA1XCIgUm91bmRzIGRvd24gdG8gbmV4dCAuMDVcbiAgICAgICAgICovXG4gICAgICAgIG1Sb3VuZDogJ1MnLFxuXG4gICAgICAgIC8qIENvbnRyb2xzIGRlY2ltYWwgcGFkZGluZ1xuICAgICAgICAgKiBhUGFkOiB0cnVlIC0gYWx3YXlzIFBhZCBkZWNpbWFscyB3aXRoIHplcm9zXG4gICAgICAgICAqIGFQYWQ6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICAgICAqIE5vdGU6IHNldHRpbmcgYVBhZCB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdtRGVjJyBzZXR0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYVBhZDogdHJ1ZSxcblxuICAgICAgICAvKiBBZGRzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlcyAoaWUuIHRyYW5zZm9ybXMgJy0kIDk5OS45OScgdG8gJyg5OTkuOTkpJylcbiAgICAgICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgICAgICogbkJyYWNrZXQ6IG51bGwgLSAoZGVmYXVsdClcbiAgICAgICAgICogbkJyYWNrZXQ6ICcoLCknLCBuQnJhY2tldDogJ1ssXScsIG5CcmFja2V0OiAnPCw+JyBvciBuQnJhY2tldDogJ3ssfSdcbiAgICAgICAgICovXG4gICAgICAgIG5CcmFja2V0OiBudWxsLFxuXG4gICAgICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAgICAgKiB3RW1wdHk6IFwiZm9jdXNcIiAtIChkZWZhdWx0KSBjdXJyZW5jeSBzaWduIGRpc3BsYXllZCBhbmQgdGhlIGlucHV0IHJlY2VpdmVzIGZvY3VzXG4gICAgICAgICAqIHdFbXB0eTogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcbiAgICAgICAgICogd0VtcHR5OiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgICAgICogd0VtcHR5OiBcInplcm9cIiAtIGlmIHRoZSBpbnB1dCBoYXMgbm8gdmFsdWUgb24gZm9jdXMgb3V0IGRpc3BsYXlzIGEgemVybyBcInJvdW5kZWRcIiB3aXRoIG9yIHdpdGggYSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICAvL1RPRE8gQWRkIGFuIG9wdGlvbiB0byBkaXNwbGF5IHRoZSBjdXJyZW5jeSBzaWduIG9ubHkgb24gaG92ZXIgKGlmIHRoZSBpbnB1dCBpcyBlbXB0eSlcbiAgICAgICAgd0VtcHR5OiAnZm9jdXMnLFxuXG4gICAgICAgIC8qIENvbnRyb2xzIGxlYWRpbmcgemVybyBiZWhhdmlvclxuICAgICAgICAgKiBsWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgICAgICogbFplcm86IFwia2VlcFwiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIG9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgcmV0YWluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBsWmVybzogJ2FsbG93JyxcblxuICAgICAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICogZmFsc2UgPSB3aWxsIG5vdCBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGFGb3JtOiB0cnVlLFxuXG4gICAgICAgIC8qIERldGVybWluZSBpZiB0aGUgc2VsZWN0IGFsbCBrZXlib2FyZCBjb21tYW5kIHdpbGwgc2VsZWN0XG4gICAgICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgICAgICogaWYgdGhlIGN1cnJlbmN5IHN5bWJvbCBpcyBiZXR3ZWVuIHRoZSBudW1lcmljIHZhbHVlIGFuZCB0aGUgbmVnYXRpdmUgc2lnbiBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNOdW1iZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qIEhlbHBlciBvcHRpb24gZm9yIEFTUC5ORVQgcG9zdGJhY2tcbiAgICAgICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgKiBleGFtcGxlczpcbiAgICAgICAgICogbm8gZGVmYXVsdCB2YWx1ZT1cIlwiIHthbkRlZmF1bHQ6IFwiXCJ9XG4gICAgICAgICAqIHZhbHVlPTEyMzQuNTYge2FuRGVmYXVsdDogJzEyMzQuNTYnfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5EZWZhdWx0OiBudWxsLFxuXG4gICAgICAgIC8qIFJlbW92ZXMgZm9ybWF0dGluZyBvbiBzdWJtaXQgZXZlbnRcbiAgICAgICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICAgICAqL1xuICAgICAgICB1blNldE9uU3VibWl0OiBmYWxzZSxcblxuICAgICAgICAvKiBBbGxvd3MgdGhlIG91dHB1dCB0byBiZSBpbiB0aGUgbG9jYWxlIGZvcm1hdCB2aWEgdGhlIFwiZ2V0XCIsIFwiZ2V0U3RyaW5nXCIgJiBcImdldEFycmF5XCIgbWV0aG9kc1xuICAgICAgICAgKiBudWxsID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gZGVmYXVsdFxuICAgICAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzbyBiZSBcIi0sXCJcbiAgICAgICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZU91dHB1dDogbnVsbCxcblxuICAgICAgICAvKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xuICAgICAgICAgKi9cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG5cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cztcblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyXG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB2TWF4ID0gc2V0dGluZ3Mudk1heC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBkZWNMZW5ndGgodk1pbiwgdk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgc2VuZEN1c3RvbUV2ZW50KCdhdXRvRm9ybWF0LmF1dG9OdW1lcmljJywgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHNldHRpbmdzYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDtcblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XG4gICAgICAgIGNvbnN0IGF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5uQnJhY2tldCAmJiBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpWzBdID09PSB2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFOZWcgPSAnLSc7XG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVidWcgPSB0cnVlOyAvLyBUaGUgZXJyb3IgaGVyZSBtdXN0IGFsd2F5cyBiZSB0aHJvd24sIHNpbmNlIGEgYmFkbHkgY29uZmlndXJlZCBvcHRpb25zIG9iamVjdCB3aWxsIGxlYWQgdG8gd3JvbmcgcmVzdWx0cywgaWYgYW55LlxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFTZXAsIFsnLCcsICcuJywgJyAnLCAnJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FTZXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJywnLCAnLicsICcgJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmFTZXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5uU2VwKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMublNlcCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnblNlcCcgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5TZXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRHcm91cCkpIHsgLy8gaXNOYU4ocGFyc2VJbnQob3B0aW9ucy5kR3JvdXApKSAvL0RFQlVHXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZEdyb3VwJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kR3JvdXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFEZWMsIFsnLCcsICcuJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLicgb3IgJywnLCBbJHtvcHRpb25zLmFEZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChvcHRpb25zLmFEZWMgPT09IG9wdGlvbnMuYVNlcCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ2FEZWMnIFske29wdGlvbnMuYURlY31dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yICdhU2VwJyBbJHtvcHRpb25zLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuYWx0RGVjKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5hbHREZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FsdERlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hbHREZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hU2lnbiAhPT0gJycgJiYgIWlzU3RyaW5nKG9wdGlvbnMuYVNpZ24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnYVNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuYVNpZ259XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnBTaWduLCBbJ3AnLCAncyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgY3VycmVuY3kgc2lnbiBvcHRpb24gJ3BTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCkgb3IgJ3MnIChzdWZmaXgpLCBbJHtvcHRpb25zLnBTaWdufV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5wTmVnLCBbJ3AnLCAncycsICdsJywgJ3InXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICdwTmVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSBvciAncicgKHJpZ2h0KSwgWyR7b3B0aW9ucy5wTmVnfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLmFTdWZmaXgpIHx8IChvcHRpb25zLmFTdWZmaXggIT09ICcnICYmIChjb250YWlucyhvcHRpb25zLmFTdWZmaXgsICctJykgfHwgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMudGVzdChvcHRpb25zLmFTdWZmaXgpKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhZGRpdGlvbmFsIHN1ZmZpeCBvcHRpb24gJ2FTdWZmaXgnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgbm90IGNvbnRhaW5zIHRoZSBuZWdhdGl2ZSBzaWduICctJyBub3IgYW55IG51bWVyaWNhbCBjaGFyYWN0ZXJzLCBbJHtvcHRpb25zLmFTdWZmaXh9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm9MaW1pdHMpICYmICFpc0luQXJyYXkob3B0aW9ucy5vTGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ29MaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vTGltaXRzfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNYXgpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1heCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1heH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy52TWluKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLnZNaW4pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ3ZNaW4nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLnZNaW59XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLnZNaW4pID4gcGFyc2VGbG9hdChvcHRpb25zLnZNYXgpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICd2TWluJyBbJHtvcHRpb25zLnZNaW59XSBzaG91bGQgYmUgc21hbGxlciB0aGFuICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm1EZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5tRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdtRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5tRGVjfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFQYWQgJiYgIWlzTnVsbChvcHRpb25zLm1EZWMpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdhUGFkJyB0byBbZmFsc2VdIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ21EZWMnIHNldHRpbmcgWyR7b3B0aW9ucy5tRGVjfV0uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIHZNaW4vdk1heCBpcyBvdmVycmlkZGVuIGJ5IG1EZWMgKGFuZCBub3QgaWYgbURlYyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiB2TWluL3ZNYXgpXG4gICAgICAgIGxldCBkcFZNaW4gPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1pbik7XG4gICAgICAgIGxldCBkcFZNYXggPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1heCk7XG4gICAgICAgIGRwVk1pbiA9IGlzTnVsbChkcFZNaW4pPzA6ZHBWTWluO1xuICAgICAgICBkcFZNYXggPSBpc051bGwoZHBWTWF4KT8wOmRwVk1heDtcbiAgICAgICAgY29uc3Qgdk1pbk1heERlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChkcFZNaW4sIGRwVk1heCk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiZcbiAgICAgICAgICAgICgoaGFzRGVjaW1hbHMob3B0aW9ucy52TWluKSB8fCBoYXNEZWNpbWFscyhvcHRpb25zLnZNYXgpKSAmJiB2TWluTWF4RGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdtRGVjJyB0byBbJHtvcHRpb25zLm1EZWN9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAndk1pbicgWyR7b3B0aW9ucy52TWlufV0gYW5kICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5lRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZURlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJlRGVjXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJtRGVjXCJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5lRGVjKSAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykgJiYgTnVtYmVyKG9wdGlvbnMubURlYykgPCBOdW1iZXIob3B0aW9ucy5lRGVjKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgJ2VEZWMnIFske29wdGlvbnMuZURlY31dIGlzIGdyZWF0ZXIgdGhhbiB0aGUgJ21EZWMnIFske29wdGlvbnMubURlY31dIHZhbHVlLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWwpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWwpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWx9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlU3ltYm9sKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5zY2FsZVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBzeW1ib2wgb3B0aW9uICdzY2FsZVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5zY2FsZVN5bWJvbH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFTdG9yKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdhU3RvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYVN0b3J9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm1Sb3VuZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAnbVJvdW5kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMubVJvdW5kfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYVBhZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFQYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY29udHJvbCBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhUGFkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hUGFkfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uQnJhY2tldCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm5CcmFja2V0LCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduQnJhY2tldCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uQnJhY2tldH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMud0VtcHR5LCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICd3RW1wdHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy53RW1wdHl9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmxaZXJvLCBbJ2FsbG93JywgJ2RlbnknLCAna2VlcCddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxaZXJvfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYUZvcm0pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hRm9ybSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdhRm9ybScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYUZvcm19XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zTnVtYmVyKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc051bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzTnVtYmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zTnVtYmVyfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbkRlZmF1bHQpICYmIChvcHRpb25zLmFuRGVmYXVsdCAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5hbkRlZmF1bHQpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdhbkRlZmF1bHQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLmFuRGVmYXVsdH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuU2V0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51blNldE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuU2V0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuU2V0T25TdWJtaXR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmxvY2FsZU91dHB1dCkgJiYgIWlzSW5BcnJheShvcHRpb25zLmxvY2FsZU91dHB1dCwgW1xuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ2xvY2FsZU91dHB1dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgZW1wdHksICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMubG9jYWxlT3V0cHV0fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZGVidWcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5kZWJ1ZykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2RlYnVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5kZWJ1Z31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlU2V0dGluZ3NWYWxpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICAvKiBsZXQgZXZlbnRJbmZvID0gbmV3IEN1c3RvbUV2ZW50SW5pdCgpOyAvL1RoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCwgYnV0IElFIGRvZXMgbm90IHN1cHBvcnQgJ0N1c3RvbUV2ZW50SW5pdCcgeWV0XG4gICAgICAgIGV2ZW50SW5mby5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9KSgpO1xufSkpO1xuXG4vKipcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxuICAgIGdldERlZmF1bHRDb25maWcsXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxuICAgIGFyZVNldHRpbmdzVmFsaWQsIC8vYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xuXG4gICAgLy9UT0RPIENvbXBsZXRlIHRoZSBpbnRlcmZhY2Ugd2l0aCBmdW5jdGlvbnMgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyA6XG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxuICAgIC8vc2V0ICAgICAgICAgIDogYW4uc2V0KHZhbHVlLCBpbnB1dClcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxuICAgIC8vZ2V0Rm9ybWF0dGVkIDogYW4uZ2V0Rm9ybWF0dGVkKGlucHV0KVxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cbiAgICAvL3NldHRpbmdzICAgICA6IGFuLnNldHRpbmdzKGlucHV0KVxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcbiAgICAvL2Rlc3Ryb3kgICAgICA6IGFuLmRlc3Ryb3koaW5wdXQpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;
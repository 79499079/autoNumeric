(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-27 UTC 11:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message) {\n        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * Function to handle warning messages\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * converts the ISO numeric string to the locale decimal and minus sign placement\n     * see \"localeOutput\" option for determine\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros to the first significant digit\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // removes access zeros to the mDec length when aPad is set true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the iv (input Value) is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        //FIXME The options 'a' is never tested here\n        tRound > 5 && settings.mRound === 'A' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'A' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // Supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // Checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n                }\n\n                // Checks for non-supported tags\n                //TODO Move the static configuration objects out of that block, and hoist them at the start of this file\n                var allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n                var currentElementTag = $this.prop('tagName').toLowerCase();\n                if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n                    throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n                }\n\n                // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: allowedTagList\n                    });\n\n                    // Modify the user settings to make them 'exploitable'\n                    $.each(settings, function (key, value) {\n                        // Convert the string 'true' and 'false' to real Boolean\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n\n                        // Convert numbers in options to strings\n                        //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                        if (typeof value === 'number' && key !== 'aScale') {\n                            settings[key] = value.toString();\n                        }\n                    });\n\n                    // Validate the settings\n                    validate(settings, false); // Throws if necessary\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n\n                        /*\n                         * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                         * precedence and should get formatted on init (if that this input value is a valid number and that the\n                         * developer wants it formatted on init (cf. `settings.aForm`)). Note; this is true whatever the developer\n                         * has set for `data-an-default` in the html (asp.net users).\n                         *\n                         * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n                         * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n                         * changed the input value, and then it means we should not overwrite his own decision to do so.\n                         * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n                         * we should ignore `anDefault` altogether.\n                         */\n                        if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                            // Check if the `value` is valid or not\n                            var testedCurrentValue = parseFloat(currentValue.replace(',', '.')); //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                            if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                                $this.autoNumeric('set', testedCurrentValue);\n                                setValue = false;\n                            } else {\n                                // If not, inform the developer that nothing usable has been provided\n                                throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                            }\n                        } else {\n                            /* Checks for :\n                             * - page reload from back button, and\n                             * - ASP.net form post back\n                             *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                             *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                             */\n                            //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                            if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                                if (settings.eDec !== null && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (settings.scaleDivisor && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (!settings.aStor) {\n                                    var toStrip = void 0;\n                                    if (settings.nBracket !== null && settings.aNeg !== '') {\n                                        settings.onOff = true;\n                                        toStrip = negativeBracket(currentValue, settings);\n                                    } else {\n                                        toStrip = currentValue;\n                                    }\n                                    settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                                }\n                                setValue = false;\n                            }\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                //TODO Extract the event listeners to another function\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.scaleDivisor) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.nSep) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                            $settings.aSuffix = '';\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n                            $this.change();\n                            holder.inVal = $this.val();\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                            $settings.aSuffix = $settings.oSuffix;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.scaleDivisor) {\n                                    value = value / $settings.scaleDivisor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.scaleDivisor && $settings.scaleDecimal ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSymbol ? groupedValue + $settings.scaleSymbol : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: '€ '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * autoNumeric function\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /*\n     * Defaults options are public - these can be overridden by the following:\n     * - HTML5 data attributes\n     * - Options passed by the 'init' or 'update' methods\n     * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n     */\n    $.fn.autoNumeric.defaults = {\n        /* Allowed thousand separator characters\n         * comma = \",\"\n         * period \"full stop\" = \".\"\n         * apostrophe is escaped = \"\\\"\"\n         * space = \" \"\n         * none = \"\"\n         * NOTE: do not use numeric characters\n         */\n        aSep: ',',\n\n        /* When true => removes the thousand seperator, currency symbol & suffix \"focusin\"\n         * example if the input value \"$ 1,999.88 suffix\"\n         * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n         */\n        nSep: false,\n\n        /* Digital grouping for the thousand separator used in Format\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n         * dGroup: \"3\", results in 999,999,999 default\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n         */\n        dGroup: '3',\n\n        /* Allowed decimal separator characters\n         * period \"full stop\" = \".\"\n         * comma = \",\"\n         */\n        aDec: '.',\n\n        /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n         * developed for countries the use a comma \",\" as the decimal character\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\n         * Must be in quotes aSign: \"$\"\n         * space to the right of the currency symbol aSign: '$ '\n         * space to the left of the currency symbol aSign: ' $'\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\n         * for prefix pSign: \"p\" (default)\n         * for suffix pSign: \"s\"\n         */\n        pSign: 'p',\n\n        /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n         * -1,234.56  => default no options required\n         * -$1,234.56 => {aSign: \"$\"}\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n         * 1,234.56-  => {pNeg: \"s\"}\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n         * Numeric characters and negative sign not allowed'\n         */\n        aSuffix: '',\n\n        /* Override min max limits\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n         * oLimits: \"ignore\" ignores both vMin & vMax\n         */\n        oLimits: null,\n\n        /* Maximum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be larger than vMin\n         */\n        vMax: '9999999999999.99',\n\n        /* Minimum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be smaller than vMax\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n         * value must be enclosed in quotes example mDec: \"3\",\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n         * the \"get\" method returns the extended decimal places\n         */\n        eDec: null,\n\n        /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n         * Please note that the non-scaled value is held in data and it is advised that you use the \"aStore\" option to ensure retaining the value         * [\"divisor\", \"decimal places\", \"symbol\"]\n         * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n         * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n         */\n\n        /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n         * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n         * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n         * The \"get\" method returns the full value, including the 'hidden' decimals.\n         */\n        scaleDivisor: null,\n\n        /*\n         * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n         * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n         */\n        scaleDecimal: null,\n\n        /*\n         * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n         * This is optional too.\n         */\n        scaleSymbol: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\n         * if ie 6 or 7 the value will be saved as a session cookie\n         */\n        aStor: false,\n\n        /* method used for rounding\n         * mRound: \"S\", Round-Half-Up Symmetric (default)\n         * mRound: \"A\", Round-Half-Up Asymmetric\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n         * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n         * mRound: \"U05\" Rounds up to next .05\n         * mRound: \"D05\" Rounds down to next .05\n         */\n        mRound: 'S',\n\n        /* Controls decimal padding\n         * aPad: true - always Pad decimals with zeros\n         * aPad: false - does not pad with zeros.\n         * Note: setting aPad to 'false' will override the 'mDec' setting.\n         *\n         * thanks to Jonas Johansson for the suggestion\n         */\n        aPad: true,\n\n        /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n         * Those brackets are visible only when the field does NOT have the focus.\n         * The left and right symbols should be enclosed in quotes and separated by a comma\n         * nBracket: null - (default)\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\n         * wEmpty: \"always\" - always displays the currency sign only\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n         */\n        //TODO Add an option to display the currency sign only on hover (if the input is empty)\n        wEmpty: 'focus',\n\n        /* Controls leading zero behavior\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n         * lZero: \"deny\", - allows only one leading zero on values less than one\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n         */\n        lZero: 'allow',\n\n        /* Determine if the default value will be formatted on initialization.\n         * true = automatically formats the default value on initialization\n         * false = will not format the default value\n         */\n        aForm: true,\n\n        /* Determine if the select all keyboard command will select\n         * the complete input text or only the input numeric value\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n         */\n        sNumber: false,\n\n        /* Helper option for ASP.NET postback\n         * should be the value of the unformatted default value\n         * examples:\n         * no default value=\"\" {anDefault: \"\"}\n         * value=1234.56 {anDefault: '1234.56'}\n         */\n        anDefault: null,\n\n        /* Removes formatting on submit event\n         * this output format: positive nnnn.nn, negative -nnnn.nn\n         * review the 'unSet' method for other formats\n         */\n        unSetOnSubmit: false,\n\n        /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n         * null => nnnn.nn or -nnnn.nn default\n         * \",\"  => nnnn,nn or -nnnn,nn can also be \"-,\"\n         * \".-\" => nnnn.nn or nnnn.nn-\n         * \",-\" => nnnn,nn or nnnn,nn-\n         */\n        localeOutput: null,\n\n        /* Error handling function\n         * true => all errors are thrown - helpful in site development\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.', debug);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, $.fn.autoNumeric.defaults, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.', debug);\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.', debug);\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.', debug);\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.', debug);\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.', debug);\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.', debug);\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.', debug);\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.', debug);\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.', debug);\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.', debug);\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.', debug);\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.', debug);\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.', debug);\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.', debug);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.', debug);\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.', debug);\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.', debug);\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.', debug);\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.', debug);\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.', debug);\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.', debug);\n        }\n\n        if (!isNull(options.localeOutput) && !isInArray(options.localeOutput, ['.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'localeOutput\\' is invalid ; it should either be empty, \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.localeOutput + '] given.', debug);\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.', debug);\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\n        eventInfo.detail = detail;\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJpc051bGwiLCJ2YWx1ZSIsImlzVW5kZWZpbmVkIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc1RydWVPckZhbHNlU3RyaW5nIiwibG93ZXJjYXNlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsImlzT2JqZWN0IiwicmVmZXJlbmNlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNFbXB0eU9iaiIsIm9iaiIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJoYXNEZWNpbWFscyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJkZWNpbWFsUGxhY2VzIiwibGVuZ3RoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwidGV4dCIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJkZWJ1ZyIsIndhcm5pbmciLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3MiLCIkdGhpcyIsInNldHRpbmdzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsImRlY0xlbmd0aCIsInZNaW4iLCJ2TWF4Iiwidk1heExlbmd0aCIsInZNaW5MZW5ndGgiLCJNYXRoIiwibWF4IiwiYXV0b0NvZGUiLCJhTmVnIiwicmVwbGFjZSIsIm1JbnRQb3MiLCJtSW50TmVnIiwibURlYyIsIm9EZWMiLCJOdW1iZXIiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJhbHREZWMiLCJhRGVjIiwiYVNlcCIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsImF1dG9TdHJpcCIsImFTaWduIiwiYVN1ZmZpeCIsInBOZWciLCJwU2lnbiIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJsWmVybyIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwiY2hhckF0Iiwic2xpY2UiLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwibkJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpdiIsInNpZ25PbkVtcHR5Iiwid0VtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnIiwiZGlnaXRhbEdyb3VwIiwiZEdyb3VwIiwidGVzdCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsIml2Um91bmRlZCIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsIm1Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwicmVzdWx0IiwiYVBhZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsIm9MaW1pdHMiLCJhdXRvR2V0IiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiaG9sZGVyIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJrZWVwT3JpZ2luYWxTZXR0aW5ncyIsIm9QYWQiLCJvQnJhY2tldCIsIm9TZXAiLCJvU2lnbiIsIm9TdWZmaXgiLCJyZWFkQ29va2llIiwibmFtZSIsIm5hbWVFUSIsImNhIiwiY29va2llIiwic3RvcmFnZVRlc3QiLCJtb2QiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiYXV0b1NhdmUiLCJ0b0RvIiwiYVN0b3IiLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsImZvcm1hdHRlZCIsInNldHRpbmdzQ2xvbmUiLCJpbml0IiwiY3RybEtleSIsImNtZEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInR5cGUiLCJrZENvZGUiLCJ3aGljaCIsInByb2Nlc3NlZCIsInNldFNlbGVjdGlvbiIsInNldFJlYWwiLCJtaW4iLCJzZXRQb3NpdGlvbiIsInBvcyIsImdldEJlZm9yZUFmdGVyIiwibGVmdCIsInJpZ2h0IiwiZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkIiwibm9ybWFsaXplUGFydHMiLCJuZXdWYWx1ZSIsInNldFZhbHVlUGFydHMiLCJhZHZlbnQiLCJwYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwidHJpZ2dlciIsInNpZ25Qb3NpdGlvbiIsImFTaWduTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJleHBhbmRTZWxlY3Rpb25PblNpZ24iLCJjaGVja1Bhc3RlIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0Iiwic3Vic3RyIiwic2tpcEFsd2F5cyIsInNOdW1iZXIiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsImFTdWZmaXhMZW4iLCJzdGFydEp1bXAiLCJwcm9jZXNzVHJhaWxpbmciLCJjYXJldEZpeCIsIkJvb2xlYW4iLCJwcm9jZXNzQWx3YXlzIiwidGhyb3dJbnB1dCIsInByb2Nlc3NLZXlwcmVzcyIsImNDb2RlIiwiZnJvbUNoYXJDb2RlIiwiZm9ybWF0UXVpY2siLCJsZWZ0TGVuZ3RoIiwia3VDb2RlIiwic3ViUGFydHMiLCJsZWZ0QXIiLCJzaGlmdCIsInB1c2giLCJzaWduUGFydHMiLCJlc2NhcGVDaHIiLCJlc2NhcGVkUGFydHMiLCJtaW5pUGFydHMiLCJsZWZ0UmVnIiwibmV3TGVmdCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsImluQXJyYXkiLCJ0ZXN0SW5wdXQiLCJsb2NhbGVPdXRwdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJpbnB1dFZhbHVlIiwibW9kaWZpZWRJbnB1dFZhbHVlIiwibWV0aG9kcyIsIm9wdGlvbnMiLCJ0YWdEYXRhIiwiJGlucHV0IiwiaXMiLCJhbGxvd2VkVGFnTGlzdCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZXh0ZW5kIiwiZm4iLCJkZWZhdWx0cyIsInJ1bk9uY2UiLCJ0YWdMaXN0Iiwia2V5IiwiYUZvcm0iLCJzZXRWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImF0dHIiLCJ0ZXN0ZWRDdXJyZW50VmFsdWUiLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJJbmZpbml0eSIsImFuRGVmYXVsdCIsImlzTnVtZXJpYyIsImVEZWMiLCJ0b1N0cmlwIiwib24iLCIkc2V0dGluZ3MiLCJuU2VwIiwiaW5WYWwiLCJsYXN0VmFsIiwib25FbXB0eSIsInJlYWRPbmx5Iiwic2tpcCIsInRhYiIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsInNjYWxlU3ltYm9sIiwiY2hhbmdlIiwicHJlcGFyZSIsImlzVmFsaWQiLCJvbGRSYXdWYWx1ZSIsInByZWZpeCIsInN1ZmZpeCIsInBhc3RlZFRleHQiLCJvcmlnaW5hbEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJ2YWx1ZU9mIiwiY2xvc2VzdCIsInVuU2V0T25TdWJtaXQiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJ2YWx1ZUluIiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwibWV0aG9kIiwiYXJncyIsImFwcGx5Iiwic2VuZEN1c3RvbUV2ZW50IiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJkcFZNaW4iLCJkcFZNYXgiLCJ2TWluTWF4RGVjaW1hbFBsYWNlcyIsImVycm9yIiwiY3JlYXRlQ3VzdG9tRXZlbnQiLCJldmVudE5hbWUiLCJkZXRhaWwiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50IiwicGFyYW1zIiwiZXZ0IiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJFdmVudCIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQSxJQUFJQSxtQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBOztBQUVDLFdBQVNDLE9BQVQsRUFBa0I7QUFDZjtBQUNKLFFBQUksSUFBSixFQUFnRDtBQUM1QztBQUNBQyxRQUFBLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxvQ0FBbUJELE9BQW5CO0FBQ0gsS0FIRCxNQUdPLElBQUksUUFBT0UsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QkEsT0FBT0MsT0FBekMsRUFBa0Q7QUFDckQ7QUFDQUQsZUFBT0MsT0FBUCxHQUFpQkgsUUFBUUksUUFBUSxRQUFSLENBQVIsQ0FBakI7QUFDSCxLQUhNLE1BR0E7QUFDSDtBQUNBSixnQkFBUUssT0FBT0MsTUFBZjtBQUNIO0FBQ0EsQ0FaQSxFQVlDLGFBQUs7QUFDSDs7O0FBR0EsUUFBTUMsVUFBVTtBQUNaQyxtQkFBZ0IsQ0FESjtBQUVaQyxhQUFnQixDQUZKO0FBR1pDLGVBQWdCLEVBSEo7QUFJWkMsZUFBZ0IsRUFKSjtBQUtaQyxjQUFnQixFQUxKO0FBTVpDLGFBQWdCLEVBTko7QUFPWkMsb0JBQWdCLEVBUEo7QUFRWkMsa0JBQWdCLEVBUko7QUFTWkMsYUFBZ0IsRUFUSjtBQVVaQyxlQUFnQixFQVZKO0FBV1pDLGdCQUFnQixFQVhKO0FBWVpDLGtCQUFnQixFQVpKO0FBYVpDLGFBQWdCLEVBYko7QUFjWkMsY0FBZ0IsRUFkSjtBQWVaQyxtQkFBZ0IsRUFmSjtBQWdCWkMsaUJBQWdCLEVBaEJKO0FBaUJaQyxvQkFBZ0IsRUFqQko7QUFrQlpDLG1CQUFnQixFQWxCSjtBQW1CWkMsZ0JBQWdCLEVBbkJKO0FBb0JaQyxnQkFBZ0IsRUFwQko7QUFxQlpDLGNBQWdCLEVBckJKO0FBc0JaQyxjQUFnQixFQXRCSjtBQXVCWkMsY0FBZ0IsRUF2Qko7QUF3QlpDLGNBQWdCLEVBeEJKO0FBeUJaQyxjQUFnQixFQXpCSjtBQTBCWkMsY0FBZ0IsRUExQko7QUEyQlpDLGNBQWdCLEVBM0JKO0FBNEJaQyxjQUFnQixFQTVCSjtBQTZCWkMsY0FBZ0IsRUE3Qko7QUE4QlpDLGNBQWdCLEVBOUJKO0FBK0JaQyxXQUFnQixFQS9CSjtBQWdDWkMsV0FBZ0IsRUFoQ0o7QUFpQ1pDLFdBQWdCLEVBakNKO0FBa0NaQyxXQUFnQixFQWxDSjtBQW1DWkMsV0FBZ0IsRUFuQ0o7QUFvQ1pDLFdBQWdCLEVBcENKO0FBcUNaQyxXQUFnQixFQXJDSjtBQXNDWkMsV0FBZ0IsRUF0Q0o7QUF1Q1pDLFdBQWdCLEVBdkNKO0FBd0NaQyxXQUFnQixFQXhDSjtBQXlDWkMsV0FBZ0IsRUF6Q0o7QUEwQ1pDLFdBQWdCLEVBMUNKO0FBMkNaQyxXQUFnQixFQTNDSjtBQTRDWkMsV0FBZ0IsRUE1Q0o7QUE2Q1pDLFdBQWdCLEVBN0NKO0FBOENaQyxXQUFnQixFQTlDSjtBQStDWkMsV0FBZ0IsRUEvQ0o7QUFnRFpDLFdBQWdCLEVBaERKO0FBaURaQyxXQUFnQixFQWpESjtBQWtEWkMsV0FBZ0IsRUFsREo7QUFtRFpDLFdBQWdCLEVBbkRKO0FBb0RaQyxXQUFnQixFQXBESjtBQXFEWkMsV0FBZ0IsRUFyREo7QUFzRFpDLFdBQWdCLEVBdERKO0FBdURaQyxXQUFnQixFQXZESjtBQXdEWkMsV0FBZ0IsRUF4REo7QUF5RFpDLGlCQUFnQixFQXpESjtBQTBEWkMsb0JBQWdCLEVBMURKO0FBMkRaQyxpQkFBZ0IsRUEzREo7QUE0RFpDLGlCQUFnQixFQTVESjtBQTZEWkMsaUJBQWdCLEVBN0RKO0FBOERaQyxpQkFBZ0IsRUE5REo7QUErRFpDLGlCQUFnQixHQS9ESjtBQWdFWkMsaUJBQWdCLEdBaEVKO0FBaUVaQyxpQkFBZ0IsR0FqRUo7QUFrRVpDLGlCQUFnQixHQWxFSjtBQW1FWkMsaUJBQWdCLEdBbkVKO0FBb0VaQyxpQkFBZ0IsR0FwRUo7QUFxRVpDLHdCQUFnQixHQXJFSjtBQXNFWkMsb0JBQWdCLEdBdEVKO0FBdUVaQyxxQkFBZ0IsR0F2RUo7QUF3RVpDLG1CQUFnQixHQXhFSjtBQXlFWkMscUJBQWdCLEdBekVKO0FBMEVaQyxZQUFnQixHQTFFSjtBQTJFWkMsWUFBZ0IsR0EzRUo7QUE0RVpDLFlBQWdCLEdBNUVKO0FBNkVaQyxZQUFnQixHQTdFSjtBQThFWkMsWUFBZ0IsR0E5RUo7QUErRVpDLFlBQWdCLEdBL0VKO0FBZ0ZaQyxZQUFnQixHQWhGSjtBQWlGWkMsWUFBZ0IsR0FqRko7QUFrRlpDLFlBQWdCLEdBbEZKO0FBbUZaQyxhQUFnQixHQW5GSjtBQW9GWkMsYUFBZ0IsR0FwRko7QUFxRlpDLGFBQWdCLEdBckZKO0FBc0ZaQyxpQkFBZ0IsR0F0Rko7QUF1RlpDLG9CQUFnQixHQXZGSjtBQXdGWkMsb0JBQWdCLEdBeEZKO0FBeUZaQyxzQkFBZ0IsR0F6Rko7QUEwRlpDLG1CQUFnQixHQTFGSjtBQTJGWkMsZUFBZ0IsR0EzRko7QUE0RlpDLGVBQWdCLEdBNUZKO0FBNkZaQyxnQkFBZ0IsR0E3Rko7QUE4RlpDLGFBQWdCLEdBOUZKO0FBK0ZaQyxlQUFnQixHQS9GSjtBQWdHWkMsbUJBQWdCLEdBaEdKO0FBaUdaQyxxQkFBZ0IsR0FqR0o7QUFrR1pDLG1CQUFnQixHQWxHSjtBQW1HWkMsc0JBQWdCLEdBbkdKO0FBb0daQyxlQUFnQixHQXBHSjtBQXFHWkMsaUJBQWdCO0FBckdKLEtBQWhCOztBQXdHQTs7Ozs7OztBQU9BLGFBQVNDLE1BQVQsQ0FBZ0JDLEtBQWhCLEVBQXVCO0FBQ25CLGVBQU9BLFVBQVUsSUFBakI7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLGFBQVNDLFdBQVQsQ0FBcUJELEtBQXJCLEVBQTRCO0FBQ3hCLGVBQU9BLFVBQVUsS0FBSyxDQUF0QjtBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTRSx3QkFBVCxDQUFrQ0YsS0FBbEMsRUFBeUM7QUFDckMsZUFBT0EsVUFBVSxJQUFWLElBQWtCQSxVQUFVLEtBQUssQ0FBakMsSUFBdUMsT0FBT0EsS0FBckQ7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBU0csUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDbkIsZUFBUSxPQUFPQSxHQUFQLEtBQWUsUUFBZixJQUEyQkEsZUFBZUMsTUFBbEQ7QUFDSDs7QUFFRDs7Ozs7OztBQU9BLGFBQVNDLFNBQVQsQ0FBbUJOLEtBQW5CLEVBQTBCO0FBQ3RCLGVBQU8sT0FBT0EsS0FBUCxLQUFrQixTQUF6QjtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU08sbUJBQVQsQ0FBNkJQLEtBQTdCLEVBQW9DO0FBQ2hDLFlBQU1RLGlCQUFpQkgsT0FBT0wsS0FBUCxFQUFjUyxXQUFkLEVBQXZCO0FBQ0EsZUFBT0QsbUJBQW1CLE1BQW5CLElBQTZCQSxtQkFBbUIsT0FBdkQ7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBU0UsUUFBVCxDQUFrQkMsU0FBbEIsRUFBNkI7QUFDekIsZUFBTyxRQUFPQSxTQUFQLHlDQUFPQSxTQUFQLE9BQXFCLFFBQXJCLElBQWlDQSxjQUFjLElBQS9DLElBQXVELENBQUNDLE1BQU1DLE9BQU4sQ0FBY0YsU0FBZCxDQUEvRDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0csVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDckIsYUFBSyxJQUFNQyxJQUFYLElBQW1CRCxHQUFuQixFQUF3QjtBQUNwQixnQkFBSUEsSUFBSUUsY0FBSixDQUFtQkQsSUFBbkIsQ0FBSixFQUE4QjtBQUMxQix1QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7OztBQVFBLGFBQVNFLFFBQVQsQ0FBa0JkLEdBQWxCLEVBQXVCZSxNQUF2QixFQUErQjtBQUMzQixZQUFJLENBQUNoQixTQUFTQyxHQUFULENBQUQsSUFBa0IsQ0FBQ0QsU0FBU2dCLE1BQVQsQ0FBbkIsSUFBdUNmLFFBQVEsRUFBL0MsSUFBcURlLFdBQVcsRUFBcEUsRUFBd0U7QUFDcEUsbUJBQU8sS0FBUDtBQUNIOztBQUVELGVBQU9mLElBQUlnQixPQUFKLENBQVlELE1BQVosTUFBd0IsQ0FBQyxDQUFoQztBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBU0UsU0FBVCxDQUFtQkYsTUFBbkIsRUFBMkJHLEtBQTNCLEVBQWtDO0FBQzlCLFlBQUksQ0FBQ1QsUUFBUVMsS0FBUixDQUFELElBQW1CQSxVQUFVLEVBQTdCLElBQW1DckIsWUFBWWtCLE1BQVosQ0FBdkMsRUFBNEQ7QUFDeEQsbUJBQU8sS0FBUDtBQUNIOztBQUVELGVBQU9HLE1BQU1GLE9BQU4sQ0FBY0QsTUFBZCxNQUEwQixDQUFDLENBQWxDO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTTixPQUFULENBQWlCVSxHQUFqQixFQUFzQjtBQUNsQixZQUFJQyxPQUFPQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0IsRUFBL0IsTUFBdUMsZ0JBQTNDLEVBQTZEO0FBQUU7QUFDM0Q7QUFDQSxtQkFBT2YsTUFBTUMsT0FBTixDQUFjVSxHQUFkLEtBQXVCLFFBQU9BLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFmLElBQTJCQyxPQUFPQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JKLEdBQS9CLE1BQXdDLGdCQUFqRztBQUNILFNBSEQsTUFJSztBQUNELGtCQUFNLElBQUlLLEtBQUosQ0FBVSwyQ0FBVixDQUFOLENBREMsQ0FDNkQ7QUFDakU7QUFDSjs7QUFFRDs7Ozs7O0FBTUEsYUFBU0MsV0FBVCxDQUFxQnpCLEdBQXJCLEVBQTBCO0FBQUEseUJBQ0VBLElBQUkwQixLQUFKLENBQVUsR0FBVixDQURGO0FBQUE7QUFBQSxZQUNiQyxXQURhOztBQUV0QixlQUFPLENBQUM5QixZQUFZOEIsV0FBWixDQUFSO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxhQUFTQyxhQUFULENBQXVCNUIsR0FBdkIsRUFBNEI7QUFBQSwwQkFDQUEsSUFBSTBCLEtBQUosQ0FBVSxHQUFWLENBREE7QUFBQTtBQUFBLFlBQ2ZDLFdBRGU7O0FBRXhCLFlBQUksQ0FBQzlCLFlBQVk4QixXQUFaLENBQUwsRUFBK0I7QUFDM0IsbUJBQU9BLFlBQVlFLE1BQW5CO0FBQ0g7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVNDLG1CQUFULENBQTZCQyxJQUE3QixFQUFtQztBQUMvQixZQUFNQyxXQUFXLEVBQWpCO0FBQ0EsWUFBSW5DLFlBQVlrQyxLQUFLRSxjQUFqQixDQUFKLEVBQXNDO0FBQ2xDRixpQkFBS0csS0FBTDtBQUNBLGdCQUFNQyxTQUFTQyxTQUFTQyxTQUFULENBQW1CQyxXQUFuQixFQUFmO0FBQ0FOLHFCQUFTSCxNQUFULEdBQWtCTSxPQUFPSSxJQUFQLENBQVlWLE1BQTlCO0FBQ0FNLG1CQUFPSyxTQUFQLENBQWlCLFdBQWpCLEVBQThCLENBQUNULEtBQUtuQyxLQUFMLENBQVdpQyxNQUExQztBQUNBRyxxQkFBU1MsR0FBVCxHQUFlTixPQUFPSSxJQUFQLENBQVlWLE1BQTNCO0FBQ0FHLHFCQUFTVSxLQUFULEdBQWlCVixTQUFTUyxHQUFULEdBQWVULFNBQVNILE1BQXpDO0FBQ0gsU0FQRCxNQU9PO0FBQ0hHLHFCQUFTVSxLQUFULEdBQWlCWCxLQUFLRSxjQUF0QjtBQUNBRCxxQkFBU1MsR0FBVCxHQUFlVixLQUFLWSxZQUFwQjtBQUNBWCxxQkFBU0gsTUFBVCxHQUFrQkcsU0FBU1MsR0FBVCxHQUFlVCxTQUFTVSxLQUExQztBQUNIOztBQUVELGVBQU9WLFFBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBU1ksbUJBQVQsQ0FBNkJiLElBQTdCLEVBQW1DVyxLQUFuQyxFQUEwQ0QsR0FBMUMsRUFBK0M7QUFDM0MsWUFBSTVDLFlBQVlrQyxLQUFLRSxjQUFqQixDQUFKLEVBQXNDO0FBQ2xDRixpQkFBS0csS0FBTDtBQUNBLGdCQUFNVyxRQUFRZCxLQUFLZSxlQUFMLEVBQWQ7QUFDQUQsa0JBQU1FLFFBQU4sQ0FBZSxJQUFmO0FBQ0FGLGtCQUFNRyxPQUFOLENBQWMsV0FBZCxFQUEyQlAsR0FBM0I7QUFDQUksa0JBQU1MLFNBQU4sQ0FBZ0IsV0FBaEIsRUFBNkJFLEtBQTdCO0FBQ0FHLGtCQUFNVixNQUFOO0FBQ0gsU0FQRCxNQU9PO0FBQ0hKLGlCQUFLRSxjQUFMLEdBQXNCUyxLQUF0QjtBQUNBWCxpQkFBS1ksWUFBTCxHQUFvQkYsR0FBcEI7QUFDSDtBQUNKOztBQUVEOzs7QUFHQSxhQUFTUSxVQUFULENBQW9CQyxPQUFwQixFQUEyQztBQUFBLFlBQWRDLEtBQWMsdUVBQU4sSUFBTTs7QUFDdkMsWUFBSUEsS0FBSixFQUFXO0FBQ1Asa0JBQU0sSUFBSTNCLEtBQUosQ0FBVTBCLE9BQVYsQ0FBTjtBQUNIO0FBQ0o7O0FBRUQ7OztBQUdBLGFBQVNFLE9BQVQsQ0FBaUJGLE9BQWpCLEVBQW9EO0FBQUEsWUFBMUJHLGdCQUEwQix1RUFBUCxLQUFPOztBQUNoRCxZQUFJQSxnQkFBSixFQUFzQjtBQUNsQjtBQUNBQyxvQkFBUUMsSUFBUixlQUF5QkwsT0FBekI7QUFDSDtBQUNKOztBQUVEOzs7Ozs7QUFNQSxhQUFTTSxZQUFULENBQXNCQyxLQUF0QixFQUE2QkMsUUFBN0IsRUFBdUM7QUFDbkM7QUFDQUMsVUFBRUMsSUFBRixDQUFPRixRQUFQLEVBQWlCLFVBQUM1SCxDQUFELEVBQUkrSCxHQUFKLEVBQVk7QUFDekIsZ0JBQUksT0FBT0EsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQzNCSCx5QkFBUzVILENBQVQsSUFBYytILElBQUlKLEtBQUosRUFBV0MsUUFBWCxFQUFxQjVILENBQXJCLENBQWQ7QUFDSCxhQUZELE1BRU8sSUFBSSxPQUFPMkgsTUFBTUssV0FBTixDQUFrQkQsR0FBbEIsQ0FBUCxLQUFrQyxVQUF0QyxFQUFrRDtBQUNyRDtBQUNBSCx5QkFBUzVILENBQVQsSUFBYzJILE1BQU1LLFdBQU4sQ0FBa0JELEdBQWxCLEVBQXVCSixLQUF2QixFQUE4QkMsUUFBOUIsRUFBd0M1SCxDQUF4QyxDQUFkO0FBQ0g7QUFDSixTQVBEO0FBUUg7O0FBRUQ7OztBQUdBLGFBQVNpSSxTQUFULENBQW1CQyxJQUFuQixFQUF5QkMsSUFBekIsRUFBK0I7QUFDM0IsWUFBSUMsYUFBYSxDQUFqQjtBQUNBLFlBQUlDLGFBQWEsQ0FBakI7QUFDQSxZQUFJRixLQUFLLENBQUwsQ0FBSixFQUFhO0FBQ1RDLHlCQUFhRCxLQUFLLENBQUwsRUFBUXBDLE1BQXJCO0FBQ0g7QUFDRCxZQUFJbUMsS0FBSyxDQUFMLENBQUosRUFBYTtBQUNURyx5QkFBYUgsS0FBSyxDQUFMLEVBQVFuQyxNQUFyQjtBQUNIOztBQUVELGVBQU91QyxLQUFLQyxHQUFMLENBQVNILFVBQVQsRUFBcUJDLFVBQXJCLENBQVA7QUFDSDs7QUFFRDs7OztBQUlBLGFBQVNHLFFBQVQsQ0FBa0JiLEtBQWxCLEVBQXlCQyxRQUF6QixFQUFtQztBQUMvQkYscUJBQWFDLEtBQWIsRUFBb0JDLFFBQXBCO0FBQ0EsWUFBTU8sT0FBT1AsU0FBU08sSUFBVCxDQUFjM0MsUUFBZCxHQUF5QkksS0FBekIsQ0FBK0IsR0FBL0IsQ0FBYjtBQUNBLFlBQU1zQyxPQUFRLENBQUNOLFNBQVNNLElBQVYsSUFBa0JOLFNBQVNNLElBQVQsS0FBa0IsQ0FBckMsR0FBMEMsRUFBMUMsR0FBK0NOLFNBQVNNLElBQVQsQ0FBYzFDLFFBQWQsR0FBeUJJLEtBQXpCLENBQStCLEdBQS9CLENBQTVEO0FBQ0FnQyxpQkFBU2EsSUFBVCxHQUFnQmIsU0FBU00sSUFBVCxHQUFnQixDQUFoQixHQUFvQixHQUFwQixHQUEwQixFQUExQztBQUNBQyxhQUFLLENBQUwsSUFBVUEsS0FBSyxDQUFMLEVBQVFPLE9BQVIsQ0FBZ0IsR0FBaEIsRUFBcUIsRUFBckIsQ0FBVjtBQUNBUixhQUFLLENBQUwsSUFBVUEsS0FBSyxDQUFMLEVBQVFRLE9BQVIsQ0FBZ0IsR0FBaEIsRUFBcUIsRUFBckIsQ0FBVjtBQUNBZCxpQkFBU2UsT0FBVCxHQUFtQkwsS0FBS0MsR0FBTCxDQUFTSixLQUFLLENBQUwsRUFBUXBDLE1BQWpCLEVBQXlCLENBQXpCLENBQW5CO0FBQ0E2QixpQkFBU2dCLE9BQVQsR0FBbUJOLEtBQUtDLEdBQUwsQ0FBU0wsS0FBSyxDQUFMLEVBQVFuQyxNQUFqQixFQUF5QixDQUF6QixDQUFuQjtBQUNBLFlBQUk2QixTQUFTaUIsSUFBVCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QmpCLHFCQUFTaUIsSUFBVCxHQUFnQlosVUFBVUMsSUFBVixFQUFnQkMsSUFBaEIsQ0FBaEI7QUFDQVAscUJBQVNrQixJQUFULEdBQWdCbEIsU0FBU2lCLElBQXpCO0FBQ0gsU0FIRCxNQUdPO0FBQ0hqQixxQkFBU2lCLElBQVQsR0FBZ0JFLE9BQU9uQixTQUFTaUIsSUFBaEIsQ0FBaEI7QUFDSDs7QUFFRGpCLGlCQUFTaUIsSUFBVCxHQUFpQmpCLFNBQVNvQixZQUFULElBQXlCcEIsU0FBU3FCLFlBQW5DLEdBQW1EckIsU0FBU3FCLFlBQTVELEdBQTJFckIsU0FBU2lCLElBQXBHOztBQUVBO0FBQ0EsWUFBSWpCLFNBQVNzQixNQUFULEtBQW9CLElBQXBCLElBQTRCdEIsU0FBU2lCLElBQVQsR0FBZ0IsQ0FBaEQsRUFBbUQ7QUFDL0MsZ0JBQUlqQixTQUFTdUIsSUFBVCxLQUFrQixHQUFsQixJQUF5QnZCLFNBQVN3QixJQUFULEtBQWtCLEdBQS9DLEVBQW9EO0FBQ2hEeEIseUJBQVNzQixNQUFULEdBQWtCLEdBQWxCO0FBQ0gsYUFGRCxNQUVPLElBQUl0QixTQUFTdUIsSUFBVCxLQUFrQixHQUFsQixJQUF5QnZCLFNBQVN3QixJQUFULEtBQWtCLEdBQS9DLEVBQW9EO0FBQ3ZEeEIseUJBQVNzQixNQUFULEdBQWtCLEdBQWxCO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFlBQU1HLFVBQVV6QixTQUFTYSxJQUFULGFBQXVCYixTQUFTYSxJQUFoQyxXQUEyQyxNQUEzRDtBQUNBYixpQkFBUzBCLGdCQUFULEdBQTRCRCxPQUE1QjtBQUNBekIsaUJBQVMyQixrQkFBVCxHQUE4QixJQUFJQyxNQUFKLENBQWNILE9BQWQsWUFBNEJ6QixTQUFTYSxJQUFULFVBQW1CYixTQUFTYSxJQUE1QixHQUFtQyxFQUEvRCxXQUF1RWIsU0FBU3VCLElBQWhGLHNCQUFxR3ZCLFNBQVN1QixJQUE5RyxVQUE5QjtBQUNBdkIsaUJBQVM2QixpQkFBVCxHQUE2QixJQUFJRCxNQUFKLFlBQW9CNUIsU0FBU3VCLElBQTdCLGNBQTBDdkIsU0FBU3VCLElBQW5ELGVBQTdCO0FBQ0EsWUFBTU8sNEJBQTBCOUIsU0FBU3VCLElBQXpDO0FBQ0F2QixpQkFBUytCLGdCQUFULEdBQTRCLElBQUlILE1BQUosUUFBZ0JFLE9BQWhCLFFBQTRCLElBQTVCLENBQTVCO0FBQ0E5QixpQkFBU2dDLGVBQVQsR0FBMkIsSUFBSUosTUFBSixDQUFjSCxPQUFkLGFBQTZCekIsU0FBU3VCLElBQXRDLGdCQUFxRHZCLFNBQVN1QixJQUE5RCx3QkFBcUZ2QixTQUFTdUIsSUFBOUYsY0FBM0I7O0FBRUEsZUFBT3ZCLFFBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBU2lDLFNBQVQsQ0FBbUJySixDQUFuQixFQUFzQm9ILFFBQXRCLEVBQWdDO0FBQzVCLFlBQUlBLFNBQVNrQyxLQUFULEtBQW1CLEVBQXZCLEVBQTJCO0FBQ3ZCO0FBQ0F0SixnQkFBSUEsRUFBRWtJLE9BQUYsQ0FBVWQsU0FBU2tDLEtBQW5CLEVBQTBCLEVBQTFCLENBQUo7QUFDSDtBQUNELFlBQUlsQyxTQUFTbUMsT0FBYixFQUFzQjtBQUNsQjtBQUNBLG1CQUFPL0UsU0FBU3hFLENBQVQsRUFBWW9ILFNBQVNtQyxPQUFyQixDQUFQLEVBQXNDO0FBQ2xDdkosb0JBQUlBLEVBQUVrSSxPQUFGLENBQVVkLFNBQVNtQyxPQUFuQixFQUE0QixFQUE1QixDQUFKO0FBQ0g7QUFDSjs7QUFFRDtBQUNBdkosWUFBSUEsRUFBRWtJLE9BQUYsQ0FBVWQsU0FBUzJCLGtCQUFuQixFQUF1QyxNQUF2QyxDQUFKOztBQUVBLFlBQUksQ0FBQzNCLFNBQVNvQyxJQUFULEtBQWtCLEdBQWxCLElBQTBCcEMsU0FBU3FDLEtBQVQsS0FBbUIsR0FBbkIsSUFBMEJyQyxTQUFTb0MsSUFBVCxLQUFrQixHQUF2RSxLQUFnRmhGLFNBQVN4RSxDQUFULEVBQVksR0FBWixDQUFoRixJQUFvR0EsTUFBTSxFQUE5RyxFQUFrSDtBQUM5R29ILHFCQUFTc0MsZ0JBQVQsR0FBNEIsSUFBNUI7QUFDSDs7QUFFRDtBQUNBMUosWUFBSUEsRUFBRWtJLE9BQUYsQ0FBVWQsU0FBUzZCLGlCQUFuQixFQUFzQyxJQUF0QyxDQUFKOztBQUVBO0FBQ0FqSixZQUFJQSxFQUFFa0ksT0FBRixDQUFVZCxTQUFTK0IsZ0JBQW5CLEVBQXFDLEVBQXJDLENBQUo7QUFDQSxZQUFJL0IsU0FBU3NCLE1BQWIsRUFBcUI7QUFDakIxSSxnQkFBSUEsRUFBRWtJLE9BQUYsQ0FBVWQsU0FBU3NCLE1BQW5CLEVBQTJCdEIsU0FBU3VCLElBQXBDLENBQUo7QUFDSDs7QUFFRDtBQUNBLFlBQU1qSixJQUFJTSxFQUFFMkosS0FBRixDQUFRdkMsU0FBU2dDLGVBQWpCLENBQVY7QUFDQXBKLFlBQUlOLElBQUksQ0FBQ0EsRUFBRSxDQUFGLENBQUQsRUFBT0EsRUFBRSxDQUFGLENBQVAsRUFBYUEsRUFBRSxDQUFGLENBQWIsRUFBbUJrSyxJQUFuQixDQUF3QixFQUF4QixDQUFKLEdBQWtDLEVBQXRDO0FBQ0EsWUFBSXhDLFNBQVN5QyxLQUFULEtBQW1CLE9BQW5CLElBQThCekMsU0FBU3lDLEtBQVQsS0FBbUIsTUFBckQsRUFBNkQ7QUFDekQsZ0JBQUlDLFFBQVEsRUFBWjs7QUFEeUQsMkJBRXRCOUosRUFBRW9GLEtBQUYsQ0FBUWdDLFNBQVN1QixJQUFqQixDQUZzQjtBQUFBO0FBQUEsZ0JBRWxEb0IsV0FGa0Q7QUFBQSxnQkFFckMxRSxXQUZxQzs7QUFHekQsZ0JBQUkyRSxzQkFBc0JELFdBQTFCO0FBQ0EsZ0JBQUl2RixTQUFTd0YsbUJBQVQsRUFBOEI1QyxTQUFTYSxJQUF2QyxDQUFKLEVBQWtEO0FBQzlDNkIsd0JBQVExQyxTQUFTYSxJQUFqQjtBQUNBK0Isc0NBQXNCQSxvQkFBb0I5QixPQUFwQixDQUE0QmQsU0FBU2EsSUFBckMsRUFBMkMsRUFBM0MsQ0FBdEI7QUFDSDs7QUFFRDtBQUNBLGdCQUFJNkIsVUFBVSxFQUFWLElBQWdCRSxvQkFBb0J6RSxNQUFwQixHQUE2QjZCLFNBQVNlLE9BQXRELElBQWlFNkIsb0JBQW9CQyxNQUFwQixDQUEyQixDQUEzQixNQUFrQyxHQUF2RyxFQUE0RztBQUN4R0Qsc0NBQXNCQSxvQkFBb0JFLEtBQXBCLENBQTBCLENBQTFCLENBQXRCO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSUosVUFBVSxFQUFWLElBQWdCRSxvQkFBb0J6RSxNQUFwQixHQUE2QjZCLFNBQVNnQixPQUF0RCxJQUFpRTRCLG9CQUFvQkMsTUFBcEIsQ0FBMkIsQ0FBM0IsTUFBa0MsR0FBdkcsRUFBNEc7QUFDeEdELHNDQUFzQkEsb0JBQW9CRSxLQUFwQixDQUEwQixDQUExQixDQUF0QjtBQUNIO0FBQ0RsSyxxQkFBTzhKLEtBQVAsR0FBZUUsbUJBQWYsSUFBcUN6RyxZQUFZOEIsV0FBWixJQUF5QixFQUF6QixHQUE0QitCLFNBQVN1QixJQUFULEdBQWdCdEQsV0FBakY7QUFDSDtBQUNELFlBQUsrQixTQUFTK0MsS0FBVCxJQUFrQi9DLFNBQVN5QyxLQUFULEtBQW1CLE1BQXRDLElBQWtEekMsU0FBU3lDLEtBQVQsS0FBbUIsT0FBbkIsSUFBOEJ6QyxTQUFTK0MsS0FBVCxLQUFtQixLQUF2RyxFQUErRztBQUMzRztBQUNBLGdCQUFJQyxpQkFBZWhELFNBQVMwQixnQkFBeEIsWUFBSjtBQUNBc0IsdUJBQVcsSUFBSXBCLE1BQUosQ0FBV29CLFFBQVgsQ0FBWDtBQUNBcEssZ0JBQUlBLEVBQUVrSSxPQUFGLENBQVVrQyxRQUFWLEVBQW9CLE1BQXBCLENBQUo7QUFDSDs7QUFFRCxlQUFPcEssQ0FBUDtBQUNIOztBQUVEOzs7QUFHQSxhQUFTcUssZUFBVCxDQUF5QnJLLENBQXpCLEVBQTRCb0gsUUFBNUIsRUFBc0M7QUFDbEMsWUFBS0EsU0FBU3FDLEtBQVQsS0FBbUIsR0FBbkIsSUFBMEJyQyxTQUFTb0MsSUFBVCxLQUFrQixHQUE3QyxJQUFzRHBDLFNBQVNxQyxLQUFULEtBQW1CLEdBQW5CLElBQTBCckMsU0FBU29DLElBQVQsS0FBa0IsR0FBdEcsRUFBNEc7QUFBQSx3Q0FDcEVwQyxTQUFTa0QsUUFBVCxDQUFrQmxGLEtBQWxCLENBQXdCLEdBQXhCLENBRG9FO0FBQUE7QUFBQSxnQkFDakdtRixZQURpRztBQUFBLGdCQUNuRkMsV0FEbUY7O0FBRXhHLGdCQUFJLENBQUNwRCxTQUFTK0MsS0FBZCxFQUFxQjtBQUNqQm5LLG9CQUFJQSxFQUFFa0ksT0FBRixDQUFVZCxTQUFTYSxJQUFuQixFQUF5QixFQUF6QixDQUFKO0FBQ0FqSSxvQkFBSXVLLGVBQWV2SyxDQUFmLEdBQW1Cd0ssV0FBdkI7QUFDSCxhQUhELE1BR08sSUFBSXBELFNBQVMrQyxLQUFULElBQWtCbkssRUFBRWlLLE1BQUYsQ0FBUyxDQUFULE1BQWdCTSxZQUF0QyxFQUFvRDtBQUN2RHZLLG9CQUFJQSxFQUFFa0ksT0FBRixDQUFVcUMsWUFBVixFQUF3Qm5ELFNBQVNhLElBQWpDLENBQUo7QUFDQWpJLG9CQUFJQSxFQUFFa0ksT0FBRixDQUFVc0MsV0FBVixFQUF1QixFQUF2QixDQUFKO0FBQ0g7QUFDSjs7QUFFRCxlQUFPeEssQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7O0FBVUEsYUFBU3lLLFVBQVQsQ0FBb0J6SyxDQUFwQixFQUF1QjtBQUNuQkEsWUFBSUEsRUFBRWtJLE9BQUYsQ0FBVSxHQUFWLEVBQWUsR0FBZixDQUFKO0FBQ0EsWUFBSTFELFNBQVN4RSxDQUFULEVBQVksR0FBWixLQUFvQkEsRUFBRTBLLFdBQUYsQ0FBYyxHQUFkLE1BQXVCMUssRUFBRXVGLE1BQUYsR0FBVyxDQUExRCxFQUE2RDtBQUN6RHZGLGdCQUFJQSxFQUFFa0ksT0FBRixDQUFVLEdBQVYsRUFBZSxFQUFmLENBQUo7QUFDQWxJLGdCQUFJLE1BQU1BLENBQVY7QUFDSDs7QUFFRCxlQUFPQSxDQUFQO0FBQ0g7O0FBRUQ7Ozs7Ozs7O0FBUUEsYUFBUzJLLFFBQVQsQ0FBa0JySCxLQUFsQixFQUF5QnNILE1BQXpCLEVBQWlDO0FBQzdCLFlBQUlBLFdBQVcsSUFBZixFQUFxQjtBQUNqQnRILG9CQUFRa0IsU0FBU2xCLEtBQVQsRUFBZ0IsR0FBaEIsSUFBdUJBLE1BQU00RSxPQUFOLENBQWMsR0FBZCxFQUFtQixFQUFuQixJQUF5QixHQUFoRCxHQUFzRDVFLEtBQTlEO0FBQ0g7QUFDRCxZQUFJc0gsV0FBVyxHQUFYLElBQWtCQSxXQUFXLElBQWpDLEVBQXVDO0FBQ25DdEgsb0JBQVFBLE1BQU00RSxPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFSO0FBQ0g7QUFDRCxZQUFJMEMsV0FBVyxJQUFmLEVBQXFCO0FBQ2pCdEgsb0JBQVFBLE1BQU00RSxPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFSO0FBQ0E1RSxvQkFBUWtCLFNBQVNsQixLQUFULEVBQWdCLEdBQWhCLElBQXVCQSxNQUFNNEUsT0FBTixDQUFjLEdBQWQsRUFBbUIsRUFBbkIsSUFBeUIsR0FBaEQsR0FBc0Q1RSxLQUE5RDtBQUNIOztBQUVELGVBQU9BLEtBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBU3VILFNBQVQsQ0FBbUI3SyxDQUFuQixFQUFzQjJJLElBQXRCLEVBQTRCVixJQUE1QixFQUFrQztBQUM5QixZQUFJVSxRQUFRQSxTQUFTLEdBQXJCLEVBQTBCO0FBQ3RCM0ksZ0JBQUlBLEVBQUVrSSxPQUFGLENBQVVTLElBQVYsRUFBZ0IsR0FBaEIsQ0FBSjtBQUNIO0FBQ0QsWUFBSVYsUUFBUUEsU0FBUyxHQUFyQixFQUEwQjtBQUN0QmpJLGdCQUFJQSxFQUFFa0ksT0FBRixDQUFVRCxJQUFWLEVBQWdCLEdBQWhCLENBQUo7QUFDSDtBQUNELFlBQUksQ0FBQ2pJLEVBQUUySixLQUFGLENBQVEsSUFBUixDQUFMLEVBQW9CO0FBQ2hCM0osaUJBQUssR0FBTDtBQUNIOztBQUVELGVBQU9BLENBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBUzhLLGFBQVQsQ0FBdUI5SyxDQUF2QixFQUEwQm9ILFFBQTFCLEVBQW9DO0FBQ2hDLFlBQUlBLFNBQVNhLElBQVQsSUFBaUJiLFNBQVNhLElBQVQsS0FBa0IsR0FBdkMsRUFBNEM7QUFDeENqSSxnQkFBSUEsRUFBRWtJLE9BQUYsQ0FBVSxHQUFWLEVBQWVkLFNBQVNhLElBQXhCLENBQUo7QUFDSDtBQUNELFlBQUliLFNBQVN1QixJQUFULElBQWlCdkIsU0FBU3VCLElBQVQsS0FBa0IsR0FBdkMsRUFBNEM7QUFDeEMzSSxnQkFBSUEsRUFBRWtJLE9BQUYsQ0FBVSxHQUFWLEVBQWVkLFNBQVN1QixJQUF4QixDQUFKO0FBQ0g7O0FBRUQsZUFBTzNJLENBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBUytLLFVBQVQsQ0FBb0JDLEVBQXBCLEVBQXdCNUQsUUFBeEIsRUFBa0M2RCxXQUFsQyxFQUErQztBQUMzQyxZQUFJRCxPQUFPLEVBQVAsSUFBYUEsT0FBTzVELFNBQVNhLElBQWpDLEVBQXVDO0FBQ25DLGdCQUFJYixTQUFTOEQsTUFBVCxLQUFvQixRQUFwQixJQUFnQ0QsV0FBcEMsRUFBaUQ7QUFDN0MsdUJBQVE3RCxTQUFTb0MsSUFBVCxLQUFrQixHQUFuQixHQUEwQndCLEtBQUs1RCxTQUFTa0MsS0FBZCxHQUFzQmxDLFNBQVNtQyxPQUF6RCxHQUFtRW5DLFNBQVNrQyxLQUFULEdBQWlCMEIsRUFBakIsR0FBc0I1RCxTQUFTbUMsT0FBekc7QUFDSDtBQUNELG1CQUFPeUIsRUFBUDtBQUNIOztBQUVELGVBQU8sSUFBUDtBQUNIOztBQUVEOzs7QUFHQSxhQUFTRyxTQUFULENBQW1CSCxFQUFuQixFQUF1QjVELFFBQXZCLEVBQWlDO0FBQzdCLFlBQUlBLFNBQVNnRSxLQUFiLEVBQW9CO0FBQ2hCSixpQkFBSzNCLFVBQVUyQixFQUFWLEVBQWM1RCxRQUFkLENBQUw7QUFDSDtBQUNELFlBQUlBLFNBQVNzQyxnQkFBVCxJQUE2QixDQUFDbEYsU0FBU3dHLEVBQVQsRUFBYSxHQUFiLENBQWxDLEVBQXFEO0FBQ2pEQSxpQkFBSyxNQUFNQSxFQUFYO0FBQ0g7QUFDRCxZQUFNSyxRQUFRTixXQUFXQyxFQUFYLEVBQWU1RCxRQUFmLEVBQXlCLElBQXpCLENBQWQ7QUFDQSxZQUFNa0UsUUFBUTlHLFNBQVN3RyxFQUFULEVBQWEsR0FBYixDQUFkO0FBQ0EsWUFBSU0sS0FBSixFQUFXO0FBQ1BOLGlCQUFLQSxHQUFHOUMsT0FBSCxDQUFXLEdBQVgsRUFBZ0IsRUFBaEIsQ0FBTDtBQUNIO0FBQ0QsWUFBSW1ELFVBQVUsSUFBZCxFQUFvQjtBQUNoQixtQkFBT0EsS0FBUDtBQUNIO0FBQ0QsWUFBSUUsZUFBZSxFQUFuQjtBQUNBbkUsaUJBQVNvRSxNQUFULEdBQWtCcEUsU0FBU29FLE1BQVQsQ0FBZ0J4RyxRQUFoQixFQUFsQjtBQUNBLFlBQUlvQyxTQUFTb0UsTUFBVCxLQUFvQixHQUF4QixFQUE2QjtBQUN6QkQsMkJBQWUsc0JBQWY7QUFDSCxTQUZELE1BRU8sSUFBSW5FLFNBQVNvRSxNQUFULEtBQW9CLElBQXhCLEVBQThCO0FBQ2pDRCwyQkFBZSxtREFBZjtBQUNILFNBRk0sTUFFQSxJQUFJbkUsU0FBU29FLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDaENELDJCQUFlLGtCQUFmO0FBQ0gsU0FGTSxNQUVBO0FBQ0hBLDJCQUFlLGtCQUFmO0FBQ0g7O0FBRUQ7O0FBM0I2Qix3QkE0QklQLEdBQUc1RixLQUFILENBQVNnQyxTQUFTdUIsSUFBbEIsQ0E1Qko7QUFBQTtBQUFBLFlBNEJ4Qm9CLFdBNUJ3QjtBQUFBLFlBNEJYMUUsV0E1Qlc7O0FBNkI3QixZQUFJK0IsU0FBU3NCLE1BQVQsSUFBbUJuRixZQUFZOEIsV0FBWixDQUF2QixFQUFpRDtBQUFBLDZCQUNoQjJGLEdBQUc1RixLQUFILENBQVNnQyxTQUFTc0IsTUFBbEIsQ0FEZ0I7O0FBQUE7O0FBQzVDcUIsdUJBRDRDO0FBQy9CMUUsdUJBRCtCO0FBRWhEO0FBQ0QsWUFBSStCLFNBQVN3QixJQUFULEtBQWtCLEVBQXRCLEVBQTBCO0FBQ3RCO0FBQ0EsbUJBQU8yQyxhQUFhRSxJQUFiLENBQWtCMUIsV0FBbEIsQ0FBUCxFQUF1QztBQUNuQ0EsOEJBQWNBLFlBQVk3QixPQUFaLENBQW9CcUQsWUFBcEIsU0FBdUNuRSxTQUFTd0IsSUFBaEQsUUFBZDtBQUNIO0FBQ0o7QUFDRCxZQUFJeEIsU0FBU2lCLElBQVQsS0FBa0IsQ0FBbEIsSUFBdUIsQ0FBQzlFLFlBQVk4QixXQUFaLENBQTVCLEVBQXNEO0FBQ2xELGdCQUFJQSxZQUFZRSxNQUFaLEdBQXFCNkIsU0FBU2lCLElBQWxDLEVBQXdDO0FBQ3BDaEQsOEJBQWNBLFlBQVlxRyxTQUFaLENBQXNCLENBQXRCLEVBQXlCdEUsU0FBU2lCLElBQWxDLENBQWQ7QUFDSDs7QUFFRDtBQUNBMkMsaUJBQUtqQixjQUFjM0MsU0FBU3VCLElBQXZCLEdBQThCdEQsV0FBbkM7QUFDSCxTQVBELE1BT087QUFDSDtBQUNBMkYsaUJBQUtqQixXQUFMO0FBQ0g7QUFDRCxZQUFJM0MsU0FBU3FDLEtBQVQsS0FBbUIsR0FBdkIsRUFBNEI7QUFDeEIsZ0JBQUk2QixTQUFTbEUsU0FBU29DLElBQVQsS0FBa0IsR0FBL0IsRUFBb0M7QUFDaEN3QixxQkFBSzVELFNBQVNhLElBQVQsR0FBZ0JiLFNBQVNrQyxLQUF6QixHQUFpQzBCLEVBQXRDO0FBQ0g7QUFDRCxnQkFBSU0sU0FBU2xFLFNBQVNvQyxJQUFULEtBQWtCLEdBQS9CLEVBQW9DO0FBQ2hDd0IscUJBQUs1RCxTQUFTa0MsS0FBVCxHQUFpQmxDLFNBQVNhLElBQTFCLEdBQWlDK0MsRUFBdEM7QUFDSDtBQUNELGdCQUFJTSxTQUFTbEUsU0FBU29DLElBQVQsS0FBa0IsR0FBL0IsRUFBb0M7QUFDaEN3QixxQkFBSzVELFNBQVNrQyxLQUFULEdBQWlCMEIsRUFBakIsR0FBc0I1RCxTQUFTYSxJQUFwQztBQUNIO0FBQ0QsZ0JBQUksQ0FBQ3FELEtBQUwsRUFBWTtBQUNSTixxQkFBSzVELFNBQVNrQyxLQUFULEdBQWlCMEIsRUFBdEI7QUFDSDtBQUNKO0FBQ0QsWUFBSTVELFNBQVNxQyxLQUFULEtBQW1CLEdBQXZCLEVBQTRCO0FBQ3hCLGdCQUFJNkIsU0FBU2xFLFNBQVNvQyxJQUFULEtBQWtCLEdBQS9CLEVBQW9DO0FBQ2hDd0IscUJBQUtBLEtBQUs1RCxTQUFTa0MsS0FBZCxHQUFzQmxDLFNBQVNhLElBQXBDO0FBQ0g7QUFDRCxnQkFBSXFELFNBQVNsRSxTQUFTb0MsSUFBVCxLQUFrQixHQUEvQixFQUFvQztBQUNoQ3dCLHFCQUFLQSxLQUFLNUQsU0FBU2EsSUFBZCxHQUFxQmIsU0FBU2tDLEtBQW5DO0FBQ0g7QUFDRCxnQkFBSWdDLFNBQVNsRSxTQUFTb0MsSUFBVCxLQUFrQixHQUEvQixFQUFvQztBQUNoQ3dCLHFCQUFLNUQsU0FBU2EsSUFBVCxHQUFnQitDLEVBQWhCLEdBQXFCNUQsU0FBU2tDLEtBQW5DO0FBQ0g7QUFDRCxnQkFBSSxDQUFDZ0MsS0FBTCxFQUFZO0FBQ1JOLHFCQUFLQSxLQUFLNUQsU0FBU2tDLEtBQW5CO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFlBQUlsQyxTQUFTa0QsUUFBVCxLQUFzQixJQUF0QixLQUErQmxELFNBQVN1RSxRQUFULEdBQW9CLENBQXBCLElBQXlCWCxHQUFHZixNQUFILENBQVUsQ0FBVixNQUFpQixHQUF6RSxDQUFKLEVBQW1GO0FBQy9FZSxpQkFBS1gsZ0JBQWdCVyxFQUFoQixFQUFvQjVELFFBQXBCLENBQUw7QUFDSDtBQUNEQSxpQkFBU3NDLGdCQUFULEdBQTRCLEtBQTVCOztBQUVBLGVBQU9zQixLQUFLNUQsU0FBU21DLE9BQXJCO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVNxQyxhQUFULENBQXVCQyxTQUF2QixFQUFrQ0MsSUFBbEMsRUFBd0M7QUFDcEMsWUFBSUMsY0FBSjtBQUNBLGdCQUFRRCxJQUFSO0FBQ0ksaUJBQUssQ0FBTDtBQUNJO0FBQ0FDLHdCQUFRLHNCQUFSO0FBQ0E7QUFDSixpQkFBSyxDQUFMO0FBQ0k7QUFDQUEsd0JBQVEsd0JBQVI7QUFDQTtBQUNKO0FBQ0k7QUFDQUEsd0JBQVEsSUFBSS9DLE1BQUosY0FBc0I4QyxJQUF0Qix3QkFBUjtBQVhSOztBQWNBO0FBQ0FELG9CQUFZQSxVQUFVM0QsT0FBVixDQUFrQjZELEtBQWxCLEVBQXlCLElBQXpCLENBQVo7QUFDQSxZQUFJRCxTQUFTLENBQWIsRUFBZ0I7QUFDWkQsd0JBQVlBLFVBQVUzRCxPQUFWLENBQWtCLEtBQWxCLEVBQXlCLEVBQXpCLENBQVo7QUFDSDs7QUFFRCxlQUFPMkQsU0FBUDtBQUNIOztBQUVEOzs7Ozs7QUFNQSxhQUFTRyxTQUFULENBQW1CaEIsRUFBbkIsRUFBdUI1RCxRQUF2QixFQUFpQztBQUFFO0FBQy9CNEQsYUFBTUEsT0FBTyxFQUFSLEdBQWMsR0FBZCxHQUFvQkEsR0FBR2hHLFFBQUgsRUFBekI7QUFDQSxZQUFJb0MsU0FBUzZFLE1BQVQsS0FBb0IsS0FBcEIsSUFBNkI3RSxTQUFTNkUsTUFBVCxLQUFvQixLQUFqRCxJQUEwRDdFLFNBQVM2RSxNQUFULEtBQW9CLEtBQTlFLElBQXVGN0UsU0FBUzZFLE1BQVQsS0FBb0IsS0FBL0csRUFBc0g7QUFDbEgsb0JBQVE3RSxTQUFTNkUsTUFBakI7QUFDSSxxQkFBSyxLQUFMO0FBQ0lqQix5QkFBSyxDQUFDbEQsS0FBS29FLEtBQUwsQ0FBV2xCLEtBQUssRUFBaEIsSUFBc0IsRUFBdkIsRUFBMkJoRyxRQUEzQixFQUFMO0FBQ0E7QUFDSixxQkFBSyxLQUFMO0FBQ0lnRyx5QkFBSyxDQUFDbEQsS0FBS3FFLElBQUwsQ0FBVW5CLEtBQUssRUFBZixJQUFxQixFQUF0QixFQUEwQmhHLFFBQTFCLEVBQUw7QUFDQTtBQUNKO0FBQ0lnRyx5QkFBSyxDQUFDbEQsS0FBS3NFLEtBQUwsQ0FBV3BCLEtBQUssRUFBaEIsSUFBc0IsRUFBdkIsRUFBMkJoRyxRQUEzQixFQUFMO0FBUlI7O0FBV0EsZ0JBQUlxSCxlQUFKO0FBQ0EsZ0JBQUksQ0FBQzdILFNBQVN3RyxFQUFULEVBQWEsR0FBYixDQUFMLEVBQXdCO0FBQ3BCcUIseUJBQVNyQixLQUFLLEtBQWQ7QUFDSCxhQUZELE1BRU8sSUFBSUEsR0FBR3pGLE1BQUgsR0FBWXlGLEdBQUd0RyxPQUFILENBQVcsR0FBWCxDQUFaLEdBQThCLENBQWxDLEVBQXFDO0FBQ3hDMkgseUJBQVNyQixLQUFLLEdBQWQ7QUFDSCxhQUZNLE1BRUE7QUFDSHFCLHlCQUFTckIsRUFBVDtBQUNIO0FBQ0QsbUJBQU9xQixNQUFQO0FBQ0g7O0FBRUQsWUFBSVIsWUFBWSxFQUFoQjtBQUNBLFlBQUl2TSxJQUFJLENBQVI7QUFDQSxZQUFJd0ssUUFBUSxFQUFaO0FBQ0EsWUFBSWdDLGFBQUo7O0FBRUE7QUFDQSxZQUFJMUUsU0FBU2tGLElBQWIsRUFBbUI7QUFDZlIsbUJBQU8xRSxTQUFTaUIsSUFBaEI7QUFDSCxTQUZELE1BRU87QUFDSHlELG1CQUFPLENBQVA7QUFDSDs7QUFFRDtBQUNBLFlBQUlkLEdBQUdmLE1BQUgsQ0FBVSxDQUFWLE1BQWlCLEdBQXJCLEVBQTBCO0FBQ3RCSCxvQkFBUSxHQUFSOztBQUVBO0FBQ0FrQixpQkFBS0EsR0FBRzlDLE9BQUgsQ0FBVyxHQUFYLEVBQWdCLEVBQWhCLENBQUw7QUFDSDs7QUFFRDtBQUNBLFlBQUksQ0FBQzhDLEdBQUdyQixLQUFILENBQVMsS0FBVCxDQUFMLEVBQXNCO0FBQ2xCcUIsaUJBQUssTUFBTUEsRUFBWDtBQUNIOztBQUVEO0FBQ0EsWUFBSWxCLFVBQVUsR0FBVixJQUFpQnZCLE9BQU95QyxFQUFQLE1BQWUsQ0FBcEMsRUFBdUM7QUFDbkNsQixvQkFBUSxFQUFSO0FBQ0g7O0FBRUQ7QUFDQSxZQUFLdkIsT0FBT3lDLEVBQVAsSUFBYSxDQUFiLElBQWtCNUQsU0FBU3lDLEtBQVQsS0FBbUIsTUFBdEMsSUFBa0RtQixHQUFHekYsTUFBSCxHQUFZLENBQVosSUFBaUI2QixTQUFTeUMsS0FBVCxLQUFtQixPQUExRixFQUFvRztBQUNoR21CLGlCQUFLQSxHQUFHOUMsT0FBSCxDQUFXLFNBQVgsRUFBc0IsSUFBdEIsQ0FBTDtBQUNIOztBQUVELFlBQU1xRSxPQUFPdkIsR0FBR04sV0FBSCxDQUFlLEdBQWYsQ0FBYjs7QUFFQTtBQUNBLFlBQU04QixRQUFTRCxTQUFTLENBQUMsQ0FBWCxHQUFnQnZCLEdBQUd6RixNQUFILEdBQVksQ0FBNUIsR0FBZ0NnSCxJQUE5Qzs7QUFFQTtBQUNBO0FBQ0EsWUFBSUUsT0FBUXpCLEdBQUd6RixNQUFILEdBQVksQ0FBYixHQUFrQmlILEtBQTdCO0FBQ0EsWUFBSUMsUUFBUXJGLFNBQVNpQixJQUFyQixFQUEyQjtBQUN2QjtBQUNBd0Qsd0JBQVliLEVBQVo7QUFDQSxnQkFBSXlCLE9BQU9YLElBQVgsRUFBaUI7QUFDYixvQkFBSVMsU0FBUyxDQUFDLENBQWQsRUFBaUI7QUFDYlYsaUNBQWF6RSxTQUFTdUIsSUFBdEI7QUFDSDs7QUFFRCxvQkFBSStELFFBQVEsUUFBWjtBQUNBLHVCQUFPRCxPQUFPWCxJQUFkLEVBQW9CO0FBQ2hCWSw0QkFBUUEsTUFBTWhCLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUJJLE9BQU9XLElBQTFCLENBQVI7QUFDQVosaUNBQWFhLEtBQWI7QUFDQUQsNEJBQVFDLE1BQU1uSCxNQUFkO0FBQ0g7QUFDSixhQVhELE1BV08sSUFBSWtILE9BQU9YLElBQVgsRUFBaUI7QUFDcEJELDRCQUFZRCxjQUFjQyxTQUFkLEVBQXlCQyxJQUF6QixDQUFaO0FBQ0gsYUFGTSxNQUVBLElBQUlXLFNBQVMsQ0FBVCxJQUFjWCxTQUFTLENBQTNCLEVBQThCO0FBQ2pDRCw0QkFBWUEsVUFBVTNELE9BQVYsQ0FBa0IsS0FBbEIsRUFBeUIsRUFBekIsQ0FBWjtBQUNIOztBQUVELG1CQUFRSyxPQUFPc0QsU0FBUCxNQUFzQixDQUF2QixHQUE0QkEsU0FBNUIsR0FBd0MvQixRQUFRK0IsU0FBdkQ7QUFDSDs7QUFFRDtBQUNBLFlBQU1jLFVBQVVKLE9BQU9uRixTQUFTaUIsSUFBaEMsQ0E1RjZCLENBNEZTO0FBQ3RDLFlBQU11RSxTQUFTckUsT0FBT3lDLEdBQUdmLE1BQUgsQ0FBVTBDLFVBQVUsQ0FBcEIsQ0FBUCxDQUFmO0FBQ0EsWUFBTUUsTUFBTzdCLEdBQUdmLE1BQUgsQ0FBVTBDLE9BQVYsTUFBdUIsR0FBeEIsR0FBZ0MzQixHQUFHZixNQUFILENBQVUwQyxVQUFVLENBQXBCLElBQXlCLENBQXpELEdBQStEM0IsR0FBR2YsTUFBSCxDQUFVMEMsT0FBVixJQUFxQixDQUFoRztBQUNBLFlBQUlHLFVBQVU5QixHQUFHVSxTQUFILENBQWEsQ0FBYixFQUFnQmlCLFVBQVUsQ0FBMUIsRUFBNkJ2SCxLQUE3QixDQUFtQyxFQUFuQyxDQUFkO0FBQ0EsWUFBS3dILFNBQVMsQ0FBVCxJQUFjeEYsU0FBUzZFLE1BQVQsS0FBb0IsR0FBbkMsSUFBNEQ7QUFDM0RXLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxFQURwRCxJQUM0RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxHQUZwRCxJQUU0RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBSG5DLElBRzREO0FBQzVEO0FBQ0NXLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxFQUxwRCxJQUs0RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxHQU5wRCxJQU00RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBUG5DLElBTzREO0FBQzNEVyxtQkFBVyxDQUFYLElBQWdCeEYsU0FBUzZFLE1BQVQsS0FBb0IsR0FBcEMsSUFBMkNZLFFBQVEsQ0FScEQsSUFRNEQ7QUFDM0RELGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxFQVRwRCxJQVM0RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBQWxDLElBQXlDbkMsVUFBVSxHQVZwRCxJQVU0RDtBQUMzRDhDLGlCQUFTLENBQVQsSUFBY3hGLFNBQVM2RSxNQUFULEtBQW9CLEdBWHZDLEVBVzZDO0FBQW1CO0FBQzVEO0FBQ0EsaUJBQUszTSxJQUFLd04sUUFBUXZILE1BQVIsR0FBaUIsQ0FBM0IsRUFBK0JqRyxLQUFLLENBQXBDLEVBQXVDQSxLQUFLLENBQTVDLEVBQStDO0FBQzNDLG9CQUFJd04sUUFBUXhOLENBQVIsTUFBZSxHQUFuQixFQUF3QjtBQUNwQndOLDRCQUFReE4sQ0FBUixJQUFhLENBQUN3TixRQUFReE4sQ0FBUixDQUFELEdBQWMsQ0FBM0I7QUFDQSx3QkFBSXdOLFFBQVF4TixDQUFSLElBQWEsRUFBakIsRUFBcUI7QUFDakI7QUFDSDtBQUNELHdCQUFJQSxJQUFJLENBQVIsRUFBVztBQUNQd04sZ0NBQVF4TixDQUFSLElBQWEsR0FBYjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0F3TixrQkFBVUEsUUFBUTVDLEtBQVIsQ0FBYyxDQUFkLEVBQWlCeUMsVUFBVSxDQUEzQixDQUFWOztBQUVBO0FBQ0FkLG9CQUFZRCxjQUFja0IsUUFBUWxELElBQVIsQ0FBYSxFQUFiLENBQWQsRUFBZ0NrQyxJQUFoQyxDQUFaOztBQUVBLGVBQVF2RCxPQUFPc0QsU0FBUCxNQUFzQixDQUF2QixHQUE0QkEsU0FBNUIsR0FBd0MvQixRQUFRK0IsU0FBdkQ7QUFDSDs7QUFFRDs7Ozs7Ozs7QUFRQSxhQUFTa0IsZUFBVCxDQUF5Qi9NLENBQXpCLEVBQTRCb0gsUUFBNUIsRUFBc0M0RixLQUF0QyxFQUE2QztBQUN6QyxZQUFNckUsT0FBT3ZCLFNBQVN1QixJQUF0QjtBQUNBLFlBQU1OLE9BQU9qQixTQUFTaUIsSUFBdEI7QUFDQXJJLFlBQUtnTixVQUFVLE9BQVgsR0FBc0JoQixVQUFVaE0sQ0FBVixFQUFhb0gsUUFBYixDQUF0QixHQUErQ3BILENBQW5EO0FBQ0EsWUFBSTJJLFFBQVFOLElBQVosRUFBa0I7QUFBQSw0QkFDcUJySSxFQUFFb0YsS0FBRixDQUFRdUQsSUFBUixDQURyQjtBQUFBO0FBQUEsZ0JBQ1BvQixXQURPO0FBQUEsZ0JBQ00xRSxXQUROOztBQUdkOzs7QUFDQSxnQkFBSUEsZUFBZUEsWUFBWUUsTUFBWixHQUFxQjhDLElBQXhDLEVBQThDO0FBQzFDLG9CQUFJQSxPQUFPLENBQVgsRUFBYztBQUNWLHdCQUFNNEUsc0JBQXNCNUgsWUFBWXFHLFNBQVosQ0FBc0IsQ0FBdEIsRUFBeUJyRCxJQUF6QixDQUE1QjtBQUNBckksNkJBQU8rSixXQUFQLEdBQXFCcEIsSUFBckIsR0FBNEJzRSxtQkFBNUI7QUFDSCxpQkFIRCxNQUdPO0FBQ0hqTix3QkFBSStKLFdBQUo7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBTy9KLENBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBU2tOLFFBQVQsQ0FBa0J2TixDQUFsQixFQUFxQjtBQUNqQixZQUFNVSxJQUFJLEVBQVY7QUFDQSxZQUFJbkIsVUFBSjtBQUNBLFlBQUlJLFVBQUo7QUFDQSxZQUFJNk4sV0FBSjtBQUNBLFlBQUk1TixVQUFKOztBQUVBO0FBQ0EsWUFBSUksTUFBTSxDQUFOLElBQVcsSUFBSUEsQ0FBSixHQUFRLENBQXZCLEVBQTBCO0FBQ3RCQSxnQkFBSSxJQUFKO0FBQ0g7O0FBRUQ7QUFDQUEsWUFBSUEsRUFBRXFGLFFBQUYsRUFBSjtBQUNBLFlBQUlyRixFQUFFc0ssTUFBRixDQUFTLENBQVQsTUFBZ0IsR0FBcEIsRUFBeUI7QUFDckJ0SyxnQkFBSUEsRUFBRXVLLEtBQUYsQ0FBUSxDQUFSLENBQUo7QUFDQTdKLGNBQUVMLENBQUYsR0FBTSxDQUFDLENBQVA7QUFDSCxTQUhELE1BR087QUFDSEssY0FBRUwsQ0FBRixHQUFNLENBQU47QUFDSDs7QUFFRDtBQUNBZCxZQUFJUyxFQUFFK0UsT0FBRixDQUFVLEdBQVYsQ0FBSjtBQUNBLFlBQUl4RixJQUFJLENBQUMsQ0FBVCxFQUFZO0FBQ1JTLGdCQUFJQSxFQUFFdUksT0FBRixDQUFVLEdBQVYsRUFBZSxFQUFmLENBQUo7QUFDSDs7QUFFRDtBQUNBLFlBQUloSixJQUFJLENBQVIsRUFBVztBQUNQO0FBQ0FBLGdCQUFJUyxFQUFFNEYsTUFBTjtBQUNIOztBQUVEO0FBQ0FqRyxZQUFLSyxFQUFFeU4sTUFBRixDQUFTLFFBQVQsTUFBdUIsQ0FBQyxDQUF6QixHQUE4QnpOLEVBQUU0RixNQUFoQyxHQUF5QzVGLEVBQUV5TixNQUFGLENBQVMsUUFBVCxDQUE3QztBQUNBRCxhQUFLeE4sRUFBRTRGLE1BQVA7QUFDQSxZQUFJakcsTUFBTTZOLEVBQVYsRUFBYztBQUNWO0FBQ0E5TSxjQUFFbkIsQ0FBRixHQUFNLENBQU47QUFDQW1CLGNBQUVyQixDQUFGLEdBQU0sQ0FBQyxDQUFELENBQU47QUFDSCxTQUpELE1BSU87QUFDSDtBQUNBLGlCQUFLTyxJQUFJNE4sS0FBSyxDQUFkLEVBQWlCeE4sRUFBRXNLLE1BQUYsQ0FBUzFLLENBQVQsTUFBZ0IsR0FBakMsRUFBc0NBLEtBQUssQ0FBM0MsRUFBOEM7QUFDMUM0TixzQkFBTSxDQUFOO0FBQ0g7QUFDREEsa0JBQU0sQ0FBTjs7QUFFQTtBQUNBOU0sY0FBRW5CLENBQUYsR0FBTUEsSUFBSUksQ0FBSixHQUFRLENBQWQ7QUFDQWUsY0FBRXJCLENBQUYsR0FBTSxFQUFOOztBQUVBO0FBQ0EsaUJBQUtFLElBQUksQ0FBVCxFQUFZSSxLQUFLNk4sRUFBakIsRUFBcUI3TixLQUFLLENBQTFCLEVBQTZCO0FBQ3pCZSxrQkFBRXJCLENBQUYsQ0FBSUUsQ0FBSixJQUFTLENBQUNTLEVBQUVzSyxNQUFGLENBQVMzSyxDQUFULENBQVY7QUFDQUoscUJBQUssQ0FBTDtBQUNIO0FBQ0o7O0FBRUQsZUFBT21CLENBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsYUFBU2dOLFVBQVQsQ0FBb0IvTSxDQUFwQixFQUF1QkQsQ0FBdkIsRUFBMEI7QUFDdEIsWUFBTWlOLEtBQUtqTixFQUFFckIsQ0FBYjtBQUNBLFlBQU11TyxLQUFLak4sRUFBRXRCLENBQWI7QUFDQSxZQUFJTSxJQUFJZSxFQUFFTCxDQUFWO0FBQ0EsWUFBSVQsSUFBSWUsRUFBRU4sQ0FBVjtBQUNBLFlBQUlSLElBQUlhLEVBQUVuQixDQUFWO0FBQ0EsWUFBSU8sSUFBSWEsRUFBRXBCLENBQVY7O0FBRUE7QUFDQSxZQUFJLENBQUNvTyxHQUFHLENBQUgsQ0FBRCxJQUFVLENBQUNDLEdBQUcsQ0FBSCxDQUFmLEVBQXNCO0FBQ2xCLGdCQUFJbEIsZ0JBQUo7QUFDQSxnQkFBSSxDQUFDaUIsR0FBRyxDQUFILENBQUwsRUFBWTtBQUNSakIsMEJBQVMsQ0FBQ2tCLEdBQUcsQ0FBSCxDQUFELEdBQU8sQ0FBUCxHQUFTLENBQUNoTyxDQUFuQjtBQUNILGFBRkQsTUFFTztBQUNIOE0sMEJBQVMvTSxDQUFUO0FBQ0g7QUFDRCxtQkFBTytNLE9BQVA7QUFDSDs7QUFFRDtBQUNBLFlBQUkvTSxNQUFNQyxDQUFWLEVBQWE7QUFDVCxtQkFBT0QsQ0FBUDtBQUNIO0FBQ0QsWUFBTWtPLE9BQU9sTyxJQUFJLENBQWpCOztBQUVBO0FBQ0EsWUFBSUUsTUFBTUMsQ0FBVixFQUFhO0FBQ1QsbUJBQVFELElBQUlDLENBQUosR0FBUStOLElBQVQsR0FBZSxDQUFmLEdBQWlCLENBQUMsQ0FBekI7QUFDSDtBQUNEbE8sWUFBSSxDQUFDLENBQUw7QUFDQUUsWUFBSThOLEdBQUcvSCxNQUFQO0FBQ0E5RixZQUFJOE4sR0FBR2hJLE1BQVA7QUFDQWhHLFlBQUtDLElBQUlDLENBQUwsR0FBVUQsQ0FBVixHQUFjQyxDQUFsQjs7QUFFQTtBQUNBLGFBQUtILEtBQUssQ0FBVixFQUFhQSxJQUFJQyxDQUFqQixFQUFvQkQsS0FBSyxDQUF6QixFQUE0QjtBQUN4QixnQkFBSWdPLEdBQUdoTyxDQUFILE1BQVVpTyxHQUFHak8sQ0FBSCxDQUFkLEVBQXFCO0FBQ2pCLHVCQUFRZ08sR0FBR2hPLENBQUgsSUFBUWlPLEdBQUdqTyxDQUFILENBQVIsR0FBZ0JrTyxJQUFqQixHQUF1QixDQUF2QixHQUF5QixDQUFDLENBQWpDO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFlBQUluQixlQUFKO0FBQ0EsWUFBSTdNLE1BQU1DLENBQVYsRUFBYTtBQUNUNE0scUJBQVMsQ0FBVDtBQUNILFNBRkQsTUFFTztBQUNIQSxxQkFBVTdNLElBQUlDLENBQUosR0FBUStOLElBQVQsR0FBZSxDQUFmLEdBQWlCLENBQUMsQ0FBM0I7QUFDSDs7QUFFRCxlQUFPbkIsTUFBUDtBQUNIOztBQUVEOzs7OztBQUtBLGFBQVNvQixTQUFULENBQW1Cek4sQ0FBbkIsRUFBc0JvSCxRQUF0QixFQUFnQztBQUM1QnBILFlBQUlBLEVBQUVnRixRQUFGLEVBQUo7QUFDQWhGLFlBQUlBLEVBQUVrSSxPQUFGLENBQVUsR0FBVixFQUFlLEdBQWYsQ0FBSjtBQUNBLFlBQU13RixXQUFXUixTQUFTOUYsU0FBU00sSUFBbEIsQ0FBakI7QUFDQSxZQUFNaUcsV0FBV1QsU0FBUzlGLFNBQVNPLElBQWxCLENBQWpCO0FBQ0EsWUFBTWlHLFdBQVdWLFNBQVNsTixDQUFULENBQWpCOztBQUVBLFlBQUlxTSxlQUFKO0FBQ0EsZ0JBQVFqRixTQUFTeUcsT0FBakI7QUFDSSxpQkFBSyxPQUFMO0FBQ0l4Qix5QkFBUyxDQUFDZ0IsV0FBV0ssUUFBWCxFQUFxQkUsUUFBckIsSUFBaUMsQ0FBQyxDQUFuQyxFQUFzQyxJQUF0QyxDQUFUO0FBQ0E7QUFDSixpQkFBSyxTQUFMO0FBQ0l2Qix5QkFBUyxDQUFDLElBQUQsRUFBT2dCLFdBQVdNLFFBQVgsRUFBcUJDLFFBQXJCLElBQWlDLENBQXhDLENBQVQ7QUFDQTtBQUNKLGlCQUFLLFFBQUw7QUFDSXZCLHlCQUFTLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBVDtBQUNBO0FBQ0o7QUFDSUEseUJBQVMsQ0FBQ2dCLFdBQVdLLFFBQVgsRUFBcUJFLFFBQXJCLElBQWlDLENBQUMsQ0FBbkMsRUFBc0NQLFdBQVdNLFFBQVgsRUFBcUJDLFFBQXJCLElBQWlDLENBQXZFLENBQVQ7QUFYUjs7QUFjQSxlQUFPdkIsTUFBUDtBQUNIOztBQUVEOzs7QUFHQSxhQUFTeUIsT0FBVCxDQUFpQnpKLEdBQWpCLEVBQXNCO0FBQ2xCLFlBQUksT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLGVBQWVWLE1BQTlDLEVBQXNEO0FBQ2xEVSxrQkFBTUEsSUFBSTZELE9BQUosQ0FBWSxLQUFaLEVBQW1CLEtBQW5CLEVBQTBCQSxPQUExQixDQUFrQyxJQUFsQyxFQUF3QyxLQUF4QyxDQUFOO0FBQ0E3RCxrQkFBTSxNQUFNQSxJQUFJNkQsT0FBSixDQUFZLFNBQVosRUFBdUIsTUFBdkIsQ0FBWjtBQUNBO0FBQ0E7QUFDSDs7QUFFRCxlQUFPYixFQUFFaEQsR0FBRixDQUFQO0FBQ0g7O0FBRUQ7Ozs7QUFJQSxhQUFTMEosU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI1RyxRQUExQixFQUFvQzZHLE1BQXBDLEVBQTRDO0FBQ3hDLFlBQUlDLE9BQU9GLE1BQU1FLElBQU4sQ0FBVyxhQUFYLENBQVg7QUFDQSxZQUFJLENBQUNBLElBQUwsRUFBVztBQUNQQSxtQkFBTyxFQUFQO0FBQ0FGLGtCQUFNRSxJQUFOLENBQVcsYUFBWCxFQUEwQkEsSUFBMUI7QUFDSDtBQUNELFlBQUlDLFNBQVNELEtBQUtDLE1BQWxCO0FBQ0EsWUFBSzVLLFlBQVk0SyxNQUFaLEtBQXVCL0csUUFBeEIsSUFBcUM2RyxNQUF6QyxFQUFpRDtBQUM3Q0UscUJBQVMsSUFBSUMsaUJBQUosQ0FBc0JKLE1BQU1LLEdBQU4sQ0FBVSxDQUFWLENBQXRCLEVBQW9DakgsUUFBcEMsQ0FBVDtBQUNBOEcsaUJBQUtDLE1BQUwsR0FBY0EsTUFBZDtBQUNIOztBQUVELGVBQU9BLE1BQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBU0csb0JBQVQsQ0FBOEJsSCxRQUE5QixFQUF3QztBQUNwQ0EsaUJBQVNrQixJQUFULEdBQW9CbEIsU0FBU2lCLElBQTdCO0FBQ0FqQixpQkFBU21ILElBQVQsR0FBb0JuSCxTQUFTa0YsSUFBN0I7QUFDQWxGLGlCQUFTb0gsUUFBVCxHQUFvQnBILFNBQVNrRCxRQUE3QjtBQUNBbEQsaUJBQVNxSCxJQUFULEdBQW9CckgsU0FBU3dCLElBQTdCO0FBQ0F4QixpQkFBU3NILEtBQVQsR0FBb0J0SCxTQUFTa0MsS0FBN0I7QUFDQWxDLGlCQUFTdUgsT0FBVCxHQUFvQnZILFNBQVNtQyxPQUE3QjtBQUNIOztBQUVEOzs7O0FBSUEsYUFBU3FGLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCO0FBQ3RCLFlBQU1DLFNBQVNELE9BQU8sR0FBdEI7QUFDQSxZQUFNRSxLQUFLakosU0FBU2tKLE1BQVQsQ0FBZ0I1SixLQUFoQixDQUFzQixHQUF0QixDQUFYO0FBQ0EsWUFBSXBHLElBQUksRUFBUjtBQUNBLGFBQUssSUFBSU0sSUFBSSxDQUFiLEVBQWdCQSxJQUFJeVAsR0FBR3hKLE1BQXZCLEVBQStCakcsS0FBSyxDQUFwQyxFQUF1QztBQUNuQ04sZ0JBQUkrUCxHQUFHelAsQ0FBSCxDQUFKO0FBQ0EsbUJBQU9OLEVBQUVpTCxNQUFGLENBQVMsQ0FBVCxNQUFnQixHQUF2QixFQUE0QjtBQUN4QmpMLG9CQUFJQSxFQUFFME0sU0FBRixDQUFZLENBQVosRUFBZTFNLEVBQUV1RyxNQUFqQixDQUFKO0FBQ0g7QUFDRCxnQkFBSXZHLEVBQUUwRixPQUFGLENBQVVvSyxNQUFWLE1BQXNCLENBQTFCLEVBQTZCO0FBQ3pCLHVCQUFPOVAsRUFBRTBNLFNBQUYsQ0FBWW9ELE9BQU92SixNQUFuQixFQUEyQnZHLEVBQUV1RyxNQUE3QixDQUFQO0FBQ0g7QUFDSjs7QUFFRCxlQUFPLElBQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBUzBKLFdBQVQsR0FBdUI7QUFDbkIsWUFBTUMsTUFBTSxXQUFaO0FBQ0EsWUFBSTtBQUNBQywyQkFBZUMsT0FBZixDQUF1QkYsR0FBdkIsRUFBNEJBLEdBQTVCO0FBQ0FDLDJCQUFlRSxVQUFmLENBQTBCSCxHQUExQjtBQUNBLG1CQUFPLElBQVA7QUFDSCxTQUpELENBSUUsT0FBT2hRLENBQVAsRUFBVTtBQUNSLG1CQUFPLEtBQVA7QUFDSDtBQUNKOztBQUVEOzs7QUFHQSxhQUFTb1EsUUFBVCxDQUFrQm5JLEtBQWxCLEVBQXlCQyxRQUF6QixFQUFtQ21JLElBQW5DLEVBQXlDO0FBQ3JDLFlBQUluSSxTQUFTb0ksS0FBYixFQUFvQjtBQUNoQixnQkFBTUMsYUFBY3RJLE1BQU0sQ0FBTixFQUFTMEgsSUFBVCxLQUFrQixFQUFsQixJQUF3QixDQUFDdEwsWUFBWTRELE1BQU0sQ0FBTixFQUFTMEgsSUFBckIsQ0FBMUIsYUFBK0RhLG1CQUFtQnZJLE1BQU0sQ0FBTixFQUFTMEgsSUFBNUIsQ0FBL0QsYUFBNEcxSCxNQUFNLENBQU4sRUFBU3dJLEVBQXhJO0FBQ0EsZ0JBQUlDLGFBQUo7QUFDQSxnQkFBSUMsZ0JBQUo7O0FBRUE7QUFDQSxnQkFBSVosa0JBQWtCLEtBQXRCLEVBQTZCO0FBQ3pCLHdCQUFRTSxJQUFSO0FBQ0kseUJBQUssS0FBTDtBQUNJekosaUNBQVNrSixNQUFULEdBQXFCUyxVQUFyQixTQUFtQ3JJLFNBQVN1RSxRQUE1QztBQUNBO0FBQ0oseUJBQUssTUFBTDtBQUNJaUUsK0JBQU8sSUFBSUUsSUFBSixFQUFQO0FBQ0FGLDZCQUFLRyxPQUFMLENBQWFILEtBQUtJLE9BQUwsS0FBa0IsQ0FBQyxDQUFELEdBQUssRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFmLEdBQW9CLElBQW5EO0FBQ0FILGtDQUFVLGVBQWVELEtBQUtLLFdBQUwsRUFBekIsQ0FISixDQUdpRDtBQUM3Q25LLGlDQUFTa0osTUFBVCxHQUFxQlMsVUFBckIsZUFBdUNJLE9BQXZDO0FBQ0E7QUFDSix5QkFBSyxLQUFMO0FBQ0ksK0JBQU9qQixXQUFXYSxVQUFYLENBQVA7QUFYUjtBQWFILGFBZEQsTUFjTztBQUNILHdCQUFRRixJQUFSO0FBQ0kseUJBQUssS0FBTDtBQUNJSix1Q0FBZUMsT0FBZixDQUF1QkssVUFBdkIsRUFBbUNySSxTQUFTdUUsUUFBNUM7QUFDQTtBQUNKLHlCQUFLLE1BQUw7QUFDSXdELHVDQUFlRSxVQUFmLENBQTBCSSxVQUExQjtBQUNBO0FBQ0oseUJBQUssS0FBTDtBQUNJLCtCQUFPTixlQUFlZSxPQUFmLENBQXVCVCxVQUF2QixDQUFQO0FBUlI7QUFVSDtBQUNKO0FBQ0o7O0FBRUQ7OztBQUdBLGFBQVNyQixpQkFBVCxDQUEyQjNJLElBQTNCLEVBQWlDMkIsUUFBakMsRUFBMkM7QUFDdkMsYUFBS0EsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxhQUFLM0IsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsYUFBS3VJLEtBQUwsR0FBYTNHLEVBQUU1QixJQUFGLENBQWI7QUFDQSxhQUFLMEssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQUtDLGFBQUwsR0FBcUJwSSxTQUFTLEtBQUtnRyxLQUFkLEVBQXFCLEtBQUs1RyxRQUExQixDQUFyQjtBQUNBLGFBQUs5RCxLQUFMLEdBQWFtQyxLQUFLbkMsS0FBbEI7QUFDSDs7QUFFRDhLLHNCQUFrQnJKLFNBQWxCLEdBQThCO0FBQzFCc0wsWUFEMEIsZ0JBQ3JCblIsQ0FEcUIsRUFDbEI7QUFDSixpQkFBS29FLEtBQUwsR0FBYSxLQUFLbUMsSUFBTCxDQUFVbkMsS0FBdkI7QUFDQSxpQkFBSzhNLGFBQUwsR0FBcUJwSSxTQUFTLEtBQUtnRyxLQUFkLEVBQXFCLEtBQUs1RyxRQUExQixDQUFyQjtBQUNBLGlCQUFLa0osT0FBTCxHQUFlcFIsRUFBRW9SLE9BQWpCO0FBQ0EsaUJBQUtDLE1BQUwsR0FBY3JSLEVBQUVzUixPQUFoQjtBQUNBLGlCQUFLQyxRQUFMLEdBQWdCdlIsRUFBRXVSLFFBQWxCOztBQUVBO0FBQ0EsaUJBQUsxSyxTQUFMLEdBQWlCUCxvQkFBb0IsS0FBS0MsSUFBekIsQ0FBakI7QUFDQSxnQkFBSXZHLEVBQUV3UixJQUFGLEtBQVcsU0FBWCxJQUF3QnhSLEVBQUV3UixJQUFGLEtBQVcsT0FBdkMsRUFBZ0Q7QUFDNUMscUJBQUtDLE1BQUwsR0FBY3pSLEVBQUVuQyxPQUFoQjtBQUNIO0FBQ0QsaUJBQUs2VCxLQUFMLEdBQWExUixFQUFFMFIsS0FBZjtBQUNBLGlCQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsaUJBQUtWLFNBQUwsR0FBaUIsS0FBakI7QUFDSCxTQWhCeUI7QUFrQjFCVyxvQkFsQjBCLHdCQWtCYjFLLEtBbEJhLEVBa0JORCxHQWxCTSxFQWtCRDRLLE9BbEJDLEVBa0JRO0FBQzlCM0ssb0JBQVEwQixLQUFLQyxHQUFMLENBQVMzQixLQUFULEVBQWdCLENBQWhCLENBQVI7QUFDQUQsa0JBQU0yQixLQUFLa0osR0FBTCxDQUFTN0ssR0FBVCxFQUFjLEtBQUtWLElBQUwsQ0FBVW5DLEtBQVYsQ0FBZ0JpQyxNQUE5QixDQUFOO0FBQ0EsaUJBQUtRLFNBQUwsR0FBaUI7QUFDYkssNEJBRGE7QUFFYkQsd0JBRmE7QUFHYlosd0JBQVFZLE1BQU1DO0FBSEQsYUFBakI7QUFLQSxnQkFBSTdDLFlBQVl3TixPQUFaLEtBQXdCQSxPQUE1QixFQUFxQztBQUNqQ3pLLG9DQUFvQixLQUFLYixJQUF6QixFQUErQlcsS0FBL0IsRUFBc0NELEdBQXRDO0FBQ0g7QUFDSixTQTdCeUI7QUErQjFCOEssbUJBL0IwQix1QkErQmRDLEdBL0JjLEVBK0JUSCxPQS9CUyxFQStCQTtBQUN0QixpQkFBS0QsWUFBTCxDQUFrQkksR0FBbEIsRUFBdUJBLEdBQXZCLEVBQTRCSCxPQUE1QjtBQUNILFNBakN5QjtBQW1DMUJJLHNCQW5DMEIsNEJBbUNUO0FBQ2IsZ0JBQU03TixRQUFRLEtBQUtBLEtBQW5CO0FBQ0EsZ0JBQU04TixPQUFPOU4sTUFBTW9JLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsS0FBSzNGLFNBQUwsQ0FBZUssS0FBbEMsQ0FBYjtBQUNBLGdCQUFNaUwsUUFBUS9OLE1BQU1vSSxTQUFOLENBQWdCLEtBQUszRixTQUFMLENBQWVJLEdBQS9CLEVBQW9DN0MsTUFBTWlDLE1BQTFDLENBQWQ7O0FBRUEsbUJBQU8sQ0FBQzZMLElBQUQsRUFBT0MsS0FBUCxDQUFQO0FBQ0gsU0F6Q3lCO0FBMkMxQkMsNkJBM0MwQixtQ0EyQ0Y7QUFDcEIsZ0JBQU1sQixnQkFBZ0IsS0FBS0EsYUFBM0I7O0FBRG9CLGtDQUVBLEtBQUtlLGNBQUwsRUFGQTtBQUFBO0FBQUEsZ0JBRWZDLElBRmU7QUFBQSxnQkFFVEMsS0FGUzs7QUFHcEJELG1CQUFPL0gsVUFBVStILElBQVYsRUFBZ0IsS0FBS2hCLGFBQXJCLENBQVA7QUFDQWlCLG9CQUFRaEksVUFBVWdJLEtBQVYsRUFBaUIsS0FBS2pCLGFBQXRCLENBQVI7QUFDQSxnQkFBSUEsY0FBYzFHLGdCQUFkLElBQWtDLENBQUNsRixTQUFTNE0sSUFBVCxFQUFlLEdBQWYsQ0FBdkMsRUFBNEQ7QUFDeERBLHVCQUFPLE1BQU1BLElBQWI7QUFDQUMsd0JBQVNBLFVBQVUsR0FBWCxHQUFrQixFQUFsQixHQUF1QkEsS0FBL0I7QUFDSDtBQUNEakIsMEJBQWMxRyxnQkFBZCxHQUFpQyxLQUFqQzs7QUFFQSxtQkFBTyxDQUFDMEgsSUFBRCxFQUFPQyxLQUFQLENBQVA7QUFDSCxTQXZEeUI7OztBQXlEMUI7OztBQUdBRSxzQkE1RDBCLDBCQTREWEgsSUE1RFcsRUE0RExDLEtBNURLLEVBNERFO0FBQ3hCLGdCQUFNakIsZ0JBQWdCLEtBQUtBLGFBQTNCOztBQUVBO0FBQ0FnQixtQkFBTy9ILFVBQVUrSCxJQUFWLEVBQWdCaEIsYUFBaEIsQ0FBUDs7QUFFQTtBQUNBaUIsb0JBQVFoSSxVQUFVZ0ksS0FBVixFQUFpQmpCLGFBQWpCLENBQVI7QUFDQSxnQkFBSUEsY0FBYzFHLGdCQUFkLElBQWtDLENBQUNsRixTQUFTNE0sSUFBVCxFQUFlLEdBQWYsQ0FBdkMsRUFBNEQ7QUFDeERBLHVCQUFPLE1BQU1BLElBQWI7QUFDQWhCLDhCQUFjMUcsZ0JBQWQsR0FBaUMsS0FBakM7QUFDSDtBQUNELGdCQUFJLENBQUMwSCxTQUFTLEVBQVQsSUFBZUEsU0FBU2hCLGNBQWNuSSxJQUF2QyxLQUFnRG1JLGNBQWN2RyxLQUFkLEtBQXdCLE1BQTVFLEVBQW9GO0FBQ2hGLG9CQUFJd0gsUUFBUSxFQUFaLEVBQWdCO0FBQ1pBLDRCQUFRQSxNQUFNbkosT0FBTixDQUFjLFNBQWQsRUFBeUIsSUFBekIsQ0FBUjtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxpQkFBS3NKLFFBQUwsR0FBZ0JKLE9BQU9DLEtBQXZCO0FBQ0EsZ0JBQUlqQixjQUFjekgsSUFBbEIsRUFBd0I7QUFDcEIsb0JBQU1qSixJQUFJLEtBQUs4UixRQUFMLENBQWM3SCxLQUFkLENBQW9CLElBQUlYLE1BQUosT0FBZW9ILGNBQWN0SCxnQkFBN0IsVUFBa0RzSCxjQUFjekgsSUFBaEUsQ0FBcEIsQ0FBVjtBQUNBLG9CQUFJakosQ0FBSixFQUFPO0FBQ0gwUiwyQkFBT0EsS0FBS2xKLE9BQUwsQ0FBYXhJLEVBQUUsQ0FBRixDQUFiLEVBQW1CQSxFQUFFLENBQUYsSUFBTyxHQUExQixDQUFQO0FBQ0EseUJBQUs4UixRQUFMLEdBQWdCSixPQUFPQyxLQUF2QjtBQUNIO0FBQ0o7O0FBRUQsbUJBQU8sQ0FBQ0QsSUFBRCxFQUFPQyxLQUFQLENBQVA7QUFDSCxTQXpGeUI7OztBQTJGMUI7OztBQUdBSSxxQkE5RjBCLHlCQThGWkwsSUE5RlksRUE4Rk5DLEtBOUZNLEVBOEZDSyxNQTlGRCxFQThGUztBQUMvQixnQkFBTXRCLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLGdCQUFNdUIsUUFBUSxLQUFLSixjQUFMLENBQW9CSCxJQUFwQixFQUEwQkMsS0FBMUIsQ0FBZDs7QUFGK0IsNkJBR0o1RCxVQUFVLEtBQUsrRCxRQUFmLEVBQXlCcEIsYUFBekIsQ0FISTtBQUFBO0FBQUEsZ0JBR3hCd0IsT0FId0I7QUFBQSxnQkFHZkMsT0FIZTs7QUFJL0IsZ0JBQUluTSxXQUFXaU0sTUFBTSxDQUFOLEVBQVNwTSxNQUF4QjtBQUNBLGlCQUFLaU0sUUFBTCxHQUFnQkcsTUFBTS9ILElBQU4sQ0FBVyxFQUFYLENBQWhCO0FBQ0EsZ0JBQUlnSSxXQUFXQyxPQUFmLEVBQXdCO0FBQ3BCLHFCQUFLTCxRQUFMLEdBQWdCekUsZ0JBQWdCLEtBQUt5RSxRQUFyQixFQUErQnBCLGFBQS9CLEVBQThDc0IsTUFBOUMsQ0FBaEI7QUFDQSxvQkFBTUksWUFBYXROLFNBQVMsS0FBS2dOLFFBQWQsRUFBd0IsR0FBeEIsQ0FBRCxHQUFpQyxLQUFLQSxRQUFMLENBQWN0SixPQUFkLENBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLENBQWpDLEdBQW1FLEtBQUtzSixRQUExRjtBQUNBLG9CQUFJTSxjQUFjLEVBQWQsSUFBb0JBLGNBQWMxQixjQUFjbkksSUFBcEQsRUFBMEQ7QUFDdERtSSxrQ0FBY3pFLFFBQWQsR0FBeUIsRUFBekI7QUFDSCxpQkFGRCxNQUVPO0FBQ0h5RSxrQ0FBY3pFLFFBQWQsR0FBeUJtRyxTQUF6QjtBQUNIO0FBQ0Qsb0JBQUlwTSxXQUFXLEtBQUs4TCxRQUFMLENBQWNqTSxNQUE3QixFQUFxQztBQUNqQ0csK0JBQVcsS0FBSzhMLFFBQUwsQ0FBY2pNLE1BQXpCO0FBQ0g7QUFDRCxxQkFBS2pDLEtBQUwsR0FBYSxLQUFLa08sUUFBbEI7QUFDQSxxQkFBS1AsV0FBTCxDQUFpQnZMLFFBQWpCLEVBQTJCLEtBQTNCO0FBQ0EsdUJBQU8sSUFBUDtBQUNIO0FBQ0QsZ0JBQUksQ0FBQ2tNLE9BQUwsRUFBYztBQUNWLHFCQUFLNUQsS0FBTCxDQUFXK0QsT0FBWCxDQUFtQix5QkFBbkI7QUFDSCxhQUZELE1BRU8sSUFBSSxDQUFDRixPQUFMLEVBQWM7QUFDakIscUJBQUs3RCxLQUFMLENBQVcrRCxPQUFYLENBQW1CLHlCQUFuQjtBQUNIOztBQUVELG1CQUFPLEtBQVA7QUFDSCxTQTFIeUI7OztBQTRIMUI7Ozs7QUFJQUMsb0JBaEkwQiwwQkFnSVg7QUFDWCxnQkFBTTVCLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLGdCQUFNOUcsUUFBUThHLGNBQWM5RyxLQUE1QjtBQUNBLGdCQUFNN0QsT0FBTyxLQUFLQSxJQUFsQjtBQUNBLGdCQUFJNkQsS0FBSixFQUFXO0FBQ1Asb0JBQU0ySSxXQUFXM0ksTUFBTS9ELE1BQXZCO0FBQ0Esb0JBQUk2SyxjQUFjM0csS0FBZCxLQUF3QixHQUE1QixFQUFpQztBQUM3Qix3QkFBTXlJLFNBQVM5QixjQUFjbkksSUFBZCxJQUFzQnhDLEtBQUtuQyxLQUEzQixJQUFvQ21DLEtBQUtuQyxLQUFMLENBQVcyRyxNQUFYLENBQWtCLENBQWxCLE1BQXlCbUcsY0FBY25JLElBQTFGO0FBQ0EsMkJBQU9pSyxTQUFTLENBQUMsQ0FBRCxFQUFJRCxXQUFXLENBQWYsQ0FBVCxHQUE2QixDQUFDLENBQUQsRUFBSUEsUUFBSixDQUFwQztBQUNIO0FBQ0Qsb0JBQU1FLFdBQVcxTSxLQUFLbkMsS0FBTCxDQUFXaUMsTUFBNUI7QUFDQSx1QkFBTyxDQUFDNE0sV0FBV0YsUUFBWixFQUFzQkUsUUFBdEIsQ0FBUDtBQUNIOztBQUVELG1CQUFPLENBQUMsSUFBRCxFQUFPLENBQUMsQ0FBUixDQUFQO0FBQ0gsU0EvSXlCOzs7QUFpSjFCOzs7O0FBSUFDLDZCQXJKMEIsaUNBcUpKckIsT0FySkksRUFxSks7QUFDM0IsZ0JBQU1pQixlQUFlLEtBQUtBLFlBQUwsRUFBckI7QUFDQSxnQkFBTWpNLFlBQVksS0FBS0EsU0FBdkI7O0FBRUE7QUFDQSxnQkFBSUEsVUFBVUssS0FBVixHQUFrQjRMLGFBQWEsQ0FBYixDQUFsQixJQUFxQ2pNLFVBQVVJLEdBQVYsR0FBZ0I2TCxhQUFhLENBQWIsQ0FBekQsRUFBMEU7QUFDdEU7QUFDQSxvQkFBSSxDQUFDak0sVUFBVUssS0FBVixHQUFrQjRMLGFBQWEsQ0FBYixDQUFsQixJQUFxQ2pNLFVBQVVJLEdBQVYsR0FBZ0I2TCxhQUFhLENBQWIsQ0FBdEQsS0FBMEUsS0FBSzFPLEtBQUwsQ0FBV29JLFNBQVgsQ0FBcUI1RCxLQUFLQyxHQUFMLENBQVNoQyxVQUFVSyxLQUFuQixFQUEwQjRMLGFBQWEsQ0FBYixDQUExQixDQUFyQixFQUFpRWxLLEtBQUtrSixHQUFMLENBQVNqTCxVQUFVSSxHQUFuQixFQUF3QjZMLGFBQWEsQ0FBYixDQUF4QixDQUFqRSxFQUEyR3JJLEtBQTNHLENBQWlILE9BQWpILENBQTlFLEVBQXlNO0FBQ3JNLHdCQUFJNUQsVUFBVUssS0FBVixHQUFrQjRMLGFBQWEsQ0FBYixDQUF0QixFQUF1QztBQUNuQyw2QkFBS2xCLFlBQUwsQ0FBa0IvSyxVQUFVSyxLQUE1QixFQUFtQzRMLGFBQWEsQ0FBYixDQUFuQyxFQUFvRGpCLE9BQXBEO0FBQ0gscUJBRkQsTUFFTztBQUNILDZCQUFLRCxZQUFMLENBQWtCa0IsYUFBYSxDQUFiLENBQWxCLEVBQW1Dak0sVUFBVUksR0FBN0MsRUFBa0Q0SyxPQUFsRDtBQUNIO0FBQ0osaUJBTkQsTUFNTztBQUNIO0FBQ0EseUJBQUtELFlBQUwsQ0FBa0JoSixLQUFLa0osR0FBTCxDQUFTakwsVUFBVUssS0FBbkIsRUFBMEI0TCxhQUFhLENBQWIsQ0FBMUIsQ0FBbEIsRUFBOERsSyxLQUFLQyxHQUFMLENBQVNoQyxVQUFVSSxHQUFuQixFQUF3QjZMLGFBQWEsQ0FBYixDQUF4QixDQUE5RCxFQUF3R2pCLE9BQXhHO0FBQ0g7QUFDSjtBQUNKLFNBdkt5Qjs7O0FBeUsxQjs7O0FBR0FzQixrQkE1SzBCLHdCQTRLYjtBQUNULGdCQUFJLENBQUM5TyxZQUFZLEtBQUsrTyxxQkFBakIsQ0FBTCxFQUE4QztBQUMxQyxvQkFBTUMsV0FBVyxLQUFLRCxxQkFBdEI7O0FBRDBDLHVDQUVwQixLQUFLbkIsY0FBTCxFQUZvQjtBQUFBO0FBQUEsb0JBRW5DQyxJQUZtQztBQUFBLG9CQUU3QkMsS0FGNkI7O0FBSTFDOzs7QUFDQSx1QkFBTyxLQUFLaUIscUJBQVo7QUFDQSxvQkFBTUUsbUJBQW1CcEIsS0FBS3FCLE1BQUwsQ0FBWSxDQUFaLEVBQWVGLFNBQVMsQ0FBVCxFQUFZaE4sTUFBM0IsSUFBcUM4RCxVQUFVK0gsS0FBS3FCLE1BQUwsQ0FBWUYsU0FBUyxDQUFULEVBQVloTixNQUF4QixDQUFWLEVBQTJDLEtBQUs2SyxhQUFoRCxDQUE5RDtBQUNBLG9CQUFJLENBQUMsS0FBS3FCLGFBQUwsQ0FBbUJlLGdCQUFuQixFQUFxQ25CLEtBQXJDLEVBQTRDLE9BQTVDLENBQUwsRUFBMkQ7QUFDdkQseUJBQUsvTixLQUFMLEdBQWFpUCxTQUFTM0ksSUFBVCxDQUFjLEVBQWQsQ0FBYjtBQUNBLHlCQUFLcUgsV0FBTCxDQUFpQnNCLFNBQVMsQ0FBVCxFQUFZaE4sTUFBN0IsRUFBcUMsS0FBckM7QUFDSDtBQUNKO0FBQ0osU0F6THlCOzs7QUEyTDFCOzs7O0FBSUFtTixrQkEvTDBCLHNCQStMZnhULENBL0xlLEVBK0xaO0FBQ1YsZ0JBQU15UixTQUFTLEtBQUtBLE1BQXBCO0FBQ0EsZ0JBQU1DLFFBQVEsS0FBS0EsS0FBbkI7QUFDQSxnQkFBTU4sVUFBVSxLQUFLQSxPQUFyQjtBQUNBLGdCQUFNQyxTQUFTLEtBQUtBLE1BQXBCOztBQUVBO0FBQ0EsZ0JBQU1FLFdBQVcsS0FBS0EsUUFBdEI7QUFDQSxnQkFBSyxDQUFDSCxXQUFXQyxNQUFaLEtBQXVCclIsRUFBRXdSLElBQUYsS0FBVyxPQUFsQyxJQUE2QyxDQUFDbk4sWUFBWSxLQUFLK08scUJBQWpCLENBQS9DLElBQTRGN0IsWUFBWUUsV0FBVzVULFFBQVFtQixNQUEvSCxFQUF3STtBQUNwSSxxQkFBS21VLFVBQUw7QUFDQSx1QkFBTyxLQUFQO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSzFCLFVBQVU1VCxRQUFRMEUsRUFBbEIsSUFBd0JrUCxVQUFVNVQsUUFBUXFGLEdBQTNDLElBQ0N1TyxVQUFVNVQsUUFBUXlELE9BQWxCLElBQTZCbVEsVUFBVTVULFFBQVEwRCxVQURoRCxJQUVDa1EsVUFBVTVULFFBQVFFLEdBQWxCLElBQXlCMFQsU0FBUzVULFFBQVFVLEtBRjNDLElBR0NrVCxTQUFTNVQsUUFBUUMsU0FBakIsS0FDQTRULFVBQVUsQ0FBVixJQUFlQSxVQUFVRCxNQUR6QixDQUhELElBS0FBLFdBQVc1VCxRQUFRc0YsT0FMbkIsSUFNQXNPLFdBQVc1VCxRQUFRdUYsVUFObkIsSUFPQXFPLFdBQVc1VCxRQUFRbUIsTUFQbkIsSUFRQXlTLFdBQVc1VCxRQUFRcUcsT0FSdkIsRUFRZ0M7QUFDNUIsdUJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksQ0FBQ2tOLFdBQVdDLE1BQVosS0FBdUJJLFdBQVc1VCxRQUFRK0IsQ0FBOUMsRUFBaUQ7QUFDN0Msb0JBQUksS0FBS3NJLFFBQUwsQ0FBY3VMLE9BQWxCLEVBQTJCO0FBQ3ZCelQsc0JBQUUwVCxjQUFGO0FBQ0Esd0JBQU1ULFdBQVcsS0FBSzFNLElBQUwsQ0FBVW5DLEtBQVYsQ0FBZ0JpQyxNQUFqQztBQUNBLHdCQUFNME0sV0FBVyxLQUFLN0ssUUFBTCxDQUFja0MsS0FBZCxDQUFvQi9ELE1BQXJDO0FBQ0Esd0JBQU1zTixTQUFVLENBQUNyTyxTQUFTLEtBQUtpQixJQUFMLENBQVVuQyxLQUFuQixFQUEwQixHQUExQixDQUFGLEdBQWtDLENBQWxDLEdBQW9DLENBQW5EO0FBQ0Esd0JBQU13UCxhQUFhLEtBQUsxTCxRQUFMLENBQWNtQyxPQUFkLENBQXNCaEUsTUFBekM7QUFDQSx3QkFBTWtFLFFBQVEsS0FBS3JDLFFBQUwsQ0FBY3FDLEtBQTVCO0FBQ0Esd0JBQU1ELE9BQU8sS0FBS3BDLFFBQUwsQ0FBY29DLElBQTNCOztBQUVBLHdCQUFJcEQsY0FBSjtBQUNBLHdCQUFJcUQsVUFBVSxHQUFkLEVBQW1CO0FBQ2ZyRCxnQ0FBUSxDQUFSO0FBQ0gscUJBRkQsTUFFTztBQUNIQSxnQ0FBU29ELFNBQVMsR0FBVCxJQUFnQnFKLFdBQVcsQ0FBM0IsSUFBZ0NaLFdBQVcsQ0FBNUMsR0FBK0NBLFdBQVcsQ0FBMUQsR0FBNERBLFFBQXBFO0FBQ0g7O0FBRUQsd0JBQUk5TCxZQUFKO0FBQ0Esd0JBQUlzRCxVQUFVLEdBQWQsRUFBbUI7QUFDZnRELDhCQUFNZ00sV0FBV1csVUFBakI7QUFDSCxxQkFGRCxNQUVPO0FBQ0gsZ0NBQVF0SixJQUFSO0FBQ0ksaUNBQUssR0FBTDtBQUNJckQsc0NBQU1nTSxZQUFZVyxhQUFhYixRQUF6QixDQUFOO0FBQ0E7QUFDSixpQ0FBSyxHQUFMO0FBQ0k5TCxzQ0FBTzhMLFdBQVcsQ0FBWixHQUFlRSxZQUFZRixXQUFXWSxNQUFYLEdBQW9CQyxVQUFoQyxDQUFmLEdBQTJEWCxZQUFZRixXQUFXYSxVQUF2QixDQUFqRTtBQUNBO0FBQ0o7QUFDSTNNLHNDQUFNZ00sWUFBWUYsV0FBV2EsVUFBdkIsQ0FBTjtBQVJSO0FBVUg7O0FBRUR4TSx3Q0FBb0IsS0FBS2IsSUFBekIsRUFBK0JXLEtBQS9CLEVBQXNDRCxHQUF0QztBQUNIO0FBQ0QsdUJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksQ0FBQ21LLFdBQVdDLE1BQVosTUFBd0JJLFdBQVc1VCxRQUFRaUMsQ0FBbkIsSUFBd0IyUixXQUFXNVQsUUFBUW9ELENBQTNDLElBQWdEd1EsV0FBVzVULFFBQVFzRCxDQUEzRixDQUFKLEVBQW1HO0FBQy9GLG9CQUFJbkIsRUFBRXdSLElBQUYsS0FBVyxTQUFmLEVBQTBCO0FBQ3RCLHlCQUFLMEIscUJBQUw7QUFDSDs7QUFFRDtBQUNBLG9CQUFJekIsV0FBVzVULFFBQVFvRCxDQUFuQixJQUF3QndRLFdBQVc1VCxRQUFRbUIsTUFBL0MsRUFBdUQ7QUFDbkQsd0JBQUlnQixFQUFFd1IsSUFBRixLQUFXLFNBQVgsSUFBd0J4UixFQUFFd1IsSUFBRixLQUFXLFVBQXZDLEVBQW1EO0FBQy9DLDRCQUFJbk4sWUFBWSxLQUFLK08scUJBQWpCLENBQUosRUFBNkM7QUFDekMsaUNBQUtBLHFCQUFMLEdBQTZCLEtBQUtuQixjQUFMLEVBQTdCO0FBQ0g7QUFDSixxQkFKRCxNQUlPO0FBQ0gsNkJBQUtrQixVQUFMO0FBQ0g7QUFDSjtBQUNELHVCQUFPblQsRUFBRXdSLElBQUYsS0FBVyxTQUFYLElBQXdCeFIsRUFBRXdSLElBQUYsS0FBVyxVQUFuQyxJQUFpREMsV0FBVzVULFFBQVFpQyxDQUEzRTtBQUNIOztBQUVELGdCQUFJc1IsV0FBV0MsTUFBZixFQUF1QjtBQUNuQix1QkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSUksV0FBVzVULFFBQVFlLFNBQW5CLElBQWdDNlMsV0FBVzVULFFBQVFpQixVQUF2RCxFQUFtRTtBQUMvRCxvQkFBTTRLLE9BQU8sS0FBS3dILGFBQUwsQ0FBbUJ4SCxJQUFoQztBQUNBLG9CQUFNRCxPQUFPLEtBQUt5SCxhQUFMLENBQW1CekgsSUFBaEM7QUFDQSxvQkFBTW9LLFlBQVksS0FBS2hOLFNBQUwsQ0FBZUssS0FBakM7QUFDQSxvQkFBTTlDLFFBQVEsS0FBS21DLElBQUwsQ0FBVW5DLEtBQXhCO0FBQ0Esb0JBQUlwRSxFQUFFd1IsSUFBRixLQUFXLFNBQVgsSUFBd0IsQ0FBQyxLQUFLRCxRQUFsQyxFQUE0QztBQUN4Qyx3QkFBSUUsV0FBVzVULFFBQVFlLFNBQW5CLEtBQWlDd0YsTUFBTTJHLE1BQU4sQ0FBYThJLFlBQVksQ0FBekIsTUFBZ0NuSyxJQUFoQyxJQUF3Q3RGLE1BQU0yRyxNQUFOLENBQWE4SSxZQUFZLENBQXpCLE1BQWdDcEssSUFBekcsQ0FBSixFQUFvSDtBQUNoSCw2QkFBS3NJLFdBQUwsQ0FBaUI4QixZQUFZLENBQTdCO0FBQ0gscUJBRkQsTUFFTyxJQUFJcEMsV0FBVzVULFFBQVFpQixVQUFuQixLQUFrQ3NGLE1BQU0yRyxNQUFOLENBQWE4SSxZQUFZLENBQXpCLE1BQWdDbkssSUFBaEMsSUFBd0N0RixNQUFNMkcsTUFBTixDQUFhOEksWUFBWSxDQUF6QixNQUFnQ3BLLElBQTFHLENBQUosRUFBcUg7QUFDeEgsNkJBQUtzSSxXQUFMLENBQWlCOEIsWUFBWSxDQUE3QjtBQUNIO0FBQ0o7QUFDRCx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsbUJBQU9wQyxVQUFVNVQsUUFBUVksUUFBbEIsSUFBOEJnVCxVQUFVNVQsUUFBUWtCLFNBQXZEO0FBQ0gsU0F4U3lCOzs7QUEwUzFCOzs7QUFHQStVLHVCQTdTMEIsaUNBNlNLO0FBQUE7QUFBQSxnQkFBZDVCLElBQWM7QUFBQSxnQkFBUkMsS0FBUTs7QUFDM0IsZ0JBQU1qQixnQkFBZ0IsS0FBS0EsYUFBM0I7QUFDQSxnQkFBSUEsY0FBYzNHLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0IyRyxjQUFjNUcsSUFBZCxLQUF1QixHQUExRCxFQUErRDtBQUMzRCxvQkFBSSxLQUFLbUgsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQlAsa0NBQWM2QyxRQUFkLEdBQXlCQyxRQUFRLEtBQUtuTixTQUFMLENBQWVLLEtBQWYsSUFBd0IsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjN0csT0FBakMsQ0FBeEIsSUFBcUU2RyxjQUFjN0csT0FBZCxLQUEwQixFQUF2RyxDQUF6QjtBQUNBLHdCQUFJLEtBQUtqRyxLQUFMLENBQVcyRyxNQUFYLENBQWtCLEtBQUtsRSxTQUFMLENBQWVLLEtBQWYsR0FBdUIsQ0FBekMsTUFBZ0QsR0FBcEQsRUFBeUQ7QUFDckRnTCwrQkFBT0EsS0FBSzFGLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSCxxQkFGRCxNQUVPLElBQUksS0FBSzNGLFNBQUwsQ0FBZUssS0FBZixJQUF3QixLQUFLOUMsS0FBTCxDQUFXaUMsTUFBWCxHQUFvQjZLLGNBQWM3RyxPQUFkLENBQXNCaEUsTUFBdEUsRUFBOEU7QUFDakY2TCwrQkFBT0EsS0FBSzFGLFNBQUwsQ0FBZSxDQUFmLEVBQWtCMEYsS0FBSzdMLE1BQUwsR0FBYyxDQUFoQyxDQUFQO0FBQ0g7QUFDSixpQkFQRCxNQU9PO0FBQ0g2SyxrQ0FBYzZDLFFBQWQsR0FBeUJDLFFBQVEsS0FBS25OLFNBQUwsQ0FBZUssS0FBZixJQUF3QixLQUFLOUMsS0FBTCxDQUFXb0IsT0FBWCxDQUFtQjBMLGNBQWM3RyxPQUFqQyxDQUF4QixJQUFxRTZHLGNBQWM3RyxPQUFkLEtBQTBCLEVBQXZHLENBQXpCO0FBQ0Esd0JBQUksS0FBS3hELFNBQUwsQ0FBZUssS0FBZixJQUF3QixLQUFLOUMsS0FBTCxDQUFXb0IsT0FBWCxDQUFtQjBMLGNBQWM5RyxLQUFqQyxJQUEwQzhHLGNBQWM5RyxLQUFkLENBQW9CL0QsTUFBMUYsRUFBa0c7QUFDOUY4TCxnQ0FBUUEsTUFBTTNGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIyRixNQUFNOUwsTUFBekIsQ0FBUjtBQUNIO0FBQ0Qsd0JBQUlmLFNBQVM0TSxJQUFULEVBQWUsR0FBZixLQUF1QixLQUFLOU4sS0FBTCxDQUFXMkcsTUFBWCxDQUFrQixLQUFLbEUsU0FBTCxDQUFlSyxLQUFqQyxNQUE0QyxHQUF2RSxFQUE0RTtBQUN4RWdMLCtCQUFPQSxLQUFLMUYsU0FBTCxDQUFlLENBQWYsQ0FBUDtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxnQkFBSTBFLGNBQWMzRyxLQUFkLEtBQXdCLEdBQXhCLElBQStCMkcsY0FBYzVHLElBQWQsS0FBdUIsR0FBMUQsRUFBK0Q7QUFDM0Q0Ryw4QkFBYzZDLFFBQWQsR0FBeUJDLFFBQVEsS0FBS25OLFNBQUwsQ0FBZUssS0FBZixJQUF3QixLQUFLOUMsS0FBTCxDQUFXb0IsT0FBWCxDQUFtQjBMLGNBQWNuSSxJQUFqQyxJQUF5Q21JLGNBQWNuSSxJQUFkLENBQW1CMUMsTUFBNUYsQ0FBekI7QUFDQSxvQkFBSSxLQUFLb0wsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQix3QkFBSSxLQUFLNUssU0FBTCxDQUFlSyxLQUFmLEtBQTBCLEtBQUs5QyxLQUFMLENBQVdvQixPQUFYLENBQW1CMEwsY0FBY25JLElBQWpDLElBQXlDbUksY0FBY25JLElBQWQsQ0FBbUIxQyxNQUF0RixJQUFpR2YsU0FBUyxLQUFLbEIsS0FBZCxFQUFxQjhNLGNBQWNuSSxJQUFuQyxDQUFyRyxFQUErSTtBQUMzSW1KLCtCQUFPQSxLQUFLMUYsU0FBTCxDQUFlLENBQWYsQ0FBUDtBQUNILHFCQUZELE1BRU8sSUFBSTBGLFNBQVMsR0FBVCxLQUFrQixLQUFLckwsU0FBTCxDQUFlSyxLQUFmLElBQXdCLEtBQUs5QyxLQUFMLENBQVdvQixPQUFYLENBQW1CMEwsY0FBY25JLElBQWpDLENBQXpCLElBQW9FLENBQUN6RCxTQUFTLEtBQUtsQixLQUFkLEVBQXFCOE0sY0FBY25JLElBQW5DLENBQXRGLENBQUosRUFBcUk7QUFDeEltSiwrQkFBT0EsS0FBSzFGLFNBQUwsQ0FBZSxDQUFmLEVBQWtCMEYsS0FBSzdMLE1BQUwsR0FBYyxDQUFoQyxDQUFQO0FBQ0g7QUFDSixpQkFORCxNQU1PO0FBQ0gsd0JBQUk2TCxLQUFLLENBQUwsTUFBWSxHQUFoQixFQUFxQjtBQUNqQkMsZ0NBQVFBLE1BQU0zRixTQUFOLENBQWdCLENBQWhCLENBQVI7QUFDSDtBQUNELHdCQUFJLEtBQUszRixTQUFMLENBQWVLLEtBQWYsS0FBeUIsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjbkksSUFBakMsQ0FBekIsSUFBbUV6RCxTQUFTLEtBQUtsQixLQUFkLEVBQXFCOE0sY0FBY25JLElBQW5DLENBQXZFLEVBQWlIO0FBQzdHbUosK0JBQU9BLEtBQUsxRixTQUFMLENBQWUsQ0FBZixDQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUVELGdCQUFJMEUsY0FBYzNHLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0IyRyxjQUFjNUcsSUFBZCxLQUF1QixHQUExRCxFQUErRDtBQUMzRDRHLDhCQUFjNkMsUUFBZCxHQUF5QkMsUUFBUSxLQUFLbk4sU0FBTCxDQUFlSyxLQUFmLElBQXdCLEtBQUs5QyxLQUFMLENBQVdvQixPQUFYLENBQW1CMEwsY0FBY25JLElBQWpDLElBQXlDbUksY0FBY25JLElBQWQsQ0FBbUIxQyxNQUE1RixDQUF6QjtBQUNBLG9CQUFJLEtBQUtvTCxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLHdCQUFJLEtBQUs1SyxTQUFMLENBQWVLLEtBQWYsS0FBMEIsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjbkksSUFBakMsSUFBeUNtSSxjQUFjbkksSUFBZCxDQUFtQjFDLE1BQTFGLEVBQW1HO0FBQy9GNkwsK0JBQU9BLEtBQUsxRixTQUFMLENBQWUsQ0FBZixDQUFQO0FBQ0gscUJBRkQsTUFFTyxJQUFJMEYsU0FBUyxHQUFULElBQWdCLEtBQUtyTCxTQUFMLENBQWVLLEtBQWYsSUFBeUIsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjbkksSUFBakMsSUFBeUNtSSxjQUFjOUcsS0FBZCxDQUFvQi9ELE1BQTFHLEVBQW1IO0FBQ3RINkwsK0JBQU9BLEtBQUsxRixTQUFMLENBQWUsQ0FBZixFQUFrQjBGLEtBQUs3TCxNQUFMLEdBQWMsQ0FBaEMsQ0FBUDtBQUNILHFCQUZNLE1BRUEsSUFBSTZMLFNBQVMsRUFBVCxJQUFlLENBQUM1TSxTQUFTLEtBQUtsQixLQUFkLEVBQXFCOE0sY0FBY25JLElBQW5DLENBQXBCLEVBQThEO0FBQ2pFbUosK0JBQU9BLEtBQUsxRixTQUFMLENBQWUsQ0FBZixFQUFrQjBGLEtBQUs3TCxNQUFMLEdBQWMsQ0FBaEMsQ0FBUDtBQUNIO0FBQ0osaUJBUkQsTUFRTztBQUNINkssa0NBQWM2QyxRQUFkLEdBQXlCQyxRQUFRLEtBQUtuTixTQUFMLENBQWVLLEtBQWYsSUFBd0IsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjOUcsS0FBakMsQ0FBeEIsSUFBbUU4RyxjQUFjOUcsS0FBZCxLQUF3QixFQUFuRyxDQUF6QjtBQUNBLHdCQUFJLEtBQUt2RCxTQUFMLENBQWVLLEtBQWYsS0FBeUIsS0FBSzlDLEtBQUwsQ0FBV29CLE9BQVgsQ0FBbUIwTCxjQUFjbkksSUFBakMsQ0FBN0IsRUFBcUU7QUFDakVtSiwrQkFBT0EsS0FBSzFGLFNBQUwsQ0FBZSxDQUFmLENBQVA7QUFDSDtBQUNEMkYsNEJBQVFBLE1BQU0zRixTQUFOLENBQWdCLENBQWhCLENBQVI7QUFDSDtBQUNKOztBQUVELG1CQUFPLENBQUMwRixJQUFELEVBQU9DLEtBQVAsQ0FBUDtBQUNILFNBeFd5Qjs7O0FBMFcxQjs7OztBQUlBOEIscUJBOVcwQiwyQkE4V1Y7QUFDWixnQkFBTS9DLGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLGdCQUFJLEtBQUtPLE1BQUwsS0FBZ0I1VCxRQUFRQyxTQUF4QixJQUFxQyxLQUFLMlQsTUFBTCxLQUFnQjVULFFBQVFvQixNQUFqRSxFQUF5RTtBQUNyRSxvQkFBSWlULGFBQUo7QUFDQSxvQkFBSUMsY0FBSjtBQUNBLG9CQUFJLENBQUMsS0FBS3RMLFNBQUwsQ0FBZVIsTUFBcEIsRUFBNEI7QUFBQSxnREFDUixLQUFLK0wscUJBQUwsRUFEUTs7QUFBQTs7QUFDdkJGLHdCQUR1QjtBQUNqQkMseUJBRGlCOztBQUV4Qix3QkFBSUQsU0FBUyxFQUFULElBQWVDLFVBQVUsRUFBN0IsRUFBaUM7QUFDN0JqQixzQ0FBY2dELFVBQWQsR0FBMkIsS0FBM0I7QUFDSDtBQUNELHdCQUFJLENBQUVoRCxjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXZELElBQ0k0RyxjQUFjM0csS0FBZCxLQUF3QixHQUF4QixLQUFnQzJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXZCLElBQThCNEcsY0FBYzVHLElBQWQsS0FBdUIsR0FBckYsQ0FETCxLQUVJaEYsU0FBUyxLQUFLbEIsS0FBZCxFQUFxQixHQUFyQixDQUZSLEVBRW1DO0FBQUEsK0NBQ2YsS0FBSzBQLGVBQUwsQ0FBcUIsQ0FBQzVCLElBQUQsRUFBT0MsS0FBUCxDQUFyQixDQURlOztBQUFBOztBQUM5QkQsNEJBRDhCO0FBQ3hCQyw2QkFEd0I7QUFFbEMscUJBSkQsTUFJTztBQUNILDRCQUFJLEtBQUtWLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkJTLG1DQUFPQSxLQUFLMUYsU0FBTCxDQUFlLENBQWYsRUFBa0IwRixLQUFLN0wsTUFBTCxHQUFjLENBQWhDLENBQVA7QUFDSCx5QkFGRCxNQUVPO0FBQ0g4TCxvQ0FBUUEsTUFBTTNGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIyRixNQUFNOUwsTUFBekIsQ0FBUjtBQUNIO0FBQ0o7QUFDRCx5QkFBS2tNLGFBQUwsQ0FBbUJMLElBQW5CLEVBQXlCQyxLQUF6QjtBQUNILGlCQWpCRCxNQWlCTztBQUNILHlCQUFLZSxxQkFBTCxDQUEyQixLQUEzQjs7QUFERyxpREFFYSxLQUFLZCxxQkFBTCxFQUZiOztBQUFBOztBQUVGRix3QkFGRTtBQUVJQyx5QkFGSjs7QUFHSCx5QkFBS0ksYUFBTCxDQUFtQkwsSUFBbkIsRUFBeUJDLEtBQXpCO0FBQ0g7QUFDRCx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQsbUJBQU8sS0FBUDtBQUNILFNBN1l5Qjs7O0FBK1kxQjs7OztBQUlBZ0MsdUJBblowQiw2QkFtWlI7QUFDZCxnQkFBTWpELGdCQUFnQixLQUFLQSxhQUEzQjtBQUNBLGdCQUFNa0QsUUFBUTNQLE9BQU80UCxZQUFQLENBQW9CLEtBQUszQyxLQUF6QixDQUFkOztBQUZjLHlDQUdNLEtBQUtVLHFCQUFMLEVBSE47QUFBQTtBQUFBLGdCQUdURixJQUhTO0FBQUEsZ0JBR0hDLEtBSEc7O0FBSWRqQiwwQkFBY2dELFVBQWQsR0FBMkIsSUFBM0I7O0FBRUE7QUFDQTtBQUNBLGdCQUFJRSxVQUFVbEQsY0FBY3pILElBQXhCLElBQWlDeUgsY0FBYzFILE1BQWQsSUFBd0I0SyxVQUFVbEQsY0FBYzFILE1BQWpGLElBQTZGLENBQUM0SyxVQUFVLEdBQVYsSUFBaUJBLFVBQVUsR0FBNUIsS0FBb0MsS0FBSzNDLE1BQUwsS0FBZ0I1VCxRQUFRd0UsU0FBN0osRUFBeUs7QUFDckssb0JBQUksQ0FBQzZPLGNBQWMvSCxJQUFmLElBQXVCLENBQUMrSCxjQUFjekgsSUFBMUMsRUFBZ0Q7QUFDNUMsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0Esb0JBQUl5SCxjQUFjbkksSUFBZCxJQUFzQnpELFNBQVM2TSxLQUFULEVBQWdCakIsY0FBY25JLElBQTlCLENBQTFCLEVBQStEO0FBQzNELDJCQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLG9CQUFJekQsU0FBUzRNLElBQVQsRUFBZWhCLGNBQWN6SCxJQUE3QixDQUFKLEVBQXdDO0FBQ3BDLDJCQUFPLElBQVA7QUFDSDtBQUNELG9CQUFJMEksTUFBTTNNLE9BQU4sQ0FBYzBMLGNBQWN6SCxJQUE1QixJQUFvQyxDQUF4QyxFQUEyQztBQUN2QywyQkFBTyxJQUFQO0FBQ0g7QUFDRCxvQkFBSTBJLE1BQU0zTSxPQUFOLENBQWMwTCxjQUFjekgsSUFBNUIsTUFBc0MsQ0FBMUMsRUFBNkM7QUFDekMwSSw0QkFBUUEsTUFBTW9CLE1BQU4sQ0FBYSxDQUFiLENBQVI7QUFDSDtBQUNELHFCQUFLaEIsYUFBTCxDQUFtQkwsT0FBT2hCLGNBQWN6SCxJQUF4QyxFQUE4QzBJLEtBQTlDLEVBQXFELElBQXJEO0FBQ0EsdUJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0EsZ0JBQUksQ0FBQ2lDLFVBQVUsR0FBVixJQUFpQkEsVUFBVSxHQUE1QixLQUFvQ2xELGNBQWNuSSxJQUFkLEtBQXVCLEdBQS9ELEVBQW9FO0FBQ2hFLG9CQUFJLENBQUNtSSxhQUFMLEVBQW9CO0FBQ2hCLDJCQUFPLElBQVA7QUFDSDs7QUFFRDtBQUNBLG9CQUFLQSxjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXZELElBQWdFNEcsY0FBYzNHLEtBQWQsS0FBd0IsR0FBeEIsSUFBK0IyRyxjQUFjNUcsSUFBZCxLQUF1QixHQUExSCxFQUFnSTtBQUM1SCx3QkFBSTRILFNBQVMsRUFBVCxJQUFlNU0sU0FBUzZNLEtBQVQsRUFBZ0JqQixjQUFjbkksSUFBOUIsQ0FBbkIsRUFBd0Q7QUFDcERtSiwrQkFBT2hCLGNBQWNuSSxJQUFyQjtBQUNBb0osZ0NBQVFBLE1BQU0zRixTQUFOLENBQWdCLENBQWhCLEVBQW1CMkYsTUFBTTlMLE1BQXpCLENBQVI7QUFDSDs7QUFFRDtBQUNBLHdCQUFJNkwsS0FBS25ILE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLElBQTBCekYsU0FBUzRNLElBQVQsRUFBZWhCLGNBQWNuSSxJQUE3QixDQUE5QixFQUFrRTtBQUM5RG1KLCtCQUFPQSxLQUFLMUYsU0FBTCxDQUFlLENBQWYsRUFBa0IwRixLQUFLN0wsTUFBdkIsQ0FBUDtBQUNILHFCQUZELE1BRU87QUFDSDZMLCtCQUFRa0MsVUFBVSxHQUFYLEdBQWtCbEQsY0FBY25JLElBQWQsR0FBcUJtSixJQUF2QyxHQUE4Q0EsSUFBckQ7QUFDSDtBQUNKLGlCQVpELE1BWU87QUFDSCx3QkFBSUEsU0FBUyxFQUFULElBQWU1TSxTQUFTNk0sS0FBVCxFQUFnQmpCLGNBQWNuSSxJQUE5QixDQUFuQixFQUF3RDtBQUNwRG1KLCtCQUFPaEIsY0FBY25JLElBQXJCO0FBQ0FvSixnQ0FBUUEsTUFBTTNGLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIyRixNQUFNOUwsTUFBekIsQ0FBUjtBQUNIOztBQUVEO0FBQ0Esd0JBQUk2TCxLQUFLbkgsTUFBTCxDQUFZLENBQVosTUFBbUJtRyxjQUFjbkksSUFBckMsRUFBMkM7QUFDdkNtSiwrQkFBT0EsS0FBSzFGLFNBQUwsQ0FBZSxDQUFmLEVBQWtCMEYsS0FBSzdMLE1BQXZCLENBQVA7QUFDSCxxQkFGRCxNQUVPO0FBQ0g2TCwrQkFBUWtDLFVBQVUsR0FBWCxHQUFrQmxELGNBQWNuSSxJQUFkLEdBQXFCbUosSUFBdkMsR0FBOENBLElBQXJEO0FBQ0g7QUFDSjtBQUNELHFCQUFLSyxhQUFMLENBQW1CTCxJQUFuQixFQUF5QkMsS0FBekIsRUFBZ0MsSUFBaEM7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQSxnQkFBSWlDLFNBQVMsR0FBVCxJQUFnQkEsU0FBUyxHQUE3QixFQUFrQztBQUM5QixvQkFBSWxELGNBQWNuSSxJQUFkLElBQXNCbUosU0FBUyxFQUEvQixJQUFxQzVNLFNBQVM2TSxLQUFULEVBQWdCakIsY0FBY25JLElBQTlCLENBQXpDLEVBQThFO0FBQzFFbUosMkJBQU9oQixjQUFjbkksSUFBckI7QUFDQW9KLDRCQUFRQSxNQUFNM0YsU0FBTixDQUFnQixDQUFoQixFQUFtQjJGLE1BQU05TCxNQUF6QixDQUFSO0FBQ0g7QUFDRCxvQkFBSTZLLGNBQWN6SSxJQUFkLElBQXNCLENBQXRCLElBQTJCeUksY0FBYzFJLElBQWQsR0FBcUIwSSxjQUFjekksSUFBOUQsSUFBc0UsQ0FBQ25ELFNBQVMsS0FBS2xCLEtBQWQsRUFBcUI4TSxjQUFjbkksSUFBbkMsQ0FBdkUsSUFBbUhxTCxVQUFVLEdBQWpJLEVBQXNJO0FBQ2xJbEMsMkJBQU9oQixjQUFjbkksSUFBZCxHQUFxQm1KLElBQTVCO0FBQ0g7QUFDRCxxQkFBS0ssYUFBTCxDQUFtQkwsT0FBT2tDLEtBQTFCLEVBQWlDakMsS0FBakMsRUFBd0MsSUFBeEM7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7O0FBRUQ7QUFDQWpCLDBCQUFjZ0QsVUFBZCxHQUEyQixLQUEzQjs7QUFFQSxtQkFBTyxJQUFQO0FBQ0gsU0F4ZXlCOzs7QUEwZTFCOzs7QUFHQUksbUJBN2UwQix1QkE2ZWR0VSxDQTdlYyxFQTZlWDtBQUFBOztBQUNYLGdCQUFNa1IsZ0JBQWdCLEtBQUtBLGFBQTNCO0FBQ0EsZ0JBQU1xRCxhQUFhLEtBQUtuUSxLQUF4QjtBQUNBLGdCQUFNb1EsU0FBU3hVLEVBQUVuQyxPQUFqQjs7QUFIVyx5Q0FJRSxLQUFLdVUscUJBQUwsRUFKRjtBQUFBO0FBQUEsZ0JBSU5GLElBSk07O0FBTVg7OztBQUNBLGdCQUFJLENBQUNoQixjQUFjeEgsSUFBZCxLQUF3QixFQUF4QixJQUErQndILGNBQWN4SCxJQUFkLEtBQXVCLEVBQXZCLElBQThCLENBQUNwRSxTQUFTaVAsVUFBVCxFQUFxQnJELGNBQWN4SCxJQUFuQyxDQUEvRCxNQUNDd0gsY0FBYzlHLEtBQWQsS0FBd0IsRUFBeEIsSUFBK0I4RyxjQUFjOUcsS0FBZCxLQUF3QixFQUF4QixJQUE4QixDQUFDOUUsU0FBU2lQLFVBQVQsRUFBcUJyRCxjQUFjOUcsS0FBbkMsQ0FEL0QsQ0FBSixFQUNnSDtBQUFBLHdDQUMzRm1LLFdBQVdyTyxLQUFYLENBQWlCZ0wsY0FBY3pILElBQS9CLENBRDJGO0FBQUE7QUFBQSxvQkFDdkdnTCxRQUR1Rzs7QUFFNUcsb0JBQUk3SixRQUFRLEVBQVo7QUFDQSxvQkFBSXRGLFNBQVNtUCxRQUFULEVBQW1CLEdBQW5CLENBQUosRUFBNkI7QUFDekI3Siw0QkFBUSxHQUFSO0FBQ0E2SiwrQkFBV0EsU0FBU3pMLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0IsRUFBdEIsQ0FBWDtBQUNBa0osMkJBQU9BLEtBQUtsSixPQUFMLENBQWEsR0FBYixFQUFrQixFQUFsQixDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxvQkFBSTRCLFVBQVUsRUFBVixJQUFnQjZKLFNBQVNwTyxNQUFULEdBQWtCNkssY0FBY2pJLE9BQWhELElBQTJEaUosS0FBS25ILE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWxGLEVBQXVGO0FBQ25GbUgsMkJBQU9BLEtBQUtsSCxLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0g7O0FBRUQ7QUFDQSxvQkFBSUosVUFBVSxHQUFWLElBQWlCNkosU0FBU3BPLE1BQVQsR0FBa0I2SyxjQUFjaEksT0FBakQsSUFBNERnSixLQUFLbkgsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkYsRUFBd0Y7QUFDcEZtSCwyQkFBT0EsS0FBS2xILEtBQUwsQ0FBVyxDQUFYLENBQVA7QUFDSDtBQUNEa0gsdUJBQU90SCxRQUFRc0gsSUFBZjtBQUNIOztBQUVELGdCQUFNOU4sUUFBUTZILFVBQVUsS0FBSzdILEtBQWYsRUFBc0IsS0FBSzhNLGFBQTNCLENBQWQ7QUFDQSxnQkFBSTFLLFdBQVdwQyxNQUFNaUMsTUFBckI7QUFDQSxnQkFBSWpDLEtBQUosRUFBVztBQUNQO0FBQ0Esb0JBQU1zUSxTQUFTeEMsS0FBS2hNLEtBQUwsQ0FBVyxFQUFYLENBQWY7O0FBRUE7QUFDQSxvQkFBSSxDQUFDZ0wsY0FBYzVHLElBQWQsS0FBdUIsR0FBdkIsSUFBK0I0RyxjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXRGLEtBQStGb0ssT0FBTyxDQUFQLE1BQWMsR0FBN0csSUFBb0h4RCxjQUFjbkksSUFBZCxLQUF1QixFQUEvSSxFQUFtSjtBQUMvSTJMLDJCQUFPQyxLQUFQO0FBQ0Esd0JBQUl6RCxjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXRELEtBQThEa0ssV0FBVzNXLFFBQVFDLFNBQW5CLElBQWdDLEtBQUsyVCxNQUFMLEtBQWdCNVQsUUFBUUMsU0FBeEQsSUFBcUUwVyxXQUFXM1csUUFBUW9CLE1BQXhGLElBQWtHLEtBQUt3UyxNQUFMLEtBQWdCNVQsUUFBUW9CLE1BQXhMLEtBQW1NaVMsY0FBYzZDLFFBQXJOLEVBQStOO0FBQzNOVywrQkFBT0UsSUFBUCxDQUFZLEdBQVo7QUFDQTFELHNDQUFjNkMsUUFBZCxHQUF5QkMsUUFBUWhVLEVBQUV3UixJQUFGLEtBQVcsU0FBbkIsQ0FBekI7QUFDSDtBQUNELHdCQUFJTixjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXRELEtBQThEa0ssV0FBVzNXLFFBQVFDLFNBQW5CLElBQWdDLEtBQUsyVCxNQUFMLEtBQWdCNVQsUUFBUUMsU0FBeEQsSUFBcUUwVyxXQUFXM1csUUFBUW9CLE1BQXhGLElBQWtHLEtBQUt3UyxNQUFMLEtBQWdCNVQsUUFBUW9CLE1BQXhMLEtBQW1NaVMsY0FBYzZDLFFBQXJOLEVBQStOO0FBQzNOVywrQkFBT0UsSUFBUCxDQUFZLEdBQVo7QUFDQTFELHNDQUFjNkMsUUFBZCxHQUF5QkMsUUFBUWhVLEVBQUV3UixJQUFGLEtBQVcsU0FBbkIsQ0FBekI7QUFDSDtBQUNELHdCQUFJTixjQUFjM0csS0FBZCxLQUF3QixHQUF4QixJQUErQjJHLGNBQWM1RyxJQUFkLEtBQXVCLEdBQXRELEtBQThEa0ssV0FBVzNXLFFBQVFDLFNBQW5CLElBQWdDLEtBQUsyVCxNQUFMLEtBQWdCNVQsUUFBUUMsU0FBeEQsSUFBcUUwVyxXQUFXM1csUUFBUW9CLE1BQXhGLElBQWtHLEtBQUt3UyxNQUFMLEtBQWdCNVQsUUFBUW9CLE1BQXhMLEtBQW1NaVMsY0FBYzZDLFFBQXJOLEVBQStOO0FBQUE7QUFDM04sZ0NBQU1jLFlBQVkzRCxjQUFjOUcsS0FBZCxDQUFvQmxFLEtBQXBCLENBQTBCLEVBQTFCLENBQWxCO0FBQ0EsZ0NBQU00TyxZQUFZLENBQUMsSUFBRCxFQUFPLEdBQVAsRUFBWSxHQUFaLEVBQWlCLEdBQWpCLEVBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLEVBQWdDLEdBQWhDLEVBQXFDLEdBQXJDLEVBQTBDLEdBQTFDLEVBQStDLEdBQS9DLEVBQW9ELEdBQXBELENBQWxCO0FBQ0EsZ0NBQU1DLGVBQWUsRUFBckI7QUFDQTVNLDhCQUFFQyxJQUFGLENBQU95TSxTQUFQLEVBQWtCLFVBQUN6VSxDQUFELEVBQUk0VSxTQUFKLEVBQWtCO0FBQ2hDQSw0Q0FBWUgsVUFBVXpVLENBQVYsQ0FBWjtBQUNBLG9DQUFJcUYsVUFBVXVQLFNBQVYsRUFBcUJGLFNBQXJCLENBQUosRUFBcUM7QUFDakNDLGlEQUFhSCxJQUFiLENBQWtCLE9BQU9JLFNBQXpCO0FBQ0gsaUNBRkQsTUFFTztBQUNIRCxpREFBYUgsSUFBYixDQUFrQkksU0FBbEI7QUFDSDtBQUNKLDZCQVBEO0FBUUEsZ0NBQUlSLFdBQVczVyxRQUFRQyxTQUFuQixJQUFnQyxNQUFLMlQsTUFBTCxLQUFnQjVULFFBQVFDLFNBQTVELEVBQXVFO0FBQ25FaVgsNkNBQWFILElBQWIsQ0FBa0IsR0FBbEI7QUFDSDs7QUFFRDtBQUNBRixtQ0FBT0UsSUFBUCxDQUFZRyxhQUFhckssSUFBYixDQUFrQixFQUFsQixDQUFaO0FBQ0F3RywwQ0FBYzZDLFFBQWQsR0FBeUJDLFFBQVFoVSxFQUFFd1IsSUFBRixLQUFXLFNBQW5CLENBQXpCO0FBbEIyTjtBQW1COU47QUFDSjs7QUFFRCxxQkFBSyxJQUFJcFIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJc1UsT0FBT3JPLE1BQTNCLEVBQW1DakcsR0FBbkMsRUFBd0M7QUFDcEMsd0JBQUksQ0FBQ3NVLE9BQU90VSxDQUFQLEVBQVVxSyxLQUFWLENBQWdCLEtBQWhCLENBQUwsRUFBNkI7QUFDekJpSywrQkFBT3RVLENBQVAsSUFBWSxPQUFPc1UsT0FBT3RVLENBQVAsQ0FBbkI7QUFDSDtBQUNKOztBQUVELG9CQUFNNlUsVUFBVSxJQUFJbkwsTUFBSixDQUFXLFNBQVM0SyxPQUFPaEssSUFBUCxDQUFZLEtBQVosQ0FBcEIsQ0FBaEI7O0FBRUE7QUFDQSxvQkFBTXdLLFVBQVU5USxNQUFNcUcsS0FBTixDQUFZd0ssT0FBWixDQUFoQjtBQUNBLG9CQUFJQyxPQUFKLEVBQWE7QUFDVDFPLCtCQUFXME8sUUFBUSxDQUFSLEVBQVc3TyxNQUF0Qjs7QUFFQTtBQUNBLHdCQUFJLENBQUVHLGFBQWEsQ0FBYixJQUFrQnBDLE1BQU0yRyxNQUFOLENBQWEsQ0FBYixNQUFvQm1HLGNBQWNuSSxJQUFyRCxJQUErRHZDLGFBQWEsQ0FBYixJQUFrQnBDLE1BQU0yRyxNQUFOLENBQWEsQ0FBYixNQUFvQm1HLGNBQWNuSSxJQUFwSCxLQUE4SG1JLGNBQWM5RyxLQUE1SSxJQUFxSjhHLGNBQWMzRyxLQUFkLEtBQXdCLEdBQWpMLEVBQXNMO0FBQ2xMO0FBQ0EvRCxtQ0FBVyxLQUFLMEssYUFBTCxDQUFtQjlHLEtBQW5CLENBQXlCL0QsTUFBekIsSUFBbUNqQyxNQUFNMkcsTUFBTixDQUFhLENBQWIsTUFBb0IsR0FBcEIsR0FBMEIsQ0FBMUIsR0FBOEIsQ0FBakUsQ0FBWDtBQUNIO0FBQ0osaUJBUkQsTUFRTztBQUNILHdCQUFJbUcsY0FBYzlHLEtBQWQsSUFBdUI4RyxjQUFjM0csS0FBZCxLQUF3QixHQUFuRCxFQUF3RDtBQUNwRDtBQUNBO0FBQ0EvRCxvQ0FBWTBLLGNBQWM5RyxLQUFkLENBQW9CL0QsTUFBaEM7QUFDSDtBQUNELHdCQUFJNkssY0FBYzdHLE9BQWxCLEVBQTJCO0FBQ3ZCO0FBQ0E7QUFDQTdELG9DQUFZMEssY0FBYzdHLE9BQWQsQ0FBc0JoRSxNQUFsQztBQUNIO0FBQ0o7QUFDSjtBQUNELGlCQUFLRSxJQUFMLENBQVVuQyxLQUFWLEdBQWtCQSxLQUFsQjtBQUNBLGlCQUFLMk4sV0FBTCxDQUFpQnZMLFFBQWpCO0FBQ0EsaUJBQUt5SyxTQUFMLEdBQWlCLElBQWpCO0FBQ0g7QUFubEJ5QixLQUE5Qjs7QUFzbEJBOzs7Ozs7Ozs7Ozs7OztBQWNBLGFBQVNrRSxpQkFBVCxHQUEwRDtBQUFBLFlBQS9CQyxnQkFBK0IsdUVBQVosSUFBWTtBQUFBLFlBQU43TyxJQUFNOztBQUN0RCxZQUFNMEIsUUFBUTJHLFFBQVF6RyxFQUFFNUIsSUFBRixDQUFSLENBQWQ7QUFDQSxZQUFNOE8sWUFBWWxOLEVBQUUsTUFBRixFQUFVbU4sS0FBVixDQUFnQnJOLEtBQWhCLENBQWxCO0FBQ0EsWUFBTXNOLGtCQUFrQnBOLGVBQWFrTixTQUFiLFFBQTJCLENBQTNCLENBQXhCO0FBQ0EsWUFBTUcsVUFBVSxFQUFoQjs7QUFFQTtBQUNBLFlBQU1DLFVBQVUsRUFBaEI7O0FBRUE7QUFDQSxZQUFNQyxrQkFBa0IsdUNBQXhCOztBQUVBO0FBQ0EsWUFBTUMsZUFBZSxvQ0FBckI7O0FBRUE7QUFDQSxZQUFNQyxpQkFBaUIsdUJBQXZCO0FBQ0EsWUFBTUMsdUJBQXVCLCtJQUE3Qjs7QUFFQSxZQUFJQyxRQUFRLENBQVo7O0FBRUE7QUFDQTNOLFVBQUVDLElBQUYsQ0FBT21OLGVBQVAsRUFBd0IsVUFBQ25WLENBQUQsRUFBSTJWLEtBQUosRUFBYztBQUNsQyxnQkFBSUEsTUFBTXBHLElBQU4sS0FBZSxFQUFmLElBQXFCZ0csYUFBYXBKLElBQWIsQ0FBa0J3SixNQUFNQyxTQUF4QixDQUFyQixJQUEyRCxDQUFDTixnQkFBZ0JuSixJQUFoQixDQUFxQndKLE1BQU12RSxJQUEzQixDQUE1RCxJQUFnRyxDQUFDdUUsTUFBTUUsUUFBdkcsS0FBb0hGLE1BQU1HLE9BQU4sSUFBaUIsQ0FBQ04sZUFBZXJKLElBQWYsQ0FBb0J3SixNQUFNdkUsSUFBMUIsQ0FBdEksQ0FBSixFQUE0SztBQUN4S2lFLHdCQUFRYixJQUFSLENBQWFrQixLQUFiO0FBQ0FBO0FBQ0gsYUFIRCxNQUdPO0FBQ0hMLHdCQUFRYixJQUFSLENBQWEsQ0FBQyxDQUFkO0FBQ0g7QUFDSixTQVBEOztBQVNBO0FBQ0FrQixnQkFBUSxDQUFSO0FBQ0EzTixVQUFFQyxJQUFGLENBQU9tTixlQUFQLEVBQXdCLFVBQUNuVixDQUFELEVBQUkyVixLQUFKLEVBQWM7QUFDbEMsZ0JBQUlBLE1BQU1DLFNBQU4sS0FBb0IsT0FBcEIsS0FBZ0NELE1BQU12RSxJQUFOLEtBQWUsRUFBZixJQUFxQnVFLE1BQU12RSxJQUFOLEtBQWUsTUFBcEMsSUFBOEN1RSxNQUFNdkUsSUFBTixLQUFlLFFBQTdELElBQXlFdUUsTUFBTXZFLElBQU4sS0FBZSxLQUF4SCxDQUFKLEVBQW9JO0FBQ2hJZ0Usd0JBQVFaLElBQVIsQ0FBYWtCLEtBQWI7QUFDQUE7QUFDSCxhQUhELE1BR087QUFDSE4sd0JBQVFaLElBQVIsQ0FBYSxDQUFDLENBQWQ7QUFDQSxvQkFBSW1CLE1BQU1DLFNBQU4sS0FBb0IsT0FBcEIsSUFBK0JILHFCQUFxQnRKLElBQXJCLENBQTBCd0osTUFBTXZFLElBQWhDLENBQW5DLEVBQTBFO0FBQ3RFc0U7QUFDSDtBQUNKO0FBQ0osU0FWRDs7QUFZQSxZQUFJVixnQkFBSixFQUFzQjtBQUNsQixnQkFBTWUsYUFBYWxPLE1BQU1tTyxjQUFOLEVBQW5COztBQUVBak8sY0FBRUMsSUFBRixDQUFPK04sVUFBUCxFQUFtQixVQUFDL1YsQ0FBRCxFQUFJMlYsS0FBSixFQUFjO0FBQzdCLG9CQUFNTSxZQUFZbE8sRUFBRW1PLE9BQUYsQ0FBVWxXLENBQVYsRUFBYXFWLE9BQWIsQ0FBbEI7O0FBRUEsb0JBQUlZLFlBQVksQ0FBQyxDQUFiLElBQWtCYixRQUFRYSxTQUFSLElBQXFCLENBQUMsQ0FBNUMsRUFBK0M7QUFDM0Msd0JBQU1FLFlBQVlwTyxlQUFha04sU0FBYixtQkFBb0NHLFFBQVFhLFNBQVIsQ0FBcEMsT0FBbEI7QUFDQSx3QkFBTW5PLFdBQVdxTyxVQUFVdkgsSUFBVixDQUFlLGFBQWYsQ0FBakI7O0FBRUEsd0JBQUksUUFBTzlHLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUI2Tiw4QkFBTTNSLEtBQU4sR0FBY21TLFVBQVVqTyxXQUFWLENBQXNCLEtBQXRCLEVBQTZCSixTQUFTc08sWUFBdEMsRUFBb0QxUSxRQUFwRCxFQUFkO0FBQ0g7QUFDSjtBQUNKLGFBWEQ7O0FBYUEsbUJBQU9xUSxVQUFQO0FBQ0gsU0FqQkQsTUFrQks7QUFBQTtBQUNEO0FBQ0Esb0JBQU1BLGFBQWFsTyxNQUFNd08sU0FBTixFQUFuQjtBQUNBLG9CQUFNQyxZQUFZUCxXQUFXalEsS0FBWCxDQUFpQixHQUFqQixDQUFsQjs7QUFFQWlDLGtCQUFFQyxJQUFGLENBQU9zTyxTQUFQLEVBQWtCLGFBQUs7QUFBQSw2Q0FDYUEsVUFBVXRXLENBQVYsRUFBYThGLEtBQWIsQ0FBbUIsR0FBbkIsQ0FEYjtBQUFBO0FBQUEsd0JBQ1p5USxTQURZO0FBQUEsd0JBQ0RDLFVBREM7O0FBRW5CLHdCQUFNUCxZQUFZbE8sRUFBRW1PLE9BQUYsQ0FBVWxXLENBQVYsRUFBYXFWLE9BQWIsQ0FBbEI7O0FBRUE7QUFDQSx3QkFBSVksWUFBWSxDQUFDLENBQWIsSUFBa0JiLFFBQVFhLFNBQVIsSUFBcUIsQ0FBQyxDQUE1QyxFQUErQztBQUMzQyw0QkFBTUUsWUFBWXBPLGVBQWFrTixTQUFiLG1CQUFvQ0csUUFBUWEsU0FBUixDQUFwQyxPQUFsQjtBQUNBLDRCQUFNbk8sV0FBV3FPLFVBQVV2SCxJQUFWLENBQWUsYUFBZixDQUFqQjs7QUFFQSw0QkFBSSxRQUFPOUcsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUM5QixnQ0FBSTBPLGVBQWUsSUFBbkIsRUFBeUI7QUFDckIsb0NBQU1DLHFCQUFxQk4sVUFBVWpPLFdBQVYsQ0FBc0IsS0FBdEIsRUFBNkJKLFNBQVNzTyxZQUF0QyxFQUFvRDFRLFFBQXBELEVBQTNCO0FBQ0E0USwwQ0FBVXRXLENBQVYsSUFBa0J1VyxTQUFsQixTQUErQkUsa0JBQS9CO0FBQ0g7QUFDSjtBQUNKO0FBQ0osaUJBaEJEOztBQWtCQTtBQUFBLHVCQUFPSCxVQUFVaE0sSUFBVixDQUFlLEdBQWY7QUFBUDtBQXZCQzs7QUFBQTtBQXdCSjtBQUNKOztBQUVEOzs7QUFHQSxRQUFNb00sVUFBVTtBQUNaOzs7Ozs7Ozs7O0FBVUEzRixZQVhZLGdCQVdQNEYsT0FYTyxFQVdFO0FBQ1YsbUJBQU8sS0FBSzNPLElBQUwsQ0FBVSxZQUFXO0FBQ3hCLG9CQUFNSCxRQUFRRSxFQUFFLElBQUYsQ0FBZDs7QUFFQTtBQUNBLG9CQUFNNk8sVUFBVS9PLE1BQU0rRyxJQUFOLEVBQWhCOztBQUVBO0FBQ0Esb0JBQU1pSSxTQUFTaFAsTUFBTWlQLEVBQU4sQ0FBUywwRUFBVCxDQUFmOztBQUVBO0FBQ0Esb0JBQUksQ0FBQ0QsTUFBRCxJQUFXaFAsTUFBTTdDLElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixPQUF3QyxPQUF2RCxFQUFnRTtBQUM1RDRDLG9EQUE4QlEsTUFBTTdDLElBQU4sQ0FBVyxNQUFYLENBQTlCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLG9CQUFNK1IsaUJBQWlCLENBQ25CLEdBRG1CLEVBRW5CLFNBRm1CLEVBR25CLE1BSG1CLEVBSW5CLE1BSm1CLEVBS25CLE9BTG1CLEVBTW5CLElBTm1CLEVBT25CLEtBUG1CLEVBUW5CLEtBUm1CLEVBU25CLEtBVG1CLEVBVW5CLElBVm1CLEVBV25CLElBWG1CLEVBWW5CLElBWm1CLEVBYW5CLElBYm1CLEVBY25CLElBZG1CLEVBZW5CLElBZm1CLEVBZ0JuQixJQWhCbUIsRUFpQm5CLElBakJtQixFQWtCbkIsS0FsQm1CLEVBbUJuQixLQW5CbUIsRUFvQm5CLE9BcEJtQixFQXFCbkIsSUFyQm1CLEVBc0JuQixRQXRCbUIsRUF1Qm5CLFFBdkJtQixFQXdCbkIsR0F4Qm1CLEVBeUJuQixHQXpCbUIsRUEwQm5CLEdBMUJtQixFQTJCbkIsUUEzQm1CLEVBNEJuQixNQTVCbUIsRUE2Qm5CLFFBN0JtQixFQThCbkIsSUE5Qm1CLEVBK0JuQixJQS9CbUIsRUFnQ25CLEdBaENtQixDQUF2QjtBQWtDQSxvQkFBTUMsb0JBQW9CblAsTUFBTTdDLElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixFQUExQjtBQUNBLG9CQUFJdVMsc0JBQXNCLE9BQXRCLElBQWlDLENBQUMzUixVQUFVMlIsaUJBQVYsRUFBNkJELGNBQTdCLENBQXRDLEVBQW9GO0FBQ2hGMVAseUNBQW1CMlAsaUJBQW5CO0FBQ0g7O0FBRUQ7QUFDQSxvQkFBSWxQLFdBQVdELE1BQU0rRyxJQUFOLENBQVcsYUFBWCxDQUFmOztBQUVBO0FBQ0Esb0JBQUksUUFBTzlHLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJBLCtCQUFXQyxFQUFFa1AsTUFBRixDQUFTLEVBQVQsRUFBYWxQLEVBQUVtUCxFQUFGLENBQUtoUCxXQUFMLENBQWlCaVAsUUFBOUIsRUFBd0NQLE9BQXhDLEVBQWlERCxPQUFqRCxFQUEwRDtBQUNqRTlMLCtCQUFrQixLQUQrQztBQUVqRXVNLGlDQUFrQixLQUYrQztBQUdqRS9LLGtDQUFrQixFQUgrQztBQUlqRWpDLDBDQUFrQixLQUorQztBQUtqRXVKLGtDQUFrQixLQUwrQztBQU1qRUcsb0NBQWtCLElBTitDO0FBT2pFaEksK0JBQWtCLElBUCtDO0FBUWpFdUwsaUNBQWtCTjtBQVIrQyxxQkFBMUQsQ0FBWDs7QUFXQTtBQUNBaFAsc0JBQUVDLElBQUYsQ0FBT0YsUUFBUCxFQUFpQixVQUFDd1AsR0FBRCxFQUFNdFQsS0FBTixFQUFnQjtBQUM3QjtBQUNBLDRCQUFJQSxVQUFVLE1BQVYsSUFBb0JBLFVBQVUsT0FBbEMsRUFBMkM7QUFDdkM4RCxxQ0FBU3dQLEdBQVQsSUFBZ0IxRCxRQUFRNVAsVUFBVSxNQUFsQixDQUFoQjtBQUNIOztBQUVEO0FBQ0E7QUFDQSw0QkFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCc1QsUUFBUSxRQUF6QyxFQUFtRDtBQUMvQ3hQLHFDQUFTd1AsR0FBVCxJQUFnQnRULE1BQU0wQixRQUFOLEVBQWhCO0FBQ0g7QUFDSixxQkFYRDs7QUFhQTtBQUNBMUksNkJBQVM4SyxRQUFULEVBQW1CLEtBQW5CLEVBM0I4QixDQTJCSDs7QUFFM0I7QUFDQUQsMEJBQU0rRyxJQUFOLENBQVcsYUFBWCxFQUEwQjlHLFFBQTFCO0FBQ0gsaUJBL0JELE1BK0JPO0FBQ0gsMkJBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0FrSCxxQ0FBcUJsSCxRQUFyQjtBQUNBLG9CQUFJK0csU0FBU0osVUFBVTVHLEtBQVYsRUFBaUJDLFFBQWpCLENBQWI7O0FBRUFBLHlCQUFTaUIsSUFBVCxHQUFpQmpCLFNBQVNvQixZQUFULElBQXlCcEIsU0FBU3FCLFlBQW5DLEdBQW1EckIsU0FBU3FCLFlBQTVELEdBQTJFckIsU0FBU2lCLElBQXBHOztBQUVBO0FBQ0Esb0JBQUlqQixTQUFTc1AsT0FBVCxLQUFxQixLQUFyQixJQUE4QnRQLFNBQVN5UCxLQUEzQyxFQUFrRDtBQUM5Qyx3QkFBSUMsV0FBVyxJQUFmO0FBQ0Esd0JBQUlYLE1BQUosRUFBWTtBQUNSLDRCQUFNWSxlQUFlNVAsTUFBTUksR0FBTixFQUFyQjs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsNEJBQUlILFNBQVN5UCxLQUFULElBQWtCRSxpQkFBaUIsRUFBbkMsSUFBeUN2VCx5QkFBeUIyRCxNQUFNNlAsSUFBTixDQUFXLE9BQVgsQ0FBekIsQ0FBN0MsRUFBNEY7QUFDeEY7QUFDQSxnQ0FBTUMscUJBQXFCQyxXQUFXSCxhQUFhN08sT0FBYixDQUFxQixHQUFyQixFQUEwQixHQUExQixDQUFYLENBQTNCLENBRndGLENBRWpCO0FBQ3ZFLGdDQUFJLENBQUNpUCxNQUFNRixrQkFBTixDQUFELElBQThCRyxhQUFhSCxrQkFBL0MsRUFBbUU7QUFDL0Q5UCxzQ0FBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QnlQLGtCQUF6QjtBQUNBSCwyQ0FBVyxLQUFYO0FBQ0gsNkJBSEQsTUFJSztBQUNEO0FBQ0FuUSwyREFBeUJvUSxZQUF6QiwwRUFBNEcsS0FBNUc7QUFDSDtBQUNKLHlCQVhELE1BWUs7QUFDRDs7Ozs7O0FBTUE7QUFDQSxnQ0FBSzNQLFNBQVNpUSxTQUFULEtBQXVCLElBQXZCLElBQStCalEsU0FBU2lRLFNBQVQsQ0FBbUJyUyxRQUFuQixPQUFrQytSLFlBQWxFLElBQ0szUCxTQUFTaVEsU0FBVCxLQUF1QixJQUF2QixJQUErQk4saUJBQWlCLEVBQWhELElBQXNEQSxpQkFBaUI1UCxNQUFNNlAsSUFBTixDQUFXLE9BQVgsQ0FENUUsSUFFS0QsaUJBQWlCLEVBQWpCLElBQXVCNVAsTUFBTTZQLElBQU4sQ0FBVyxNQUFYLE1BQXVCLFFBQTlDLElBQTBELENBQUMzUCxFQUFFaVEsU0FBRixDQUFZUCxhQUFhN08sT0FBYixDQUFxQixHQUFyQixFQUEwQixHQUExQixDQUFaLENBRnBFLEVBRWtIO0FBQzlHLG9DQUFJZCxTQUFTbVEsSUFBVCxLQUFrQixJQUFsQixJQUEwQm5RLFNBQVNvSSxLQUF2QyxFQUE4QztBQUMxQ3BJLDZDQUFTdUUsUUFBVCxHQUFvQjJELFNBQVNuSSxLQUFULEVBQWdCQyxRQUFoQixFQUEwQixLQUExQixDQUFwQjtBQUNIO0FBQ0Qsb0NBQUlBLFNBQVNvQixZQUFULElBQXlCcEIsU0FBU29JLEtBQXRDLEVBQTZDO0FBQ3pDcEksNkNBQVN1RSxRQUFULEdBQW9CMkQsU0FBU25JLEtBQVQsRUFBZ0JDLFFBQWhCLEVBQTBCLEtBQTFCLENBQXBCO0FBQ0g7QUFDRCxvQ0FBSSxDQUFDQSxTQUFTb0ksS0FBZCxFQUFxQjtBQUNqQix3Q0FBSWdJLGdCQUFKO0FBQ0Esd0NBQUlwUSxTQUFTa0QsUUFBVCxLQUFzQixJQUF0QixJQUE4QmxELFNBQVNhLElBQVQsS0FBa0IsRUFBcEQsRUFBd0Q7QUFDcERiLGlEQUFTK0MsS0FBVCxHQUFpQixJQUFqQjtBQUNBcU4sa0RBQVVuTixnQkFBZ0IwTSxZQUFoQixFQUE4QjNQLFFBQTlCLENBQVY7QUFDSCxxQ0FIRCxNQUdPO0FBQ0hvUSxrREFBVVQsWUFBVjtBQUNIO0FBQ0QzUCw2Q0FBU3VFLFFBQVQsR0FBcUIsQ0FBQ3ZFLFNBQVNvQyxJQUFULEtBQWtCLEdBQWxCLElBQTBCcEMsU0FBU3FDLEtBQVQsS0FBbUIsR0FBbkIsSUFBMEJyQyxTQUFTb0MsSUFBVCxLQUFrQixHQUF2RSxLQUFnRnBDLFNBQVNhLElBQVQsS0FBa0IsRUFBbEcsSUFBd0d6RCxTQUFTdVMsWUFBVCxFQUF1QixHQUF2QixDQUF6RyxHQUFzSSxNQUFNMU4sVUFBVW1PLE9BQVYsRUFBbUJwUSxRQUFuQixDQUE1SSxHQUF5S2lDLFVBQVVtTyxPQUFWLEVBQW1CcFEsUUFBbkIsQ0FBN0w7QUFDSDtBQUNEMFAsMkNBQVcsS0FBWDtBQUNIO0FBQ0o7O0FBRUQsNEJBQUlDLGlCQUFpQixFQUFyQixFQUF5QjtBQUNyQixvQ0FBUTNQLFNBQVM4RCxNQUFqQjtBQUNJLHFDQUFLLE9BQUw7QUFDSTRMLCtDQUFXLEtBQVg7QUFDQTtBQUNKLHFDQUFLLFFBQUw7QUFDSTNQLDBDQUFNSSxHQUFOLENBQVVILFNBQVNrQyxLQUFuQjtBQUNBd04sK0NBQVcsS0FBWDtBQUNBO0FBQ0oscUNBQUssTUFBTDtBQUNJM1AsMENBQU1LLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUIsR0FBekI7QUFDQXNQLCtDQUFXLEtBQVg7QUFDQTtBQUNKO0FBQ0k7QUFiUjtBQWVILHlCQWhCRCxNQWdCTyxJQUFJQSxZQUFZQyxpQkFBaUI1UCxNQUFNNlAsSUFBTixDQUFXLE9BQVgsQ0FBakMsRUFBc0Q7QUFDekQ3UCxrQ0FBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QnVQLFlBQXpCO0FBQ0g7QUFDSjs7QUFFRCx3QkFBSXBTLFVBQVV3QyxNQUFNN0MsSUFBTixDQUFXLFNBQVgsRUFBc0JQLFdBQXRCLEVBQVYsRUFBK0NxRCxTQUFTdVAsT0FBeEQsS0FBb0V4UCxNQUFNbEIsSUFBTixPQUFpQixFQUF6RixFQUE2RjtBQUN6Riw0QkFBSW1CLFNBQVNpUSxTQUFULEtBQXVCLElBQTNCLEVBQWlDO0FBQzdCLGdDQUFJalEsU0FBU2lRLFNBQVQsS0FBdUJsUSxNQUFNbEIsSUFBTixFQUEzQixFQUF5QztBQUNyQ2tCLHNDQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCTCxNQUFNbEIsSUFBTixFQUF6QjtBQUNIO0FBQ0oseUJBSkQsTUFJTztBQUNIa0Isa0NBQU1LLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUJMLE1BQU1sQixJQUFOLEVBQXpCO0FBQ0g7QUFDSjtBQUNKOztBQUVEbUIseUJBQVNzUCxPQUFULEdBQW1CLElBQW5COztBQUVBO0FBQ0E7QUFDQSxvQkFBSVAsTUFBSixFQUFZO0FBQ1JoUCwwQkFBTXNRLEVBQU4sQ0FBUyxxQkFBVCxFQUFnQyxZQUFNO0FBQ2xDdEosaUNBQVNKLFVBQVU1RyxLQUFWLENBQVQ7QUFDQSw0QkFBTXVRLFlBQVl2SixPQUFPaUMsYUFBekI7QUFDQXNILGtDQUFVdk4sS0FBVixHQUFrQixJQUFsQjtBQUNBLDRCQUFJdU4sVUFBVXBOLFFBQVYsS0FBdUIsSUFBdkIsSUFBK0JvTixVQUFVelAsSUFBVixLQUFtQixFQUF0RCxFQUEwRDtBQUN0RGQsa0NBQU1JLEdBQU4sQ0FBVThDLGdCQUFnQmxELE1BQU1JLEdBQU4sRUFBaEIsRUFBNkJtUSxTQUE3QixDQUFWO0FBQ0g7QUFDRCw0QkFBSXJMLGVBQUo7QUFDQSw0QkFBSXFMLFVBQVVILElBQWQsRUFBb0I7QUFDaEJHLHNDQUFVclAsSUFBVixHQUFpQnFQLFVBQVVILElBQTNCO0FBQ0FwUSxrQ0FBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QmtRLFVBQVUvTCxRQUFuQztBQUNILHlCQUhELE1BR08sSUFBSStMLFVBQVVsUCxZQUFkLEVBQTRCO0FBQy9Ca1Asc0NBQVVyUCxJQUFWLEdBQWlCcVAsVUFBVXBQLElBQTNCO0FBQ0FuQixrQ0FBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QmtRLFVBQVUvTCxRQUFuQztBQUNILHlCQUhNLE1BR0EsSUFBSStMLFVBQVVDLElBQWQsRUFBb0I7QUFDdkJELHNDQUFVOU8sSUFBVixHQUFpQixFQUFqQjtBQUNBOE8sc0NBQVVwTyxLQUFWLEdBQWtCLEVBQWxCO0FBQ0FvTyxzQ0FBVW5PLE9BQVYsR0FBb0IsRUFBcEI7QUFDQXBDLGtDQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCa1EsVUFBVS9MLFFBQW5DO0FBQ0gseUJBTE0sTUFLQSxJQUFJLENBQUNVLFNBQVNoRCxVQUFVbEMsTUFBTUksR0FBTixFQUFWLEVBQXVCbVEsU0FBdkIsQ0FBVixNQUFpREEsVUFBVS9MLFFBQS9ELEVBQXlFO0FBQzVFeEUsa0NBQU1LLFdBQU4sQ0FBa0IsS0FBbEIsRUFBeUI2RSxNQUF6QjtBQUNIOztBQUVEOEIsK0JBQU95SixLQUFQLEdBQWV6USxNQUFNSSxHQUFOLEVBQWY7QUFDQTRHLCtCQUFPMEosT0FBUCxHQUFpQjFKLE9BQU95SixLQUF4QjtBQUNBLDRCQUFNRSxVQUFVL00sV0FBV29ELE9BQU95SixLQUFsQixFQUF5QkYsU0FBekIsRUFBb0MsSUFBcEMsQ0FBaEI7QUFDQSw0QkFBS0ksWUFBWSxJQUFaLElBQW9CQSxZQUFZLEVBQWpDLElBQXdDSixVQUFVeE0sTUFBVixLQUFxQixPQUFqRSxFQUEwRTtBQUN0RS9ELGtDQUFNSSxHQUFOLENBQVV1USxPQUFWO0FBQ0g7QUFDSixxQkE3QkQ7O0FBK0JBM1EsMEJBQU1zUSxFQUFOLENBQVMscUJBQVQsRUFBZ0MsYUFBSztBQUNqQ3RKLGlDQUFTSixVQUFVNUcsS0FBVixDQUFUO0FBQ0EsNEJBQUlnSCxPQUFPMUksSUFBUCxDQUFZc1MsUUFBaEIsRUFBMEI7QUFDdEI1SixtQ0FBTzBDLFNBQVAsR0FBbUIsSUFBbkI7QUFDQSxtQ0FBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0ExQywrQkFBT2tDLElBQVAsQ0FBWW5SLENBQVo7QUFDQSw0QkFBSWlQLE9BQU91RSxVQUFQLENBQWtCeFQsQ0FBbEIsQ0FBSixFQUEwQjtBQUN0QmlQLG1DQUFPMEMsU0FBUCxHQUFtQixJQUFuQjtBQUNBLG1DQUFPLElBQVA7QUFDSDtBQUNELDRCQUFJMUMsT0FBT2dGLGFBQVAsRUFBSixFQUE0QjtBQUN4QmhGLG1DQUFPMEMsU0FBUCxHQUFtQixJQUFuQjtBQUNBMUMsbUNBQU9xRixXQUFQLENBQW1CdFUsQ0FBbkI7QUFDQSxnQ0FBTTZYLGdCQUFlNVAsTUFBTUksR0FBTixFQUFyQjtBQUNBLGdDQUFLd1Asa0JBQWlCNUksT0FBTzBKLE9BQXpCLElBQXFDMUosT0FBT2lDLGFBQVAsQ0FBcUJnRCxVQUE5RCxFQUEwRTtBQUN0RTtBQUNBak0sc0NBQU00SyxPQUFOLENBQWMsT0FBZDtBQUNIO0FBQ0Q1RCxtQ0FBTzBKLE9BQVAsR0FBaUJkLGFBQWpCO0FBQ0E1SSxtQ0FBT2lDLGFBQVAsQ0FBcUJnRCxVQUFyQixHQUFrQyxJQUFsQztBQUNBbFUsOEJBQUUwVCxjQUFGO0FBQ0EsbUNBQU8sS0FBUDtBQUNIO0FBQ0R6RSwrQkFBT2dDLFNBQVAsR0FBbUIsS0FBbkI7QUFDQSwrQkFBTyxJQUFQO0FBQ0gscUJBaENEOztBQWtDQWhKLDBCQUFNc1EsRUFBTixDQUFTLHNCQUFULEVBQWlDLGFBQUs7QUFDbEM7QUFDQSw0QkFBSXZZLEVBQUV1UixRQUFGLElBQWN2UixFQUFFbkMsT0FBRixLQUFjQSxRQUFRbUIsTUFBeEMsRUFBZ0Q7QUFDNUM7QUFDSDtBQUNEaVEsaUNBQVNKLFVBQVU1RyxLQUFWLENBQVQ7QUFDQSw0QkFBTTBKLFlBQVkxQyxPQUFPMEMsU0FBekI7QUFDQTFDLCtCQUFPa0MsSUFBUCxDQUFZblIsQ0FBWjtBQUNBLDRCQUFJaVAsT0FBT3VFLFVBQVAsQ0FBa0J4VCxDQUFsQixDQUFKLEVBQTBCO0FBQ3RCLG1DQUFPLElBQVA7QUFDSDtBQUNELDRCQUFJMlIsU0FBSixFQUFlO0FBQ1gzUiw4QkFBRTBULGNBQUY7QUFDQSxtQ0FBTyxLQUFQO0FBQ0g7QUFDRCw0QkFBSXpFLE9BQU9nRixhQUFQLE1BQTBCaEYsT0FBT2tGLGVBQVAsRUFBOUIsRUFBd0Q7QUFDcERsRixtQ0FBT3FGLFdBQVAsQ0FBbUJ0VSxDQUFuQjtBQUNBLGdDQUFNNlgsaUJBQWU1UCxNQUFNSSxHQUFOLEVBQXJCO0FBQ0EsZ0NBQUt3UCxtQkFBaUI1SSxPQUFPMEosT0FBekIsSUFBcUMxSixPQUFPaUMsYUFBUCxDQUFxQmdELFVBQTlELEVBQTBFO0FBQ3RFO0FBQ0FqTSxzQ0FBTTRLLE9BQU4sQ0FBYyxPQUFkO0FBQ0g7QUFDRDVELG1DQUFPMEosT0FBUCxHQUFpQmQsY0FBakI7QUFDQTVJLG1DQUFPaUMsYUFBUCxDQUFxQmdELFVBQXJCLEdBQWtDLElBQWxDO0FBQ0FsVSw4QkFBRTBULGNBQUY7QUFDQTtBQUNIO0FBQ0R6RSwrQkFBT2dDLFNBQVAsR0FBbUIsS0FBbkI7QUFDSCxxQkE1QkQ7O0FBOEJBaEosMEJBQU1zUSxFQUFOLENBQVMsbUJBQVQsRUFBOEIsVUFBU3ZZLENBQVQsRUFBWTtBQUN0Q2lQLGlDQUFTSixVQUFVNUcsS0FBVixDQUFUO0FBQ0FnSCwrQkFBT2tDLElBQVAsQ0FBWW5SLENBQVo7QUFDQSw0QkFBTThZLE9BQU83SixPQUFPdUUsVUFBUCxDQUFrQnhULENBQWxCLENBQWI7QUFDQSw0QkFBTStZLE1BQU05SixPQUFPd0MsTUFBbkI7QUFDQXhDLCtCQUFPd0MsTUFBUCxHQUFnQixDQUFoQjtBQUNBLCtCQUFPeEMsT0FBT21FLHFCQUFkOztBQUVBO0FBQ0EsNEJBQUluTCxNQUFNLENBQU4sRUFBUzdELEtBQVQsS0FBbUI2SyxPQUFPaUMsYUFBUCxDQUFxQjlHLEtBQTVDLEVBQW1EO0FBQy9DLGdDQUFJNkUsT0FBT2lDLGFBQVAsQ0FBcUIzRyxLQUFyQixLQUErQixHQUFuQyxFQUF3QztBQUNwQ25ELG9EQUFvQixJQUFwQixFQUEwQixDQUExQixFQUE2QixDQUE3QjtBQUNILDZCQUZELE1BRU87QUFDSEEsb0RBQW9CLElBQXBCLEVBQTBCNkgsT0FBT2lDLGFBQVAsQ0FBcUI5RyxLQUFyQixDQUEyQi9ELE1BQXJELEVBQTZENEksT0FBT2lDLGFBQVAsQ0FBcUI5RyxLQUFyQixDQUEyQi9ELE1BQXhGO0FBQ0g7QUFDSix5QkFORCxNQU1PLElBQUkwUyxRQUFRbGIsUUFBUUUsR0FBcEIsRUFBeUI7QUFDNUJxSixnREFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsRUFBNkJhLE1BQU1JLEdBQU4sR0FBWWhDLE1BQXpDO0FBQ0g7QUFDRCw0QkFBSTRCLE1BQU0sQ0FBTixFQUFTN0QsS0FBVCxLQUFtQjZLLE9BQU9pQyxhQUFQLENBQXFCN0csT0FBNUMsRUFBcUQ7QUFDakRqRCxnREFBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0I7QUFDSDtBQUNELDRCQUFJNkgsT0FBT2lDLGFBQVAsQ0FBcUJ6RSxRQUFyQixLQUFrQyxFQUFsQyxJQUF3Q3dDLE9BQU9pQyxhQUFQLENBQXFCOUcsS0FBckIsS0FBK0IsRUFBdkUsSUFBNkU2RSxPQUFPaUMsYUFBUCxDQUFxQjdHLE9BQXJCLEtBQWlDLEVBQWxILEVBQXNIO0FBQ2xIakQsZ0RBQW9CLElBQXBCLEVBQTBCLENBQTFCLEVBQTZCLENBQTdCO0FBQ0g7O0FBRUQ7QUFDQSw0QkFBSTZILE9BQU9pQyxhQUFQLENBQXFCbUgsSUFBckIsS0FBOEIsSUFBOUIsSUFBc0NwSixPQUFPaUMsYUFBUCxDQUFxQlosS0FBL0QsRUFBc0U7QUFDbEVGLHFDQUFTbkksS0FBVCxFQUFnQkMsUUFBaEIsRUFBMEIsS0FBMUI7QUFDSDtBQUNELDRCQUFJNFEsSUFBSixFQUFVO0FBQ04sbUNBQU8sSUFBUDtBQUNIO0FBQ0QsNEJBQUksS0FBSzFVLEtBQUwsS0FBZSxFQUFuQixFQUF1QjtBQUNuQixtQ0FBTyxJQUFQO0FBQ0g7QUFDRCw0QkFBSSxDQUFDNkssT0FBT2dDLFNBQVosRUFBdUI7QUFDbkJoQyxtQ0FBT3FGLFdBQVAsQ0FBbUJ0VSxDQUFuQjtBQUNIO0FBQ0oscUJBdENEOztBQXdDQWlJLDBCQUFNc1EsRUFBTixDQUFTLHNCQUFULEVBQWlDLFlBQU07QUFDbkN0SixpQ0FBU0osVUFBVTVHLEtBQVYsQ0FBVDtBQUNBLDRCQUFJN0QsUUFBUTZELE1BQU1JLEdBQU4sRUFBWjtBQUNBLDRCQUFNMlEsWUFBWTVVLEtBQWxCO0FBQ0EsNEJBQU1vVSxZQUFZdkosT0FBT2lDLGFBQXpCO0FBQ0FzSCxrQ0FBVXZOLEtBQVYsR0FBa0IsS0FBbEI7QUFDQSw0QkFBSXVOLFVBQVVsSSxLQUFkLEVBQXFCO0FBQ2pCRixxQ0FBU25JLEtBQVQsRUFBZ0J1USxTQUFoQixFQUEyQixLQUEzQjtBQUNIO0FBQ0QsNEJBQUlBLFVBQVVDLElBQVYsS0FBbUIsSUFBdkIsRUFBNkI7QUFDekJELHNDQUFVOU8sSUFBVixHQUFpQjhPLFVBQVVqSixJQUEzQjtBQUNBaUosc0NBQVVwTyxLQUFWLEdBQWtCb08sVUFBVWhKLEtBQTVCO0FBQ0FnSixzQ0FBVW5PLE9BQVYsR0FBb0JtTyxVQUFVL0ksT0FBOUI7QUFDSDtBQUNELDRCQUFJK0ksVUFBVUgsSUFBVixLQUFtQixJQUF2QixFQUE2QjtBQUN6Qkcsc0NBQVVyUCxJQUFWLEdBQWlCcVAsVUFBVXBQLElBQTNCO0FBQ0FvUCxzQ0FBVXBMLElBQVYsR0FBaUJvTCxVQUFVbkosSUFBM0I7QUFDQW1KLHNDQUFVcE4sUUFBVixHQUFxQm9OLFVBQVVsSixRQUEvQjtBQUNIO0FBQ0RsTCxnQ0FBUStGLFVBQVUvRixLQUFWLEVBQWlCb1UsU0FBakIsQ0FBUjtBQUNBLDRCQUFJcFUsVUFBVSxFQUFkLEVBQWtCO0FBQ2QsZ0NBQUlvVSxVQUFVaE8sZ0JBQWQsRUFBZ0M7QUFDNUJwRyx3Q0FBUSxNQUFNQSxLQUFkO0FBQ0FvVSwwQ0FBVWhPLGdCQUFWLEdBQTZCLEtBQTdCO0FBQ0g7O0FBSmEsOENBS2ErRCxVQUFVbkssS0FBVixFQUFpQm9VLFNBQWpCLENBTGI7QUFBQTtBQUFBLGdDQUtQOUYsT0FMTztBQUFBLGdDQUtFQyxPQUxGOztBQU1kLGdDQUFJOUcsV0FBV3pILEtBQVgsRUFBa0JvVSxTQUFsQixNQUFpQyxJQUFqQyxJQUF5QzlGLE9BQXpDLElBQW9EQyxPQUF4RCxFQUFpRTtBQUM3RHZPLHdDQUFRdUgsVUFBVXZILEtBQVYsRUFBaUJvVSxVQUFVL08sSUFBM0IsRUFBaUMrTyxVQUFVelAsSUFBM0MsQ0FBUjtBQUNBeVAsMENBQVUvTCxRQUFWLEdBQXFCckksS0FBckI7QUFDQSxvQ0FBSW9VLFVBQVVsUCxZQUFkLEVBQTRCO0FBQ3hCbEYsNENBQVFBLFFBQVFvVSxVQUFVbFAsWUFBMUI7QUFDQWxGLDRDQUFRQSxNQUFNMEIsUUFBTixFQUFSO0FBQ0g7QUFDRDBTLDBDQUFVclAsSUFBVixHQUFrQnFQLFVBQVVsUCxZQUFWLElBQTBCa1AsVUFBVWpQLFlBQXJDLEdBQXFELENBQUNpUCxVQUFValAsWUFBaEUsR0FBK0VpUCxVQUFVclAsSUFBMUc7QUFDQS9FLHdDQUFRMEksVUFBVTFJLEtBQVYsRUFBaUJvVSxTQUFqQixDQUFSO0FBQ0FwVSx3Q0FBUXdILGNBQWN4SCxLQUFkLEVBQXFCb1UsU0FBckIsQ0FBUjtBQUNILDZCQVZELE1BVU87QUFDSCxvQ0FBSSxDQUFDOUYsT0FBTCxFQUFjO0FBQ1Z6SywwQ0FBTTRLLE9BQU4sQ0FBYyx5QkFBZDtBQUNIO0FBQ0Qsb0NBQUksQ0FBQ0YsT0FBTCxFQUFjO0FBQ1YxSywwQ0FBTTRLLE9BQU4sQ0FBYyx5QkFBZDtBQUNIO0FBQ0R6Tyx3Q0FBUW9VLFVBQVUvTCxRQUFsQjtBQUNIO0FBQ0oseUJBekJELE1BeUJPO0FBQ0gsZ0NBQUkrTCxVQUFVeE0sTUFBVixLQUFxQixNQUF6QixFQUFpQztBQUM3QndNLDBDQUFVL0wsUUFBVixHQUFxQixHQUFyQjtBQUNBckksd0NBQVEwSSxVQUFVLEdBQVYsRUFBZTBMLFNBQWYsQ0FBUjtBQUNILDZCQUhELE1BR087QUFDSEEsMENBQVUvTCxRQUFWLEdBQXFCLEVBQXJCO0FBQ0g7QUFDSjtBQUNELDRCQUFJd00sZUFBZXBOLFdBQVd6SCxLQUFYLEVBQWtCb1UsU0FBbEIsRUFBNkIsS0FBN0IsQ0FBbkI7QUFDQSw0QkFBSVMsaUJBQWlCLElBQXJCLEVBQTJCO0FBQ3ZCQSwyQ0FBZWhOLFVBQVU3SCxLQUFWLEVBQWlCb1UsU0FBakIsQ0FBZjtBQUNIO0FBQ0QsNEJBQUlTLGlCQUFpQkQsU0FBckIsRUFBZ0M7QUFDNUJDLDJDQUFnQlQsVUFBVVUsV0FBWCxHQUEwQkQsZUFBZVQsVUFBVVUsV0FBbkQsR0FBaUVELFlBQWhGO0FBQ0FoUixrQ0FBTUksR0FBTixDQUFVNFEsWUFBVjtBQUNIO0FBQ0QsNEJBQUlBLGlCQUFpQmhLLE9BQU95SixLQUE1QixFQUFtQztBQUMvQnpRLGtDQUFNa1IsTUFBTjtBQUNBLG1DQUFPbEssT0FBT3lKLEtBQWQ7QUFDSDtBQUNKLHFCQWpFRDs7QUFtRUF6USwwQkFBTXNRLEVBQU4sQ0FBUyxPQUFULEVBQWtCLFVBQVN2WSxDQUFULEVBQVk7QUFDMUI7QUFDQUEsMEJBQUUwVCxjQUFGO0FBQ0F6RSxpQ0FBU0osVUFBVTVHLEtBQVYsQ0FBVDtBQUNBLGlDQUFTbVIsT0FBVCxDQUFpQnJTLElBQWpCLEVBQXVCO0FBQ25CLG1DQUFPb0QsVUFBVXBELElBQVYsRUFBZ0JrSSxPQUFPaUMsYUFBdkIsRUFBc0NsSSxPQUF0QyxDQUE4Q2lHLE9BQU9pQyxhQUFQLENBQXFCekgsSUFBbkUsRUFBeUUsR0FBekUsQ0FBUDtBQUNIOztBQUVELGlDQUFTNFAsT0FBVCxDQUFpQnRTLElBQWpCLEVBQXVCO0FBQ25CLG1DQUFPQSxTQUFTLEVBQVQsSUFBZSxDQUFDa1IsTUFBTWxSLElBQU4sQ0FBdkI7QUFDSDs7QUFFRCw0QkFBTXVTLGNBQWNyUixNQUFNSyxXQUFOLENBQWtCLEtBQWxCLENBQXBCO0FBQ0EsNEJBQU11UCxlQUFlLEtBQUt6VCxLQUFMLElBQWMsRUFBbkM7QUFDQSw0QkFBTXFDLGlCQUFpQixLQUFLQSxjQUFMLElBQXVCLENBQTlDO0FBQ0EsNEJBQU1VLGVBQWUsS0FBS0EsWUFBTCxJQUFxQixDQUExQztBQUNBLDRCQUFNb1MsU0FBUzFCLGFBQWFyTCxTQUFiLENBQXVCLENBQXZCLEVBQTBCL0YsY0FBMUIsQ0FBZjtBQUNBLDRCQUFNK1MsU0FBUzNCLGFBQWFyTCxTQUFiLENBQXVCckYsWUFBdkIsRUFBcUMwUSxhQUFheFIsTUFBbEQsQ0FBZjtBQUNBLDRCQUFNb1QsYUFBYUwsUUFBUXBaLEVBQUUwWixhQUFGLENBQWdCQyxhQUFoQixDQUE4QkMsT0FBOUIsQ0FBc0MsWUFBdEMsQ0FBUixDQUFuQjtBQUNBLDRCQUFJUCxRQUFRSSxVQUFSLENBQUosRUFBeUI7QUFDckIsZ0NBQU1uSCxXQUFXOEcsUUFBUUcsU0FBU2xRLE9BQU9vUSxVQUFQLEVBQW1CSSxPQUFuQixFQUFULEdBQXdDTCxNQUFoRCxDQUFqQjtBQUNBLGdDQUFJSCxRQUFRL0csUUFBUixLQUFxQmpKLE9BQU9pUSxXQUFQLEVBQW9CTyxPQUFwQixPQUFrQ3hRLE9BQU9pSixRQUFQLEVBQWlCdUgsT0FBakIsRUFBM0QsRUFBdUY7QUFDbkY1UixzQ0FBTUssV0FBTixDQUFrQixLQUFsQixFQUF5QmdLLFFBQXpCO0FBQ0FySyxzQ0FBTTRLLE9BQU4sQ0FBYyxPQUFkO0FBQ0g7QUFDSix5QkFORCxNQU1PO0FBQ0gsaUNBQUtwTSxjQUFMLEdBQXNCVSxZQUF0QjtBQUNIO0FBQ0oscUJBNUJEOztBQThCQWMsMEJBQU02UixPQUFOLENBQWMsTUFBZCxFQUFzQnZCLEVBQXRCLENBQXlCLG9CQUF6QixFQUErQyxZQUFNO0FBQ2pEdEosaUNBQVNKLFVBQVU1RyxLQUFWLENBQVQ7QUFDQSw0QkFBSWdILE1BQUosRUFBWTtBQUNSLGdDQUFNdUosWUFBWXZKLE9BQU9pQyxhQUF6QjtBQUNBLGdDQUFJc0gsVUFBVXVCLGFBQWQsRUFBNkI7QUFDekI5UixzQ0FBTUksR0FBTixDQUFVbVEsVUFBVS9MLFFBQXBCO0FBQ0g7QUFDSjtBQUNKLHFCQVJEO0FBU0g7QUFDSixhQXhiTSxDQUFQO0FBeWJILFNBcmNXOzs7QUF1Y1o7Ozs7O0FBS0F1TixlQTVjWSxxQkE0Y0Y7QUFDTixtQkFBTzdSLEVBQUUsSUFBRixFQUFRQyxJQUFSLENBQWEsWUFBVztBQUMzQixvQkFBTUgsUUFBUTJHLFFBQVF6RyxFQUFFLElBQUYsQ0FBUixDQUFkO0FBQ0Esb0JBQU1ELFdBQVdELE1BQU0rRyxJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLG9CQUFJLFFBQU85RyxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXhCLEVBQWtDO0FBQzlCRCwwQkFBTUksR0FBTixDQUFVLEVBQVY7QUFDQStILDZCQUFTbkksS0FBVCxFQUFnQkMsUUFBaEIsRUFBMEIsTUFBMUI7QUFDQUQsMEJBQU1nUyxVQUFOLENBQWlCLGFBQWpCO0FBQ0FoUywwQkFBTWlTLEdBQU4sQ0FBVSxjQUFWO0FBQ0g7QUFDSixhQVRNLENBQVA7QUFVSCxTQXZkVzs7O0FBeWRaOzs7OztBQUtBQyxZQTlkWSxrQkE4ZEw7QUFDSCxtQkFBT2hTLEVBQUUsSUFBRixFQUFRQyxJQUFSLENBQWEsWUFBVztBQUMzQixvQkFBTUgsUUFBUTJHLFFBQVF6RyxFQUFFLElBQUYsQ0FBUixDQUFkO0FBQ0Esb0JBQU1ELFdBQVdELE1BQU0rRyxJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLG9CQUFJLFFBQU85RyxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXhCLEVBQWtDO0FBQzlCRCwwQkFBTUksR0FBTixDQUFVLEVBQVY7QUFDQUgsNkJBQVN1RSxRQUFULEdBQW9CLEVBQXBCO0FBQ0EyRCw2QkFBU25JLEtBQVQsRUFBZ0JDLFFBQWhCLEVBQTBCLE1BQTFCO0FBQ0g7QUFDSixhQVJNLENBQVA7QUFTSCxTQXhlVzs7O0FBMGVaOzs7Ozs7O0FBT0E2RyxjQWpmWSxrQkFpZkxnSSxPQWpmSyxFQWlmSTtBQUNaLG1CQUFPNU8sRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFNSCxRQUFRMkcsUUFBUXpHLEVBQUUsSUFBRixDQUFSLENBQWQ7QUFDQSxvQkFBSUQsV0FBV0QsTUFBTStHLElBQU4sQ0FBVyxhQUFYLENBQWY7O0FBRUEsb0JBQUksUUFBTzlHLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJULDRHQUF3RixJQUF4RjtBQUNIO0FBQ0Qsb0JBQU15RSxRQUFRakUsTUFBTUssV0FBTixDQUFrQixLQUFsQixDQUFkO0FBQ0FKLDJCQUFXQyxFQUFFa1AsTUFBRixDQUFTblAsUUFBVCxFQUFtQjZPLE9BQW5CLENBQVg7O0FBRUEsb0JBQUk3TyxTQUFTb0IsWUFBYixFQUEyQjtBQUN2QnBCLDZCQUFTaUIsSUFBVCxHQUFpQmpCLFNBQVNxQixZQUFWLEdBQTBCckIsU0FBU3FCLFlBQW5DLEdBQWtEckIsU0FBU2lCLElBQTNFO0FBQ0g7QUFDRGlHLHFDQUFxQmxILFFBQXJCO0FBQ0EyRywwQkFBVTVHLEtBQVYsRUFBaUJDLFFBQWpCLEVBQTJCLElBQTNCOztBQUVBLG9CQUFJQSxTQUFTdUIsSUFBVCxLQUFrQnZCLFNBQVN3QixJQUEvQixFQUFxQztBQUNqQ2pDLDZHQUF1RlMsU0FBU3VCLElBQWhHLHdDQUF1SXZCLFNBQVN3QixJQUFoSiwrQkFBZ0x4QixTQUFTUCxLQUF6TDtBQUNIO0FBQ0RNLHNCQUFNK0csSUFBTixDQUFXLGFBQVgsRUFBMEI5RyxRQUExQjs7QUFFQSxvQkFBSUQsTUFBTUksR0FBTixPQUFnQixFQUFoQixJQUFzQkosTUFBTWxCLElBQU4sT0FBaUIsRUFBM0MsRUFBK0M7QUFDM0MsMkJBQU9rQixNQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCNEQsS0FBekIsQ0FBUDtBQUNIO0FBQ0osYUF4Qk0sQ0FBUDtBQXlCSCxTQTNnQlc7OztBQTZnQlo7Ozs7OztBQU1Ba08sV0FuaEJZLGVBbWhCUkMsT0FuaEJRLEVBbWhCQztBQUNULG1CQUFPbFMsRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFJaVMsWUFBWSxJQUFaLElBQW9CaFcsWUFBWWdXLE9BQVosQ0FBeEIsRUFBOEM7QUFDMUM7QUFDSDtBQUNELG9CQUFNcFMsUUFBUTJHLFFBQVF6RyxFQUFFLElBQUYsQ0FBUixDQUFkO0FBQ0Esb0JBQU1ELFdBQVdELE1BQU0rRyxJQUFOLENBQVcsYUFBWCxDQUFqQjtBQUNBLG9CQUFNaUksU0FBU2hQLE1BQU1pUCxFQUFOLENBQVMsMEVBQVQsQ0FBZjtBQUNBLG9CQUFJOVMsUUFBUWlXLFFBQVF2VSxRQUFSLEVBQVo7QUFDQSxvQkFBSSxRQUFPb0MsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUF4QixFQUFrQztBQUM5QlQseUdBQXFGLElBQXJGO0FBQ0g7O0FBRUQ7QUFDQXJELHdCQUFRbUgsV0FBV25ILEtBQVgsQ0FBUjs7QUFFQTtBQUNBLG9CQUFJLENBQUMrRCxFQUFFaVEsU0FBRixDQUFZL08sT0FBT2pGLEtBQVAsQ0FBWixDQUFMLEVBQWlDO0FBQzdCcUQsK0NBQXlCckQsS0FBekIsdUVBQWtHOEQsU0FBU1AsS0FBM0c7QUFDQSwyQkFBT00sTUFBTUksR0FBTixDQUFVLEVBQVYsQ0FBUDtBQUNIOztBQUVELG9CQUFJakUsVUFBVSxFQUFkLEVBQWtCO0FBQUEsc0NBQ2FtSyxVQUFVbkssS0FBVixFQUFpQjhELFFBQWpCLENBRGI7QUFBQTtBQUFBLHdCQUNQd0ssT0FETztBQUFBLHdCQUNFQyxPQURGOztBQUVkLHdCQUFJRCxXQUFXQyxPQUFmLEVBQXdCO0FBQ3BCLDRCQUFJc0UsV0FBVy9PLFNBQVNtUSxJQUFULElBQWlCblEsU0FBU29CLFlBQXJDLENBQUosRUFBd0Q7QUFDcERwQixxQ0FBU3VFLFFBQVQsR0FBb0JySSxLQUFwQjtBQUNIOztBQUVEO0FBQ0EsNEJBQUk2UyxVQUFVeFIsVUFBVXdDLE1BQU03QyxJQUFOLENBQVcsU0FBWCxFQUFzQlAsV0FBdEIsRUFBVixFQUErQ3FELFNBQVN1UCxPQUF4RCxDQUFkLEVBQWdGO0FBQzVFLGdDQUFJdlAsU0FBU29CLFlBQVQsSUFBeUIsQ0FBQ3BCLFNBQVMrQyxLQUF2QyxFQUE4QztBQUMxQzdHLHdDQUFRQSxRQUFROEQsU0FBU29CLFlBQXpCO0FBQ0FsRix3Q0FBUUEsTUFBTTBCLFFBQU4sRUFBUjtBQUNBb0MseUNBQVNpQixJQUFULEdBQWlCakIsU0FBU3FCLFlBQVYsR0FBMEJyQixTQUFTcUIsWUFBbkMsR0FBa0RyQixTQUFTaUIsSUFBM0U7QUFDSDtBQUNEL0Usb0NBQVEwSSxVQUFVMUksS0FBVixFQUFpQjhELFFBQWpCLENBQVI7QUFDQSxnQ0FBSUEsU0FBU21RLElBQVQsS0FBa0IsSUFBbEIsSUFBMEJuUSxTQUFTb0IsWUFBVCxLQUEwQixJQUF4RCxFQUE4RDtBQUMxRHBCLHlDQUFTdUUsUUFBVCxHQUFvQnJJLEtBQXBCO0FBQ0g7QUFDREEsb0NBQVF3SCxjQUFjeEgsS0FBZCxFQUFxQjhELFFBQXJCLENBQVI7QUFDQTlELG9DQUFRNkgsVUFBVTdILEtBQVYsRUFBaUI4RCxRQUFqQixDQUFSO0FBQ0g7QUFDRCw0QkFBSUEsU0FBU29JLEtBQVQsS0FBbUJwSSxTQUFTbVEsSUFBVCxJQUFpQm5RLFNBQVNvQixZQUE3QyxDQUFKLEVBQWdFO0FBQzVEOEcscUNBQVNuSSxLQUFULEVBQWdCQyxRQUFoQixFQUEwQixLQUExQjtBQUNIO0FBQ0oscUJBdEJELE1Bc0JPO0FBQ0hBLGlDQUFTdUUsUUFBVCxHQUFvQixFQUFwQjtBQUNBMkQsaUNBQVNuSSxLQUFULEVBQWdCQyxRQUFoQixFQUEwQixNQUExQjtBQUNBLDRCQUFNb1MsaUJBQWlCbFcsS0FBdkI7QUFDQUEsZ0NBQVEsRUFBUjtBQUNBLDRCQUFJLENBQUNzTyxPQUFMLEVBQWM7QUFDVnpLLGtDQUFNNEssT0FBTixDQUFjLHlCQUFkO0FBQ0g7QUFDRCw0QkFBSSxDQUFDRixPQUFMLEVBQWM7QUFDVjFLLGtDQUFNNEssT0FBTixDQUFjLHlCQUFkO0FBQ0g7QUFDRHBMLG1EQUF5QjZTLGNBQXpCLDRDQUE4RXBTLFNBQVNNLElBQXZGLG9CQUEwR04sU0FBU08sSUFBbkgsa0NBQXNKUCxTQUFTUCxLQUEvSjtBQUNBLCtCQUFPTSxNQUFNSSxHQUFOLENBQVUsRUFBVixDQUFQO0FBQ0g7QUFDSixpQkF0Q0QsTUFzQ087QUFDSCwyQkFBT0osTUFBTUksR0FBTixDQUFVLEVBQVYsQ0FBUDtBQUNIOztBQUVELG9CQUFJLENBQUNILFNBQVMrQyxLQUFWLElBQW1CL0MsU0FBU2dSLFdBQWhDLEVBQTZDO0FBQ3pDOVUsNEJBQVFBLFFBQVE4RCxTQUFTZ1IsV0FBekI7QUFDSDtBQUNELG9CQUFJakMsTUFBSixFQUFZO0FBQ1IsMkJBQU9oUCxNQUFNSSxHQUFOLENBQVVqRSxLQUFWLENBQVA7QUFDSDtBQUNELG9CQUFJcUIsVUFBVXdDLE1BQU03QyxJQUFOLENBQVcsU0FBWCxFQUFzQlAsV0FBdEIsRUFBVixFQUErQ3FELFNBQVN1UCxPQUF4RCxDQUFKLEVBQXNFO0FBQ2xFLDJCQUFPeFAsTUFBTWxCLElBQU4sQ0FBVzNDLEtBQVgsQ0FBUDtBQUNIOztBQUVELHVCQUFPLEtBQVA7QUFDSCxhQTFFTSxDQUFQO0FBMkVILFNBL2xCVzs7O0FBaW1CWjs7Ozs7O0FBTUFtVyxhQXZtQlksbUJBdW1CSjtBQUNKLG1CQUFPcFMsRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFNSCxRQUFRMkcsUUFBUXpHLEVBQUUsSUFBRixDQUFSLENBQWQ7QUFDQSxvQkFBTUQsV0FBV0QsTUFBTStHLElBQU4sQ0FBVyxhQUFYLENBQWpCO0FBQ0Esb0JBQUksUUFBTzlHLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJBLDZCQUFTK0MsS0FBVCxHQUFpQixJQUFqQjtBQUNBaEQsMEJBQU1JLEdBQU4sQ0FBVUosTUFBTUssV0FBTixDQUFrQixLQUFsQixDQUFWO0FBQ0g7QUFDSixhQVBNLENBQVA7QUFRSCxTQWhuQlc7OztBQWtuQlo7Ozs7O0FBS0FrUyxhQXZuQlksbUJBdW5CSjtBQUNKLG1CQUFPclMsRUFBRSxJQUFGLEVBQVFDLElBQVIsQ0FBYSxZQUFXO0FBQzNCLG9CQUFNSCxRQUFRMkcsUUFBUXpHLEVBQUUsSUFBRixDQUFSLENBQWQ7QUFDQSxvQkFBTUQsV0FBV0QsTUFBTStHLElBQU4sQ0FBVyxhQUFYLENBQWpCO0FBQ0Esb0JBQUksUUFBTzlHLFFBQVAseUNBQU9BLFFBQVAsT0FBb0IsUUFBeEIsRUFBa0M7QUFDOUJELDBCQUFNSyxXQUFOLENBQWtCLEtBQWxCLEVBQXlCTCxNQUFNSSxHQUFOLEVBQXpCO0FBQ0g7QUFDSixhQU5NLENBQVA7QUFPSCxTQS9uQlc7OztBQWlvQlo7Ozs7OztBQU1BOEcsV0F2b0JZLGlCQXVvQk47QUFDRixnQkFBTWxILFFBQVEyRyxRQUFRekcsRUFBRSxJQUFGLENBQVIsQ0FBZDtBQUNBLGdCQUFNRCxXQUFXRCxNQUFNK0csSUFBTixDQUFXLGFBQVgsQ0FBakI7QUFDQSxnQkFBTWlJLFNBQVNoUCxNQUFNaVAsRUFBTixDQUFTLDBFQUFULENBQWY7QUFDQSxnQkFBSTlTLFFBQVEsRUFBWjtBQUNBLGdCQUFJLFFBQU84RCxRQUFQLHlDQUFPQSxRQUFQLE9BQW9CLFFBQXhCLEVBQWtDO0FBQzlCVCxxR0FBcUYsSUFBckY7QUFDSDs7QUFFRDtBQUNBLGdCQUFJd1AsTUFBSixFQUFZO0FBQ1I3Uyx3QkFBUTZELE1BQU13UyxFQUFOLENBQVMsQ0FBVCxFQUFZcFMsR0FBWixFQUFSO0FBQ0gsYUFGRCxNQUVPLElBQUk1QyxVQUFVd0MsTUFBTTdDLElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixFQUFWLEVBQStDcUQsU0FBU3VQLE9BQXhELENBQUosRUFBc0U7QUFDekVyVCx3QkFBUTZELE1BQU13UyxFQUFOLENBQVMsQ0FBVCxFQUFZMVQsSUFBWixFQUFSO0FBQ0gsYUFGTSxNQUVBO0FBQ0hVLHNDQUFvQlEsTUFBTTdDLElBQU4sQ0FBVyxTQUFYLEVBQXNCUCxXQUF0QixFQUFwQiw2Q0FBaUdxRCxTQUFTUCxLQUExRztBQUNIOztBQUVELGdCQUFJTyxTQUFTbVEsSUFBVCxJQUFpQm5RLFNBQVNvQixZQUE5QixFQUE0QztBQUN4Q2xGLHdCQUFROEQsU0FBU3VFLFFBQWpCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsb0JBQUksRUFBRyxJQUFELENBQU9GLElBQVAsQ0FBWW5JLEtBQVosS0FBc0JpRixPQUFPakYsS0FBUCxNQUFrQixDQUExQyxLQUFnRDhELFNBQVM4RCxNQUFULEtBQW9CLE9BQXhFLEVBQWlGO0FBQzdFLDJCQUFPLEVBQVA7QUFDSDtBQUNELG9CQUFJNUgsVUFBVSxFQUFWLElBQWdCOEQsU0FBU2tELFFBQVQsS0FBc0IsSUFBMUMsRUFBZ0Q7QUFDNUNsRCw2QkFBUytDLEtBQVQsR0FBaUIsSUFBakI7QUFDQTdHLDRCQUFRK0csZ0JBQWdCL0csS0FBaEIsRUFBdUI4RCxRQUF2QixDQUFSO0FBQ0g7QUFDRCxvQkFBSUEsU0FBU3NQLE9BQVQsSUFBb0J0UCxTQUFTeVAsS0FBVCxLQUFtQixLQUEzQyxFQUFrRDtBQUM5Q3ZULDRCQUFRK0YsVUFBVS9GLEtBQVYsRUFBaUI4RCxRQUFqQixDQUFSO0FBQ0g7QUFDRDlELHdCQUFRdUgsVUFBVXZILEtBQVYsRUFBaUI4RCxTQUFTdUIsSUFBMUIsRUFBZ0N2QixTQUFTYSxJQUF6QyxDQUFSO0FBQ0g7O0FBRUQsZ0JBQUlNLE9BQU9qRixLQUFQLE1BQWtCLENBQWxCLElBQXVCOEQsU0FBU3lDLEtBQVQsS0FBbUIsTUFBOUMsRUFBc0Q7QUFDbER2Ryx3QkFBUSxHQUFSO0FBQ0g7QUFDRCxnQkFBSThELFNBQVNzTyxZQUFiLEVBQTJCO0FBQ3ZCcFMsd0JBQVFxSCxTQUFTckgsS0FBVCxFQUFnQjhELFNBQVNzTyxZQUF6QixDQUFSO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLG1CQUFPcFMsS0FBUDtBQUNILFNBbnJCVzs7O0FBcXJCWjs7Ozs7O0FBTUFzVyxvQkEzckJZLDBCQTJyQkc7QUFDWDtBQUNBLGdCQUFJLENBQUMsS0FBS3JWLGNBQUwsQ0FBb0IsR0FBcEIsQ0FBRCxJQUE2QixFQUFFLFdBQVcsS0FBSyxDQUFMLENBQWIsQ0FBakMsRUFBd0Q7QUFDcERvQywyQkFBVyxzREFBWDtBQUNIOztBQUVELG1CQUFPLEtBQUssQ0FBTCxFQUFRckQsS0FBZjtBQUNILFNBbHNCVzs7O0FBb3NCWjs7Ozs7OztBQU9BdVcsaUJBM3NCWSx1QkEyc0JBO0FBQ1IsbUJBQU94RixrQkFBa0IsS0FBbEIsRUFBeUIsSUFBekIsQ0FBUDtBQUNILFNBN3NCVzs7O0FBK3NCWjs7Ozs7OztBQU9BeUYsZ0JBdHRCWSxzQkFzdEJEO0FBQ1AsbUJBQU96RixrQkFBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBUDtBQUNILFNBeHRCVzs7O0FBMHRCWjs7Ozs7QUFLQTBGLG1CQS90QlkseUJBK3RCRTtBQUNWLGdCQUFNNVMsUUFBUTJHLFFBQVF6RyxFQUFFLElBQUYsQ0FBUixDQUFkOztBQUVBLG1CQUFPRixNQUFNd1MsRUFBTixDQUFTLENBQVQsRUFBWXpMLElBQVosQ0FBaUIsYUFBakIsQ0FBUDtBQUNIO0FBbnVCVyxLQUFoQjs7QUFzdUJBOzs7QUFHQTdHLE1BQUVtUCxFQUFGLENBQUtoUCxXQUFMLEdBQW1CLFVBQVN3UyxNQUFULEVBQTBCO0FBQ3pDLFlBQUloRSxRQUFRZ0UsTUFBUixDQUFKLEVBQXFCO0FBQUEsOENBRGNDLElBQ2Q7QUFEY0Esb0JBQ2Q7QUFBQTs7QUFDakIsbUJBQU9qRSxRQUFRZ0UsTUFBUixFQUFnQkUsS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJELElBQTVCLENBQVA7QUFDSDs7QUFFRCxZQUFJLFFBQU9ELE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsQ0FBQ0EsTUFBbkMsRUFBMkM7QUFDdkM7QUFDQSxtQkFBT2hFLFFBQVEzRixJQUFSLENBQWE2SixLQUFiLENBQW1CLElBQW5CLEVBQXlCLENBQUNGLE1BQUQsQ0FBekIsQ0FBUDtBQUNIOztBQUVEclQsZ0NBQXNCcVQsTUFBdEIsd0NBQWlFLElBQWpFO0FBQ0gsS0FYRDs7QUFhQTs7Ozs7O0FBTUEzUyxNQUFFbVAsRUFBRixDQUFLaFAsV0FBTCxDQUFpQmlQLFFBQWpCLEdBQTRCO0FBQ3hCOzs7Ozs7OztBQVFBN04sY0FBTSxHQVRrQjs7QUFXeEI7Ozs7QUFJQStPLGNBQU0sS0Fma0I7O0FBaUJ4Qjs7Ozs7O0FBTUFuTSxnQkFBUSxHQXZCZ0I7O0FBeUJ4Qjs7OztBQUlBN0MsY0FBTSxHQTdCa0I7O0FBK0J4Qjs7OztBQUlBRCxnQkFBUSxJQW5DZ0I7O0FBcUN4Qjs7Ozs7QUFLQVksZUFBTyxFQTFDaUI7O0FBNEN4Qjs7OztBQUlBRyxlQUFPLEdBaERpQjs7QUFrRHhCOzs7Ozs7Ozs7O0FBVUFELGNBQU0sR0E1RGtCOztBQThEeEI7Ozs7QUFJQUQsaUJBQVMsRUFsRWU7O0FBb0V4Qjs7Ozs7QUFLQXNFLGlCQUFTLElBekVlOztBQTJFeEI7Ozs7QUFJQWxHLGNBQU0sa0JBL0VrQjs7QUFpRnhCOzs7O0FBSUFELGNBQU0sbUJBckZrQjs7QUF1RnhCOzs7QUFHQVcsY0FBTSxJQTFGa0I7O0FBNEZ4Qjs7OztBQUlBa1AsY0FBTSxJQWhHa0I7O0FBa0d4Qjs7Ozs7O0FBTUE7Ozs7O0FBS0EvTyxzQkFBYyxJQTdHVTs7QUErR3hCOzs7O0FBSUFDLHNCQUFjLElBbkhVOztBQXFIeEI7Ozs7QUFJQTJQLHFCQUFhLElBekhXOztBQTJIeEI7OztBQUdBNUksZUFBTyxLQTlIaUI7O0FBZ0l4Qjs7Ozs7Ozs7Ozs7Ozs7QUFjQXZELGdCQUFRLEdBOUlnQjs7QUFnSnhCOzs7Ozs7O0FBT0FLLGNBQU0sSUF2SmtCOztBQXlKeEI7Ozs7OztBQU1BaEMsa0JBQVUsSUEvSmM7O0FBaUt4Qjs7Ozs7O0FBTUE7QUFDQVksZ0JBQVEsT0F4S2dCOztBQTBLeEI7Ozs7O0FBS0FyQixlQUFPLE9BL0tpQjs7QUFpTHhCOzs7O0FBSUFnTixlQUFPLElBckxpQjs7QUF1THhCOzs7O0FBSUFsRSxpQkFBUyxLQTNMZTs7QUE2THhCOzs7Ozs7QUFNQTBFLG1CQUFXLElBbk1hOztBQXFNeEI7Ozs7QUFJQTRCLHVCQUFlLEtBek1TOztBQTJNeEI7Ozs7OztBQU1BdkQsc0JBQWMsSUFqTlU7O0FBbU54Qjs7OztBQUlBN08sZUFBTztBQXZOaUIsS0FBNUI7O0FBME5BeEssdUJBQW1CO0FBQUEsZUFBTWdMLEVBQUVtUCxFQUFGLENBQUtoUCxXQUFMLENBQWlCaVAsUUFBdkI7QUFBQSxLQUFuQjs7QUFFQTs7O0FBR0F0YSxpQkFBYSxvQkFBQ21ILEtBQUQsRUFBUTJTLE9BQVIsRUFBb0I7QUFDN0IsWUFBSTFTLFlBQVlELEtBQVosS0FBc0JBLFVBQVUsSUFBcEMsRUFBMEM7QUFDdEMsbUJBQU8sSUFBUDtBQUNIOztBQUVELFlBQU04RCxXQUFXQyxFQUFFa1AsTUFBRixDQUFTLEVBQVQsRUFBYWxQLEVBQUVtUCxFQUFGLENBQUtoUCxXQUFMLENBQWlCaVAsUUFBOUIsRUFBd0MsRUFBRXJMLE9BQU8sS0FBVCxFQUF4QyxFQUEwRDZLLE9BQTFELENBQWpCO0FBQ0EzUyxnQkFBUUEsTUFBTTBCLFFBQU4sRUFBUjtBQUNBMUIsZ0JBQVFtSCxXQUFXbkgsS0FBWCxDQUFSO0FBQ0EsWUFBSWlGLE9BQU9qRixLQUFQLElBQWdCLENBQXBCLEVBQXVCO0FBQ25COEQscUJBQVNhLElBQVQsR0FBZ0IsR0FBaEI7QUFDSDs7QUFFRCxZQUFJYixTQUFTaUIsSUFBVCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QixnQkFBTVYsT0FBT1AsU0FBU08sSUFBVCxDQUFjM0MsUUFBZCxHQUF5QkksS0FBekIsQ0FBK0IsR0FBL0IsQ0FBYjtBQUNBLGdCQUFNc0MsT0FBUSxDQUFDTixTQUFTTSxJQUFWLElBQWtCTixTQUFTTSxJQUFULEtBQWtCLENBQXJDLEdBQTBDLEVBQTFDLEdBQStDTixTQUFTTSxJQUFULENBQWMxQyxRQUFkLEdBQXlCSSxLQUF6QixDQUErQixHQUEvQixDQUE1RDtBQUNBZ0MscUJBQVNpQixJQUFULEdBQWdCWixVQUFVQyxJQUFWLEVBQWdCQyxJQUFoQixDQUFoQjtBQUNIOztBQWhCNEIsMEJBaUJGOEYsVUFBVW5LLEtBQVYsRUFBaUI4RCxRQUFqQixDQWpCRTtBQUFBO0FBQUEsWUFpQnRCd0ssT0FqQnNCO0FBQUEsWUFpQmJDLE9BakJhOztBQW1CN0IsWUFBSSxDQUFDRCxPQUFELElBQVksQ0FBQ0MsT0FBakIsRUFBMEI7QUFDdEI7QUFDQXNJLDRCQUFnQix3QkFBaEI7QUFDQXhULHVDQUF5QnJELEtBQXpCLDRDQUFxRThELFNBQVNNLElBQTlFLG9CQUFpR04sU0FBU08sSUFBMUcsaUJBQTRIUCxTQUFTUCxLQUFySTtBQUNIO0FBQ0R2RCxnQkFBUTBJLFVBQVUxSSxLQUFWLEVBQWlCOEQsUUFBakIsQ0FBUjtBQUNBOUQsZ0JBQVF3SCxjQUFjeEgsS0FBZCxFQUFxQjhELFFBQXJCLENBQVI7QUFDQTlELGdCQUFRNkgsVUFBVTdILEtBQVYsRUFBaUI4RCxRQUFqQixDQUFSOztBQUVBLGVBQU85RCxLQUFQO0FBQ0gsS0E3QkQ7O0FBK0JBK0QsTUFBRW1QLEVBQUYsQ0FBS3JhLFVBQUwsR0FBa0JBLFVBQWxCOztBQUVBOzs7QUFHQUMsbUJBQWUsc0JBQUNrSCxLQUFELEVBQVEyUyxPQUFSLEVBQW9CO0FBQy9CLFlBQUkxUyxZQUFZRCxLQUFaLEtBQXNCQSxVQUFVLElBQXBDLEVBQTBDO0FBQ3RDLG1CQUFPLElBQVA7QUFDSDs7QUFFRCxZQUFNOEQsV0FBV0MsRUFBRWtQLE1BQUYsQ0FBUyxFQUFULEVBQWFsUCxFQUFFbVAsRUFBRixDQUFLaFAsV0FBTCxDQUFpQmlQLFFBQTlCLEVBQXdDLEVBQUVyTCxPQUFPLEtBQVQsRUFBeEMsRUFBMEQ2SyxPQUExRCxDQUFqQjtBQUNBLFlBQU0vTSw0QkFBMEI5QixTQUFTdUIsSUFBekM7QUFDQSxZQUFNVSxZQUFZLElBQUlMLE1BQUosUUFBZ0JFLE9BQWhCLFFBQTRCLElBQTVCLENBQWxCO0FBQ0E1RixnQkFBUUEsTUFBTTBCLFFBQU4sRUFBUjs7QUFFQSxZQUFJMUIsTUFBTTJHLE1BQU4sQ0FBYSxDQUFiLE1BQW9CLEdBQXhCLEVBQTZCO0FBQ3pCN0MscUJBQVNhLElBQVQsR0FBZ0IsR0FBaEI7QUFDSCxTQUZELE1BRU8sSUFBSWIsU0FBU2tELFFBQVQsSUFBcUJsRCxTQUFTa0QsUUFBVCxDQUFrQmxGLEtBQWxCLENBQXdCLEdBQXhCLEVBQTZCLENBQTdCLE1BQW9DOUIsTUFBTTJHLE1BQU4sQ0FBYSxDQUFiLENBQTdELEVBQThFO0FBQ2pGN0MscUJBQVNhLElBQVQsR0FBZ0IsR0FBaEI7QUFDQWIscUJBQVMrQyxLQUFULEdBQWlCLElBQWpCO0FBQ0E3RyxvQkFBUStHLGdCQUFnQi9HLEtBQWhCLEVBQXVCOEQsUUFBdkIsQ0FBUjtBQUNIO0FBQ0Q5RCxnQkFBUUEsTUFBTTRFLE9BQU4sQ0FBY21CLFNBQWQsRUFBeUIsRUFBekIsQ0FBUjtBQUNBL0YsZ0JBQVFBLE1BQU00RSxPQUFOLENBQWMsR0FBZCxFQUFtQixHQUFuQixDQUFSOztBQUVBLFlBQUlkLFNBQVNzTyxZQUFiLEVBQTJCO0FBQ3ZCcFMsb0JBQVFxSCxTQUFTckgsS0FBVCxFQUFnQjhELFNBQVNzTyxZQUF6QixDQUFSO0FBQ0g7O0FBRUQsZUFBT25OLE9BQU9qRixLQUFQLENBQVA7QUFDSCxLQXpCRDs7QUEyQkErRCxNQUFFbVAsRUFBRixDQUFLNEQsWUFBTCxHQUFvQmhlLFlBQXBCOztBQUVBOzs7Ozs7Ozs7OztBQVdBRSxlQUFXLGtCQUFDK2QsV0FBRCxFQUFvRDtBQUFBLFlBQXRDQywwQkFBc0MsdUVBQVQsSUFBUzs7QUFDM0QsWUFBTXpULFFBQVEsSUFBZCxDQUQyRCxDQUN2Qzs7QUFFcEIsWUFBSXJELHlCQUF5QjZXLFdBQXpCLEtBQXlDLENBQUNyVyxTQUFTcVcsV0FBVCxDQUExQyxJQUFtRWpXLFdBQVdpVyxXQUFYLENBQXZFLEVBQWdHO0FBQzVGMVQsd0ZBQTBFMFQsV0FBMUUsZUFBaUd4VCxLQUFqRztBQUNIOztBQUVEO0FBQ0EsWUFBSW9QLGdCQUFKO0FBQ0EsWUFBSXFFLDBCQUFKLEVBQWdDO0FBQzVCckUsc0JBQVU1TyxFQUFFa1AsTUFBRixDQUFTLEVBQVQsRUFBYWxQLEVBQUVtUCxFQUFGLENBQUtoUCxXQUFMLENBQWlCaVAsUUFBOUIsRUFBd0M0RCxXQUF4QyxDQUFWO0FBQ0gsU0FGRCxNQUVPO0FBQ0hwRSxzQkFBVW9FLFdBQVY7QUFDSDs7QUFFRCxZQUFNRSxzQkFBc0IsVUFBNUI7QUFDQSxZQUFNQywwQkFBMEIsUUFBaEM7QUFDQTtBQUNBLFlBQU1DLDRDQUE0Qyx3QkFBbEQ7QUFDQSxZQUFNQyw2QkFBNkIsc0JBQW5DOztBQUVBO0FBQ0EsWUFBSSxDQUFDL1YsVUFBVXNSLFFBQVFyTixJQUFsQixFQUF3QixDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixFQUFoQixDQUF4QixDQUFMLEVBQW1EO0FBQy9DakMsNklBQXFIc1AsUUFBUXJOLElBQTdILGVBQTZJL0IsS0FBN0k7QUFDSDs7QUFFRCxZQUFJLENBQUNoRCxvQkFBb0JvUyxRQUFRMEIsSUFBNUIsQ0FBRCxJQUFzQyxDQUFDL1QsVUFBVXFTLFFBQVEwQixJQUFsQixDQUEzQyxFQUFvRTtBQUNoRWhSLHlHQUFxRnNQLFFBQVEwQixJQUE3RixlQUE2RzlRLEtBQTdHO0FBQ0g7O0FBRUQsWUFBSSxDQUFDMFQsb0JBQW9COU8sSUFBcEIsQ0FBeUJ3SyxRQUFRekssTUFBakMsQ0FBTCxFQUErQztBQUFFO0FBQzdDN0UseUlBQXlIc1AsUUFBUXpLLE1BQWpJLGVBQW1KM0UsS0FBbko7QUFDSDs7QUFFRCxZQUFJLENBQUNsQyxVQUFVc1IsUUFBUXROLElBQWxCLEVBQXdCLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBeEIsQ0FBTCxFQUEwQztBQUN0Q2hDLHVIQUFtR3NQLFFBQVF0TixJQUEzRyxlQUEySDlCLEtBQTNIO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJb1AsUUFBUXROLElBQVIsS0FBaUJzTixRQUFRck4sSUFBN0IsRUFBbUM7QUFDL0JqQyx3R0FBd0ZzUCxRQUFRdE4sSUFBaEcsK0NBQTRJc04sUUFBUXJOLElBQXBKLGdDQUFxTC9CLEtBQXJMO0FBQ0g7O0FBRUQsWUFBSSxDQUFDeEQsT0FBTzRTLFFBQVF2TixNQUFmLENBQUQsSUFBMkIsQ0FBQ2pGLFNBQVN3UyxRQUFRdk4sTUFBakIsQ0FBaEMsRUFBMEQ7QUFDdEQvQiw2SEFBNkdzUCxRQUFRdk4sTUFBckgsZUFBdUk3QixLQUF2STtBQUNIOztBQUVELFlBQUlvUCxRQUFRM00sS0FBUixLQUFrQixFQUFsQixJQUF3QixDQUFDN0YsU0FBU3dTLFFBQVEzTSxLQUFqQixDQUE3QixFQUFzRDtBQUNsRDNDLHNHQUFzRnNQLFFBQVEzTSxLQUE5RixlQUErR3pDLEtBQS9HO0FBQ0g7O0FBRUQsWUFBSSxDQUFDbEMsVUFBVXNSLFFBQVF4TSxLQUFsQixFQUF5QixDQUFDLEdBQUQsRUFBTSxHQUFOLENBQXpCLENBQUwsRUFBMkM7QUFDdkM5QyxvSkFBZ0lzUCxRQUFReE0sS0FBeEksZUFBeUo1QyxLQUF6SjtBQUNIOztBQUVELFlBQUksQ0FBQ2xDLFVBQVVzUixRQUFRek0sSUFBbEIsRUFBd0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBeEIsQ0FBTCxFQUFvRDtBQUNoRDdDLGdMQUF3SnNQLFFBQVF6TSxJQUFoSyxlQUFnTDNDLEtBQWhMO0FBQ0g7O0FBRUQsWUFBSSxDQUFDcEQsU0FBU3dTLFFBQVExTSxPQUFqQixDQUFELElBQStCME0sUUFBUTFNLE9BQVIsS0FBb0IsRUFBcEIsS0FBMkIvRSxTQUFTeVIsUUFBUTFNLE9BQWpCLEVBQTBCLEdBQTFCLEtBQWtDaVIsd0JBQXdCL08sSUFBeEIsQ0FBNkJ3SyxRQUFRMU0sT0FBckMsQ0FBN0QsQ0FBbkMsRUFBaUo7QUFDN0k1QyxnS0FBOElzUCxRQUFRMU0sT0FBdEosZUFBeUsxQyxLQUF6SztBQUNIOztBQUVELFlBQUksQ0FBQ3hELE9BQU80UyxRQUFRcEksT0FBZixDQUFELElBQTRCLENBQUNsSixVQUFVc1IsUUFBUXBJLE9BQWxCLEVBQTJCLENBQUMsU0FBRCxFQUFZLE9BQVosRUFBcUIsUUFBckIsQ0FBM0IsQ0FBakMsRUFBNkY7QUFDekZsSCxxSkFBK0hzUCxRQUFRcEksT0FBdkksZUFBMEpoSCxLQUExSjtBQUNIOztBQUVELFlBQUksQ0FBQ3BELFNBQVN3UyxRQUFRdE8sSUFBakIsQ0FBRCxJQUEyQixDQUFDOFMsMENBQTBDaFAsSUFBMUMsQ0FBK0N3SyxRQUFRdE8sSUFBdkQsQ0FBaEMsRUFBOEY7QUFDMUZoQiwwSkFBMElzUCxRQUFRdE8sSUFBbEosZUFBa0tkLEtBQWxLO0FBQ0g7O0FBRUQsWUFBSSxDQUFDcEQsU0FBU3dTLFFBQVF2TyxJQUFqQixDQUFELElBQTJCLENBQUMrUywwQ0FBMENoUCxJQUExQyxDQUErQ3dLLFFBQVF2TyxJQUF2RCxDQUFoQyxFQUE4RjtBQUMxRmYsMEpBQTBJc1AsUUFBUXZPLElBQWxKLGVBQWtLYixLQUFsSztBQUNIOztBQUVELFlBQUlxUSxXQUFXakIsUUFBUXZPLElBQW5CLElBQTJCd1AsV0FBV2pCLFFBQVF0TyxJQUFuQixDQUEvQixFQUF5RDtBQUNyRGhCLDRIQUE0R3NQLFFBQVF2TyxJQUFwSCwyQ0FBNEp1TyxRQUFRdE8sSUFBcEssU0FBOEtkLEtBQTlLO0FBQ0g7O0FBRUQsWUFBSSxDQUFDeEQsT0FBTzRTLFFBQVE1TixJQUFmLENBQUQsS0FBMEIsQ0FBQzVFLFNBQVN3UyxRQUFRNU4sSUFBakIsQ0FBRCxJQUEyQixDQUFDa1Msb0JBQW9COU8sSUFBcEIsQ0FBeUJ3SyxRQUFRNU4sSUFBakMsQ0FBdEQsQ0FBSixFQUFtRztBQUMvRjFCLGdJQUFnSHNQLFFBQVE1TixJQUF4SCxlQUF3SXhCLEtBQXhJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDb1AsUUFBUTNKLElBQVQsSUFBaUIsQ0FBQ2pKLE9BQU80UyxRQUFRNU4sSUFBZixDQUF0QixFQUE0QztBQUN4Q3ZCLGlHQUErRW1QLFFBQVE1TixJQUF2RixTQUFpR3hCLEtBQWpHO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJOFQsU0FBU3JWLGNBQWMyUSxRQUFRdk8sSUFBdEIsQ0FBYjtBQUNBLFlBQUlrVCxTQUFTdFYsY0FBYzJRLFFBQVF0TyxJQUF0QixDQUFiO0FBQ0FnVCxpQkFBU3RYLE9BQU9zWCxNQUFQLElBQWUsQ0FBZixHQUFpQkEsTUFBMUI7QUFDQUMsaUJBQVN2WCxPQUFPdVgsTUFBUCxJQUFlLENBQWYsR0FBaUJBLE1BQTFCO0FBQ0EsWUFBTUMsdUJBQXVCL1MsS0FBS0MsR0FBTCxDQUFTNFMsTUFBVCxFQUFpQkMsTUFBakIsQ0FBN0I7QUFDQSxZQUFJLENBQUN2WCxPQUFPNFMsUUFBUTVOLElBQWYsQ0FBRCxJQUNDLENBQUNsRCxZQUFZOFEsUUFBUXZPLElBQXBCLEtBQTZCdkMsWUFBWThRLFFBQVF0TyxJQUFwQixDQUE5QixLQUE0RGtULHlCQUF5QnRTLE9BQU8wTixRQUFRNU4sSUFBZixDQUQxRixFQUNpSDtBQUM3R3ZCLDhDQUE4Qm1QLFFBQVE1TixJQUF0QywyREFBOEY0TixRQUFRdk8sSUFBdEcsd0JBQTJIdU8sUUFBUXRPLElBQW5JLFNBQTZJZCxLQUE3STtBQUNIOztBQUVELFlBQUksQ0FBQ3hELE9BQU80UyxRQUFRc0IsSUFBZixDQUFELEtBQTBCLENBQUM5VCxTQUFTd1MsUUFBUXNCLElBQWpCLENBQUQsSUFBMkIsQ0FBQ2dELG9CQUFvQjlPLElBQXBCLENBQXlCd0ssUUFBUXNCLElBQWpDLENBQXRELENBQUosRUFBbUc7QUFDL0Y1USxpSUFBaUhzUCxRQUFRc0IsSUFBekgsZUFBeUkxUSxLQUF6STtBQUNIOztBQUVEO0FBQ0EsWUFBSSxDQUFDeEQsT0FBTzRTLFFBQVFzQixJQUFmLENBQUQsSUFBeUIsQ0FBQ2xVLE9BQU80UyxRQUFRNU4sSUFBZixDQUExQixJQUFrREUsT0FBTzBOLFFBQVE1TixJQUFmLElBQXVCRSxPQUFPME4sUUFBUXNCLElBQWYsQ0FBN0UsRUFBbUc7QUFDL0Y1USw4R0FBOEZzUCxRQUFRc0IsSUFBdEcsd0NBQTJJdEIsUUFBUTVOLElBQW5KLGVBQW1LeEIsS0FBbks7QUFDSDs7QUFFRCxZQUFJLENBQUN4RCxPQUFPNFMsUUFBUXpOLFlBQWYsQ0FBRCxJQUFpQyxDQUFDa1MsMkJBQTJCalAsSUFBM0IsQ0FBZ0N3SyxRQUFRek4sWUFBeEMsQ0FBdEMsRUFBNkY7QUFDekY3QiwySUFBMkhzUCxRQUFRek4sWUFBbkksZUFBMkozQixLQUEzSjtBQUNIOztBQUVELFlBQUksQ0FBQ3hELE9BQU80UyxRQUFReE4sWUFBZixDQUFELElBQWlDLENBQUM4UixvQkFBb0I5TyxJQUFwQixDQUF5QndLLFFBQVF4TixZQUFqQyxDQUF0QyxFQUFzRjtBQUNsRjlCLGdJQUFnSHNQLFFBQVF4TixZQUF4SCxlQUFnSjVCLEtBQWhKO0FBQ0g7O0FBRUQsWUFBSSxDQUFDeEQsT0FBTzRTLFFBQVFtQyxXQUFmLENBQUQsSUFBZ0MsQ0FBQzNVLFNBQVN3UyxRQUFRbUMsV0FBakIsQ0FBckMsRUFBb0U7QUFDaEV6Uix5R0FBeUZzUCxRQUFRbUMsV0FBakcsZUFBd0h2UixLQUF4SDtBQUNIOztBQUVELFlBQUksQ0FBQ2hELG9CQUFvQm9TLFFBQVF6RyxLQUE1QixDQUFELElBQXVDLENBQUM1TCxVQUFVcVMsUUFBUXpHLEtBQWxCLENBQTVDLEVBQXNFO0FBQ2xFN0ksa0lBQThHc1AsUUFBUXpHLEtBQXRILGVBQXVJM0ksS0FBdkk7QUFDSDs7QUFFRCxZQUFJLENBQUNsQyxVQUFVc1IsUUFBUWhLLE1BQWxCLEVBQTBCLENBQzNCLEdBRDJCLEVBRTNCLEdBRjJCLEVBRzNCLEdBSDJCLEVBSTNCLEdBSjJCLEVBSzNCLEdBTDJCLEVBTTNCLEdBTjJCLEVBTzNCLEdBUDJCLEVBUTNCLEdBUjJCLEVBUzNCLEdBVDJCLEVBVTNCLEtBVjJCLEVBVzNCLEtBWDJCLEVBWTNCLEtBWjJCLEVBYTNCLEtBYjJCLENBQTFCLENBQUwsRUFjSTtBQUNBdEYsNk5BQW1Mc1AsUUFBUWhLLE1BQTNMLGVBQTZNcEYsS0FBN007QUFDSDs7QUFFRCxZQUFJLENBQUNoRCxvQkFBb0JvUyxRQUFRM0osSUFBNUIsQ0FBRCxJQUFzQyxDQUFDMUksVUFBVXFTLFFBQVEzSixJQUFsQixDQUEzQyxFQUFvRTtBQUNoRTNGLGlJQUE2R3NQLFFBQVEzSixJQUFySCxlQUFxSXpGLEtBQXJJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDeEQsT0FBTzRTLFFBQVEzTCxRQUFmLENBQUQsSUFBNkIsQ0FBQzNGLFVBQVVzUixRQUFRM0wsUUFBbEIsRUFBNEIsQ0FBQyxLQUFELEVBQVEsS0FBUixFQUFlLEtBQWYsRUFBc0IsS0FBdEIsQ0FBNUIsQ0FBbEMsRUFBNkY7QUFDekYzRCx5SkFBaUlzUCxRQUFRM0wsUUFBekksZUFBNkp6RCxLQUE3SjtBQUNIOztBQUVELFlBQUksQ0FBQ2xDLFVBQVVzUixRQUFRL0ssTUFBbEIsRUFBMEIsQ0FBQyxPQUFELEVBQVUsT0FBVixFQUFtQixRQUFuQixFQUE2QixNQUE3QixDQUExQixDQUFMLEVBQXNFO0FBQ2xFdkUsMEpBQWtJc1AsUUFBUS9LLE1BQTFJLGVBQTRKckUsS0FBNUo7QUFDSDs7QUFFRCxZQUFJLENBQUNsQyxVQUFVc1IsUUFBUXBNLEtBQWxCLEVBQXlCLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsTUFBbEIsQ0FBekIsQ0FBTCxFQUEwRDtBQUN0RGxELDBJQUFvSHNQLFFBQVFwTSxLQUE1SCxlQUE2SWhELEtBQTdJO0FBQ0g7O0FBRUQsWUFBSSxDQUFDaEQsb0JBQW9Cb1MsUUFBUVksS0FBNUIsQ0FBRCxJQUF1QyxDQUFDalQsVUFBVXFTLFFBQVFZLEtBQWxCLENBQTVDLEVBQXNFO0FBQ2xFbFEsbUlBQStHc1AsUUFBUVksS0FBdkgsZUFBd0loUSxLQUF4STtBQUNIOztBQUVELFlBQUksQ0FBQ2hELG9CQUFvQm9TLFFBQVF0RCxPQUE1QixDQUFELElBQXlDLENBQUMvTyxVQUFVcVMsUUFBUXRELE9BQWxCLENBQTlDLEVBQTBFO0FBQ3RFaE0sK0hBQTJHc1AsUUFBUXRELE9BQW5ILGVBQXNJOUwsS0FBdEk7QUFDSDs7QUFFRCxZQUFJLENBQUN4RCxPQUFPNFMsUUFBUW9CLFNBQWYsQ0FBRCxJQUErQnBCLFFBQVFvQixTQUFSLEtBQXNCLEVBQXRCLElBQTRCLENBQUNvRCwwQ0FBMENoUCxJQUExQyxDQUErQ3dLLFFBQVFvQixTQUF2RCxDQUFoRSxFQUFvSTtBQUNoSTFRLGtLQUFrSnNQLFFBQVFvQixTQUExSixlQUErS3hRLEtBQS9LO0FBQ0g7O0FBRUQsWUFBSSxDQUFDaEQsb0JBQW9Cb1MsUUFBUWdELGFBQTVCLENBQUQsSUFBK0MsQ0FBQ3JWLFVBQVVxUyxRQUFRZ0QsYUFBbEIsQ0FBcEQsRUFBc0Y7QUFDbEZ0Uyw4SUFBMEhzUCxRQUFRZ0QsYUFBbEksZUFBMkpwUyxLQUEzSjtBQUNIOztBQUVELFlBQUksQ0FBQ3hELE9BQU80UyxRQUFRUCxZQUFmLENBQUQsSUFBaUMsQ0FBQy9RLFVBQVVzUixRQUFRUCxZQUFsQixFQUFnQyxDQUNsRSxHQURrRSxFQUVsRSxJQUZrRSxFQUdsRSxHQUhrRSxFQUlsRSxJQUprRSxFQUtsRSxJQUxrRSxFQU1sRSxJQU5rRSxDQUFoQyxDQUF0QyxFQU9JO0FBQ0EvTyxzS0FBMElzUCxRQUFRUCxZQUFsSixlQUEwSzdPLEtBQTFLO0FBQ0g7O0FBRUQsWUFBSSxDQUFDaEQsb0JBQW9Cb1MsUUFBUXBQLEtBQTVCLENBQUQsSUFBdUMsQ0FBQ2pELFVBQVVxUyxRQUFRcFAsS0FBbEIsQ0FBNUMsRUFBc0U7QUFDbEVGLGdIQUE0RnNQLFFBQVFwUCxLQUFwRyxlQUFxSEEsS0FBckg7QUFDSDtBQUNKLEtBM0xEOztBQTZMQVEsTUFBRW1QLEVBQUYsQ0FBS2xhLFFBQUwsR0FBZ0JBLFFBQWhCOztBQUVBOzs7Ozs7QUFNQUMsdUJBQW1CLDBCQUFTMFosT0FBVCxFQUFrQjtBQUNqQyxZQUFJc0MsVUFBVSxJQUFkO0FBQ0EsWUFBSTtBQUNBamMscUJBQVMyWixPQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU82RSxLQUFQLEVBQWM7QUFDVnZDLHNCQUFVLEtBQVY7QUFDSDs7QUFFRCxlQUFPQSxPQUFQO0FBQ0gsS0FWRDs7QUFZQTs7Ozs7Ozs7QUFRQSxhQUFTd0MsaUJBQVQsQ0FBMkJDLFNBQTNCLEVBQXNDQyxNQUF0QyxFQUE4QztBQUMxQzs7O0FBR0EsZUFBTyxJQUFJQyxXQUFKLENBQWdCRixTQUFoQixFQUEyQixFQUFFQyxjQUFGLEVBQVVFLFNBQVMsS0FBbkIsRUFBMEJDLFlBQVksS0FBdEMsRUFBM0IsQ0FBUCxDQUowQyxDQUl3QztBQUNyRjs7QUFFRDs7Ozs7OztBQU9BLGFBQVNqQixlQUFULENBQXlCYSxTQUF6QixFQUFtRDtBQUFBLFlBQWZDLE1BQWUsdUVBQU4sSUFBTTs7QUFDL0MsZUFBT25WLFNBQVN1VixhQUFULENBQXVCTixrQkFBa0JDLFNBQWxCLEVBQTZCQyxNQUE3QixDQUF2QixDQUFQO0FBQ0g7O0FBRUQ7OztBQUdBLEtBQUMsWUFBVztBQUNSLFlBQUksT0FBT3BlLE9BQU9xZSxXQUFkLEtBQThCLFVBQWxDLEVBQThDO0FBQzFDLG1CQUFPLEtBQVA7QUFDSDs7QUFFRCxpQkFBU0EsV0FBVCxDQUFxQkksS0FBckIsRUFBNEJDLE1BQTVCLEVBQW9DO0FBQ2hDQSxxQkFBU0EsVUFBVSxFQUFFSixTQUFTLEtBQVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNTyxNQUFNMVYsU0FBUzJWLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBRCxnQkFBSUUsZUFBSixDQUFvQkosS0FBcEIsRUFBMkJDLE9BQU9KLE9BQWxDLEVBQTJDSSxPQUFPSCxVQUFsRCxFQUE4REcsT0FBT04sTUFBckU7QUFDQSxtQkFBT08sR0FBUDtBQUNIOztBQUVETixvQkFBWW5XLFNBQVosR0FBd0JsSSxPQUFPOGUsS0FBUCxDQUFhNVcsU0FBckM7QUFDQWxJLGVBQU9xZSxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQTdtR0EsQ0FBRDs7QUErbUdBOzs7a0JBR2U7QUFDWFUsWUFBVXpmLFVBREM7QUFFWDBmLGNBQVV6ZixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLHNCQUpXLEVBSUQ7QUFDVkMsc0NBTFcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIGF1dG9OdW1lcmljLmpzXG4qIEBhdXRob3I6IEJvYiBLbm90aGVcbiogQGNvbnRyaWJ1dG9yczogU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnNcbiogQHZlcnNpb246IDIuMCAtIDIwMTYtMTEtMjcgVVRDIDExOjAwXG4qXG4qIENyZWF0ZWQgYnkgUm9iZXJ0IEouIEtub3RoZSBvbiAyMDA5LTA4LTA5LiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbipcbiogQ29weXJpZ2h0IChjKSAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xuKlxuKiBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxubGV0IGF1dG9Gb3JtYXQ7XG5sZXQgYXV0b1VuRm9ybWF0O1xubGV0IGdldERlZmF1bHRDb25maWc7XG5sZXQgdmFsaWRhdGU7XG5sZXQgYXJlU2V0dGluZ3NWYWxpZDtcblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS9Db21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG59IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG59XG59KCQgPT4ge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGtleUNvZGUgPSB7XG4gICAgICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgICAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICAgICAgRW50ZXI6ICAgICAgICAgIDEzLFxuICAgICAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICAgICAgQWx0OiAgICAgICAgICAgIDE4LFxuICAgICAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICAgICAgRXNjOiAgICAgICAgICAgIDI3LFxuICAgICAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICAgICAgUGFnZURvd246ICAgICAgIDM0LFxuICAgICAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICAgICAgTGVmdEFycm93OiAgICAgIDM3LFxuICAgICAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICAgICAgRG93bkFycm93OiAgICAgIDQwLFxuICAgICAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICAgICAgbnVtMDogICAgICAgICAgIDQ4LFxuICAgICAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICAgICAgbnVtMzogICAgICAgICAgIDUxLFxuICAgICAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICAgICAgbnVtNjogICAgICAgICAgIDU0LFxuICAgICAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICAgICAgbnVtOTogICAgICAgICAgIDU3LFxuICAgICAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICAgICAgYzogICAgICAgICAgICAgIDY3LFxuICAgICAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICAgICAgZjogICAgICAgICAgICAgIDcwLFxuICAgICAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICAgICAgaTogICAgICAgICAgICAgIDczLFxuICAgICAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICAgICAgbDogICAgICAgICAgICAgIDc2LFxuICAgICAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICAgICAgbzogICAgICAgICAgICAgIDc5LFxuICAgICAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICAgICAgcjogICAgICAgICAgICAgIDgyLFxuICAgICAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICAgICAgdTogICAgICAgICAgICAgIDg1LFxuICAgICAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICAgICAgeDogICAgICAgICAgICAgIDg4LFxuICAgICAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICAgICAgV2luZG93czogICAgICAgIDkxLFxuICAgICAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICAgICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgICAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICAgICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICAgICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICAgICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICAgICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICAgICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICAgICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICAgICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICAgICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICAgICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICAgICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICAgICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICAgICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICAgICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICAgICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICAgICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICAgICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICAgICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICAgICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICAgICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICAgICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICAgICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICAgICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICAgICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICAgICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICAgICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICAgICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICAgICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICAgICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICAgICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICAgICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICAgICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICAgICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICAgICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICAgICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICAgICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICAgICAgQ29tbWFuZDogICAgICAgIDIyNCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGFyclxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzRGVjaW1hbHMoc3RyKSB7XG4gICAgICAgIGNvbnN0IFssIGRlY2ltYWxQYXJ0XSA9IHN0ci5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cbiAgICAgKiBSZXR1cm4gYG51bGxgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7bnVsbHxpbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBnZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gdGhhdC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGF0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyBtZXNzYWdlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSwgZGVidWcgPSB0cnVlKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gaGFuZGxlIHdhcm5pbmcgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHN1cHByZXNzV2FybmluZ3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc3VwcHJlc3NXYXJuaW5ncykge1xuICAgICAgICAgICAgLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIGNhbGxiYWNrcyBpbiBwYXJhbWV0ZXJzIGlmIGFueVxuICAgICAqIGFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrcygkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgdk1pbiB2TWF4IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpIHtcbiAgICAgICAgbGV0IHZNYXhMZW5ndGggPSAwO1xuICAgICAgICBsZXQgdk1pbkxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh2TWF4WzFdKSB7XG4gICAgICAgICAgICB2TWF4TGVuZ3RoID0gdk1heFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZNaW5bMV0pIHtcbiAgICAgICAgICAgIHZNaW5MZW5ndGggPSB2TWluWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2TWF4TGVuZ3RoLCB2TWluTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJpbmcgdXNlciBkZWZpbmVkIG9wdGlvbnMgZm9yIGZ1cnRoZXIgdXNhZ2VcbiAgICAgKiBtZXJnZSB0aGVtIHdpdGggZGVmYXVsdHMgYXBwcm9wcmlhdGVseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Db2RlKCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgc2V0dGluZ3MuYU5lZyA9IHNldHRpbmdzLnZNaW4gPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZNYXhbMF0gPSB2TWF4WzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHZNaW5bMF0gPSB2TWluWzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heCh2TWF4WzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heCh2TWluWzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICAgICAgc2V0dGluZ3Mub0RlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gTnVtYmVyKHNldHRpbmdzLm1EZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG5cbiAgICAgICAgLy8gc2V0IGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleVxuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjID09PSBudWxsICYmIHNldHRpbmdzLm1EZWMgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gJy4nICYmIHNldHRpbmdzLmFTZXAgIT09ICcsJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdERlYyA9ICcsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuYURlYyA9PT0gJywnICYmIHNldHRpbmdzLmFTZXAgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdERlYyA9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHJlZ2V4cHMgZm9yIGF1dG9TdHJpcFxuICAgICAgICBjb25zdCBhTmVnUmVnID0gc2V0dGluZ3MuYU5lZyA/YChbLVxcXFwke3NldHRpbmdzLmFOZWd9XT8pYCA6JygtPyknO1xuICAgICAgICBzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwID0gYU5lZ1JlZztcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7KHNldHRpbmdzLmFOZWc/YFxcXFwke3NldHRpbmdzLmFOZWd9YDonJyl9XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZF0uKj8oXFxcXGR8XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZClgKTtcbiAgICAgICAgc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAoXFxcXGRcXFxcJHtzZXR0aW5ncy5hRGVjfT8pW15cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXVxcXFxEKiRgKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcbiAgICAgICAgc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfSg/OlxcXFwke3NldHRpbmdzLmFEZWN9PyhcXFxcZCtcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKyl8KFxcXFxkKig/OlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQqKT8pKWApO1xuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdHJpcCBhbGwgdW53YW50ZWQgY2hhcmFjdGVycyBhbmQgbGVhdmUgb25seSBhIG51bWJlciBhbGVydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9TdHJpcChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYVNpZ24gIT09ICcnKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU2lnbiwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU3VmZml4KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc3VmZml4XG4gICAgICAgICAgICB3aGlsZSAoY29udGFpbnMocywgc2V0dGluZ3MuYVN1ZmZpeCkpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTdWZmaXgsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBGaXJzdEF1dG9TdHJpcCwgJyQxJDInKTtcblxuICAgICAgICBpZiAoKHNldHRpbmdzLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnICE9PSAncCcpKSAmJiBjb250YWlucyhzLCAnLScpICYmIHMgIT09ICcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XG5cbiAgICAgICAgLy8gdGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCwgJycpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsdERlYywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgb25seSBudW1iZXIgc3RyaW5nXG4gICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKHNldHRpbmdzLm51bVJlZ0F1dG9TdHJpcCk7XG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sWmVybyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MuYU5lZykpIHtcbiAgICAgICAgICAgICAgICBuU2lnbiA9IHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzID0gYCR7blNpZ259JHttb2RpZmllZEludGVnZXJQYXJ0fSR7aXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpPycnOnNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3MubFplcm8gPT09ICdkZW55JykgfHwgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnICYmIHNldHRpbmdzLm9uT2ZmID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoaXMgcmVnZXggdmVyc2lvbiBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZHwkKWAgZW50aXJlbHkgY2xlYXIgdGhlIGlucHV0IG9uIGJsdXJcbiAgICAgICAgICAgIGxldCBzdHJpcFJlZyA9IGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkKWA7XG4gICAgICAgICAgICBzdHJpcFJlZyA9IG5ldyBSZWdFeHAoc3RyaXBSZWcpO1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzdHJpcFJlZywgJyQxJDInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBsYWNlcyBvciByZW1vdmVzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoKHNldHRpbmdzLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpKSB7XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBsb2NhbGUgZm9ybWF0IHRvIEphdmFzY3JpcHQgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWQgb2YgY3VycmVuY3kgc2lnbnMgYWxsb3dlZFxuICAgICAqICcxMjM0LjU2JyAgICBPS1xuICAgICAqICctMTIzNC41NicgICBPS1xuICAgICAqICcxMjM0LjU2LScgICBPS1xuICAgICAqICcxMjM0LDU2JyAgICBPS1xuICAgICAqICctMTIzNCw1NicgICBPS1xuICAgICAqICcxMjM0LDU2LScgICBPS1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Mb2NhbGUocykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudFxuICAgICAqIHNlZSBcImxvY2FsZU91dHB1dFwiIG9wdGlvbiBmb3IgZGV0ZXJtaW5lXG4gICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcbiAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzIGJlIFwiLSxcIlxuICAgICAqIFwiLi1cIiA9PiBubm5uLm5uIG9yIG5ubm4ubm4tXG4gICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcuLScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29udGFpbnModmFsdWUsICctJykgPyB2YWx1ZS5yZXBsYWNlKCctJywgJycpICsgJy0nIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJywnIHx8IGxvY2FsZSA9PT0gJy0sJykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcuJywgJywnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlID09PSAnLC0nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIG51bWJlciBzdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHJlYWwgbnVtYmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZml4TnVtYmVyKHMsIGFEZWMsIGFOZWcpIHtcbiAgICAgICAgaWYgKGFEZWMgJiYgYURlYyAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFEZWMsICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFOZWcgJiYgYU5lZyAhPT0gJy0nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGFOZWcsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgcyArPSAnMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIHJlYWwgbnVtYmVyIHRvIGJlIGNvbnZlcnRlZCB0byBvdXIgZm9ybWF0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlc2VudE51bWJlcihzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYU5lZyAmJiBzZXR0aW5ncy5hTmVnICE9PSAnLScpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyAmJiBzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpdiwgc2V0dGluZ3MsIHNpZ25PbkVtcHR5KSB7XG4gICAgICAgIGlmIChpdiA9PT0gJycgfHwgaXYgPT09IHNldHRpbmdzLmFOZWcpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5wTmVnID09PSAnbCcpID8gaXYgKyBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFTdWZmaXggOiBzZXR0aW5ncy5hU2lnbiArIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIG91ciBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR3JvdXAoaXYsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdHJpcCkge1xuICAgICAgICAgICAgaXYgPSBhdXRvU3RyaXAoaXYsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMoaXYsICctJykpIHtcbiAgICAgICAgICAgIGl2ID0gJy0nICsgaXY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1wdHkgPSBjaGVja0VtcHR5KGl2LCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGlzTmVnID0gY29udGFpbnMoaXYsICctJyk7XG4gICAgICAgIGlmIChpc05lZykge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbXB0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWdpdGFsR3JvdXAgPSAnJztcbiAgICAgICAgc2V0dGluZ3MuZEdyb3VwID0gc2V0dGluZ3MuZEdyb3VwLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcyJykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGQpKFxcZHsyfT8pKykkLztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcycycpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoPzpcXGR7Mn0pezAsMn1cXGR7M30oPzooPzpcXGR7Mn0pezJ9XFxkezN9KSo/KSQvO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzQnKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpdi5zcGxpdChzZXR0aW5ncy5hbHREZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2VwICE9PSAnJykge1xuICAgICAgICAgICAgLy8gcmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuYVNlcH0kMmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MubURlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydCArIHNldHRpbmdzLmFEZWMgKyBkZWNpbWFsUGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdob2xlIG51bWJlcnMgb25seVxuICAgICAgICAgICAgaXYgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduICsgaXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWcgKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgaXYgKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFOZWcgKyBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFOZWcgKyBpdiArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGl2ID0gaXYgKyBzZXR0aW5ncy5hU2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgKHNldHRpbmdzLnJhd1ZhbHVlIDwgMCB8fCBpdi5jaGFyQXQoMCkgPT09ICctJykpIHtcbiAgICAgICAgICAgIGl2ID0gbmVnYXRpdmVCcmFja2V0KGl2LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBpdiArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgbm90IG5lZWRlZCB6ZXJvc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCByRGVjKSB7XG4gICAgICAgIGxldCByZWdleDtcbiAgICAgICAgc3dpdGNoIChyRGVjKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudHMgcGFkZGluZyAtIHJlbW92ZXMgdHJhaWxpbmcgemVyb3MgdG8gdGhlIGZpcnN0IHNpZ25pZmljYW50IGRpZ2l0XG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIHBhZGRpbmcgd2hlbiBtRGVjIGVxdWFscyBvbmUgLSBsZWF2ZXMgb25lIHplcm8gdHJhaWxpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLlxcZCg/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVzIGFjY2VzcyB6ZXJvcyB0byB0aGUgbURlYyBsZW5ndGggd2hlbiBhUGFkIGlzIHNldCB0cnVlXG4gICAgICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGAoXFxcXC5cXFxcZHske3JEZWN9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxuICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZShyZWdleCwgJyQxJyk7XG4gICAgICAgIGlmIChyRGVjID09PSAwKSB7XG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcm91bmQgbnVtYmVyIGFmdGVyIHNldHRpbmcgYnkgcGFzdGluZyBvciAkKCkuYXV0b051bWVyaWNTZXQoKVxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gZm9yIHJvdW5kIHRoZSBudW1iZXJcbiAgICAgKiBwbGVhc2Ugbm90ZSB0aGlzIGhhbmRsZWQgYXMgdGV4dCAtIEphdmFTY3JpcHQgbWF0aCBmdW5jdGlvbiBjYW4gcmV0dXJuIGluYWNjdXJhdGUgdmFsdWVzXG4gICAgICogYWxzbyB0aGlzIG9mZmVycyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzIHRoYXQgYXJlIG5vdCBlYXNpbHkgYWNjb21wbGlzaGVkIGluIEphdmFTY3JpcHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvUm91bmQoaXYsIHNldHRpbmdzKSB7IC8vIHZhbHVlIHRvIHN0cmluZ1xuICAgICAgICBpdiA9IChpdiA9PT0gJycpID8gJzAnIDogaXYudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLm1Sb3VuZCA9PT0gJ04wNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnQ0hGJyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdVMDUnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0QwNScpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MubVJvdW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5yb3VuZChpdiAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLmNlaWwoaXYgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGguZmxvb3IoaXYgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMoaXYsICcuJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdiArICcuMDAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdi5sZW5ndGggLSBpdi5pbmRleE9mKCcuJykgPCAzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXYgKyAnMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgbGV0IHJEZWM7XG5cbiAgICAgICAgLy8gc2V0cyB0aGUgdHJ1bmNhdGUgemVybyBtZXRob2RcbiAgICAgICAgaWYgKHNldHRpbmdzLmFQYWQpIHtcbiAgICAgICAgICAgIHJEZWMgPSBzZXR0aW5ncy5tRGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgckRlYyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGl2IChpbnB1dCBWYWx1ZSkgaXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBpZiAoaXYuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpdiA9IGl2LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgYSB6ZXJvIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90KVxuICAgICAgICBpZiAoIWl2Lm1hdGNoKC9eXFxkLykpIHtcbiAgICAgICAgICAgIGl2ID0gJzAnICsgaXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSB2YWx1ZSBpcyBlcXVhbCB0byB6ZXJvLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIE51bWJlcihpdikgPT09IDApIHtcbiAgICAgICAgICAgIG5TaWduID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltcyBsZWFkaW5nIHplcm8ncyBhcyBuZWVkZWRcbiAgICAgICAgaWYgKChOdW1iZXIoaXYpID4gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB8fCAoaXYubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIGl2ID0gaXYucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRQb3MgPSBpdi5sYXN0SW5kZXhPZignLicpO1xuXG4gICAgICAgIC8vIFZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxuICAgICAgICBjb25zdCB2ZFBvcyA9IChkUG9zID09PSAtMSkgPyBpdi5sZW5ndGggLSAxIDogZFBvcztcblxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcbiAgICAgICAgbGV0IGNEZWMgPSAoaXYubGVuZ3RoIC0gMSkgLSB2ZFBvcztcbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MubURlYykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaXY7XG4gICAgICAgICAgICBpZiAoY0RlYyA8IHJEZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHNldHRpbmdzLmFEZWM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHJEZWMgLSBjRGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgY29uc3Qgckxlbmd0aCA9IGRQb3MgKyBzZXR0aW5ncy5tRGVjOyAvL1RPRE8gTW9kaWZ5IGBkUG9zYCBoZXJlIGlmIGl0J3Mgbm90IGludGVuZGVkIHRoYXQgaXQgY2FuIGJlIGVxdWFsIHRvICctMSdcbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGl2LmNoYXJBdChyTGVuZ3RoICsgMSkpO1xuICAgICAgICBjb25zdCBvZGQgPSAoaXYuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGl2LmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpdi5jaGFyQXQockxlbmd0aCkgJSAyKTtcbiAgICAgICAgbGV0IGl2QXJyYXkgPSBpdi5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAvL0ZJWE1FIFRoZSBvcHRpb25zICdhJyBpcyBuZXZlciB0ZXN0ZWQgaGVyZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0InKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPT09IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0MnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIHRvIGNlaWxpbmcgdG93YXJkIHBvc2l0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdGJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCB0byBmbG9vciB0b3dhcmQgbmVnYXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xuICAgICAgICBpdkFycmF5ID0gaXZBcnJheS5zbGljZSgwLCByTGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgckRlYyk7XG5cbiAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgdGhlIGRlY2ltYWwgcGFydCBvZiBhIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XG4gICAgICAgIGNvbnN0IGFEZWMgPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICBjb25zdCBtRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xuICAgICAgICAgICAgb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyg6fFxcLikvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50XG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoYXQuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZWVwT3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5vRGVjICAgICA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYVBhZDtcbiAgICAgICAgc2V0dGluZ3Mub0JyYWNrZXQgPSBzZXR0aW5ncy5uQnJhY2tldDtcbiAgICAgICAgc2V0dGluZ3Mub1NlcCAgICAgPSBzZXR0aW5ncy5hU2VwO1xuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmFTaWduO1xuICAgICAgICBzZXR0aW5ncy5vU3VmZml4ICA9IHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkIC0gdGFrZW4gZnJvbSBtb2Rlcm5penJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIG9yIHJlbW92ZXMgc2Vzc2lvblN0b3JhZ2Ugb3IgY29va2llIGRlcGVuZGluZyBvbiBicm93c2VyIHN1cHBvcnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsIHRvRG8pIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWROYW1lID0gKCR0aGlzWzBdLm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZCgkdGhpc1swXS5uYW1lKSkgP2BBVVRPXyR7ZGVjb2RlVVJJQ29tcG9uZW50KCR0aGlzWzBdLm5hbWUpfWAgOmBBVVRPXyR7JHRoaXNbMF0uaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIHNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JHtzZXR0aW5ncy5yYXdWYWx1ZX07IGV4cGlyZXM9IDsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKC0xICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PScnIDske2V4cGlyZXN9OyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvb2tpZShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodG9Ebykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIb2xkZXIgb2JqZWN0IGZvciBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXV0b051bWVyaWNIb2xkZXIodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgIH1cblxuICAgIEF1dG9OdW1lcmljSG9sZGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICB0aGlzLmNtZEtleSA9IGUubWV0YUtleTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuXG4gICAgICAgICAgICAvLyBrZXlwcmVzcyBldmVudCBvdmVyd3JpdGVzIG1lYW5pbmdmdWwgdmFsdWUgb2YgZS5rZXlDb2RlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtkQ29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2hpY2ggPSBlLndoaWNoO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyU3RyaXBlZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCBzZXR0aW5nc0Nsb25lKTtcblxuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGFEZWMsXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGxlZnQgPT09ICcnIHx8IGxlZnQgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgc2V0dGluZ3NDbG9uZS5sWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmFEZWN9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIGtlZXBpbmcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBhZHZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgYWR2ZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0VmFsdWUgPSAoY29udGFpbnModGhpcy5uZXdWYWx1ZSwgJywnKSkgPyB0aGlzLm5ld1ZhbHVlLnJlcGxhY2UoJywnLCAnLicpIDogdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4cGFuZFNlbGVjdGlvbk9uU2lnblxuICAgICAgICAgKiByZXR1cm5zIHNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBhU2lnbiA9IHNldHRpbmdzQ2xvbmUuYVNpZ247XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xuICAgICAgICAgICAgaWYgKGFTaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAgICAgKiBwcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5zaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIGF1dG9TdHJpcChsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIGlmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIHNraXBBbHdheXMoZSkge1xuICAgICAgICAgICAgY29uc3Qga2RDb2RlID0gdGhpcy5rZENvZGU7XG4gICAgICAgICAgICBjb25zdCB3aGljaCA9IHRoaXMud2hpY2g7XG4gICAgICAgICAgICBjb25zdCBjdHJsS2V5ID0gdGhpcy5jdHJsS2V5O1xuICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gdGhpcy5jbWRLZXk7XG5cbiAgICAgICAgICAgIC8vIGNhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgaWYgKCgoY3RybEtleSB8fCBjbWRLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoc2hpZnRLZXkgJiYga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgRngga2V5cywgd2luZG93cyBrZXlzLCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgoa2RDb2RlID49IGtleUNvZGUuRjEgJiYga2RDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIGtkQ29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLlRhYiAmJiBrZENvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgICh3aGljaCA9PT0gMCB8fCB3aGljaCA9PT0ga2RDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdCBhbGwgKGEpXG4gICAgICAgICAgICBpZiAoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBrZENvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gdGhpcy5zZXR0aW5ncy5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTdWZmaXhMZW4gPSB0aGlzLnNldHRpbmdzLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwU2lnbiA9IHRoaXMuc2V0dGluZ3MucFNpZ247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBOZWcgPSB0aGlzLnNldHRpbmdzLnBOZWc7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAocE5lZyA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBhU2lnbkxlbiA+IDApP2FTaWduTGVuICsgMTphU2lnbkxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIGFTdWZmaXhMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVN1ZmZpeExlbiArIGFTaWduTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChhU2lnbkxlbiA+IDApP3ZhbHVlTGVuIC0gKGFTaWduTGVuICsgbmVnTGVuICsgYVN1ZmZpeExlbik6dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgKGtkQ29kZSA9PT0ga2V5Q29kZS5jIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXG4gICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCBrZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN0cmxLZXkgfHwgY21kS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNlcCA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFEZWMgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYURlYztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYVNlcCB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXJ0SnVtcCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtkQ29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIGtkQ29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSArIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgLSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGRlbGV0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzQWx3YXlzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiAoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5wcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgaW5zZXJ0aW9uIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzS2V5cHJlc3MoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgY0NvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMud2hpY2gpO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcbiAgICAgICAgICAgIGlmIChjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hRGVjIHx8IChzZXR0aW5nc0Nsb25lLmFsdERlYyAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5hbHREZWMpIHx8ICgoY0NvZGUgPT09ICcuJyB8fCBjQ29kZSA9PT0gJywnKSAmJiB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5Eb3ROdW1wYWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLm1EZWMgfHwgIXNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIGFOZWcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFEZWMpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBzZXR0aW5nc0Nsb25lLmFEZWMsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0cnkgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51c1xuICAgICAgICAgICAgaWYgKGNDb2RlID49ICcwJyAmJiBjQ29kZSA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hTmVnICYmIGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnZNYXggPD0gMCAmJiBzZXR0aW5nc0Nsb25lLnZNaW4gPCBzZXR0aW5nc0Nsb25lLnZNYXggJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBjQ29kZSwgcmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aXRoIGtlZXBpbmcgb2YgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBmb3JtYXRRdWljayhlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrdUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcblxuICAgICAgICAgICAgLy8gbm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuYVNlcCAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTZXAgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2VwKSkpICYmXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuYVNpZ24gPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2lnbikpKSkge1xuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmFEZWMpO1xuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhzdWJQYXJ0cywgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF1dG9Hcm91cCh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkgJiYgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0QXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuYVNpZ24uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlQ2hyID0gWydcXFxcJywgJ14nLCAnJCcsICcuJywgJ3wnLCAnPycsICcqJywgJysnLCAnKCcsICcpJywgJ1snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlQYXJ0cyA9IHNpZ25QYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbihlLnR5cGUgPT09ICdrZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxlZnRBcltpXS5tYXRjaCgnXFxcXGQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyW2ldID0gJ1xcXFwnICsgbGVmdEFyW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHNlYXJjaCBjdXJzb3IgcG9zaXRpb24gaW4gZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IHZhbHVlLm1hdGNoKGxlZnRSZWcpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbmV3TGVmdFswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGp1c3QgYmVmb3JlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB8fCAocG9zaXRpb24gPT09IDEgJiYgdmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpKSAmJiBzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTaWduICYmIHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhhdCkpO1xuICAgICAgICBjb25zdCBmb3JtSW5kZXggPSAkKCdmb3JtJykuaW5kZXgoJHRoaXMpO1xuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcbiAgICAgICAgY29uc3QgYWlJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxuICAgICAgICBjb25zdCBzY0luZGV4ID0gW107XG5cbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XG4gICAgICAgIGNvbnN0IHJTdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJTdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXG4gICAgICAgIGNvbnN0IHJDaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG4gICAgICAgIGNvbnN0IHJOb25BdXRvTnVtZXJpY1R5cGVzID0gL14oPzpidXR0b258Y2hlY2tib3h8Y29sb3J8ZGF0ZXxkYXRldGltZXxkYXRldGltZS1sb2NhbHxlbWFpbHxmaWxlfGltYWdlfG1vbnRofG51bWJlcnxwYXNzd29yZHxyYWRpb3xyYW5nZXxyZXNldHxzZWFyY2h8c3VibWl0fHRpbWV8dXJsfHdlZWspL2k7XG5cbiAgICAgICAgbGV0IGNvdW50ID0gMDtcblxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgIT09ICcnICYmIHJTdWJtaXR0YWJsZS50ZXN0KGZpZWxkLmxvY2FsTmFtZSkgJiYgIXJTdWJtaXR0ZXJUeXBlcy50ZXN0KGZpZWxkLnR5cGUpICYmICFmaWVsZC5kaXNhYmxlZCAmJiAoZmllbGQuY2hlY2tlZCB8fCAhckNoZWNrYWJsZVR5cGUudGVzdChmaWVsZC50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIGFsbCBpbnB1dHMgdGFncyBleGNlcHQgY2hlY2tib3hcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgKGZpZWxkLnR5cGUgPT09ICcnIHx8IGZpZWxkLnR5cGUgPT09ICd0ZXh0JyB8fCBmaWVsZC50eXBlID09PSAnaGlkZGVuJyB8fCBmaWVsZC50eXBlID09PSAndGVsJykpIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goY291bnQpO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQudmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldCcsIHNldHRpbmdzLmxvY2FsZU91dHB1dCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhdGUgYXV0b051bWVyaWMgYW5kIGF0dGFjaCB0aGUgc2V0dGluZ3MgKG9wdGlvbnMgY2FuIGJlIHBhc3NlZCBhcyBhIHBhcmFtZXRlcilcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygpOyAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jywge29wdGlvbnN9KTsgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICAgICAgICAgIGlmICghJGlucHV0ICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhlIHN0YXRpYyBjb25maWd1cmF0aW9uIG9iamVjdHMgb3V0IG9mIHRoYXQgYmxvY2ssIGFuZCBob2lzdCB0aGVtIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZpbGVcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2InLFxuICAgICAgICAgICAgICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdjaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgICAgICAnY29uc3QnLFxuICAgICAgICAgICAgICAgICAgICAnZGQnLFxuICAgICAgICAgICAgICAgICAgICAnZGVsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICdkZm4nLFxuICAgICAgICAgICAgICAgICAgICAnZHQnLFxuICAgICAgICAgICAgICAgICAgICAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAnaDEnLFxuICAgICAgICAgICAgICAgICAgICAnaDInLFxuICAgICAgICAgICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgICAgICAgICAnaDQnLFxuICAgICAgICAgICAgICAgICAgICAnaDUnLFxuICAgICAgICAgICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgICAgICAgICAnaW5zJyxcbiAgICAgICAgICAgICAgICAgICAgJ2tkYicsXG4gICAgICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLFxuICAgICAgICAgICAgICAgICAgICAncScsXG4gICAgICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAgICAgJ3NhbXBsZScsXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAgICAgICAgICd1JyxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuT25jZSAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRGaXggICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QgICAgICAgICA6IGFsbG93ZWRUYWdMaXN0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHVzZXIgc2V0dGluZ3MgdG8gbWFrZSB0aGVtICdleHBsb2l0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IEJvb2xlYW4odmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMsIHNjYWxlRGl2aXNvciAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcblxuICAgICAgICAgICAgICAgIC8vIHJvdXRpbmUgdG8gZm9ybWF0IGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgPT09IGZhbHNlICYmIHNldHRpbmdzLmFGb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhhdCB0aGlzIGlucHV0IHZhbHVlIGlzIGEgdmFsaWQgbnVtYmVyIGFuZCB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogZGV2ZWxvcGVyIHdhbnRzIGl0IGZvcm1hdHRlZCBvbiBpbml0IChjZi4gYHNldHRpbmdzLmFGb3JtYCkpLiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgICAgICAgICAgICAgICogaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGFuRGVmYXVsdGAgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBkZXZlbG9wZXIgaXMgdHJ5aW5nIHRvIHByZXZlbnQgcG9zdGJhY2sgcHJvYmxlbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBIZW5jZSwgaWYgYGFuRGVmYXVsdGAgaXMgbm90IG51bGwsIGJ1dCBgaW5wdXQudmFsdWVgIGlzIGEgbnVtYmVyIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGFuRGVmYXVsdGAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFGb3JtICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KCR0aGlzLmF0dHIoJ3ZhbHVlJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdGVkQ3VycmVudFZhbHVlID0gcGFyc2VGbG9hdChjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpOyAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih0ZXN0ZWRDdXJyZW50VmFsdWUpICYmIEluZmluaXR5ICE9PSB0ZXN0ZWRDdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHRlc3RlZEN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QsIGluZm9ybSB0aGUgZGV2ZWxvcGVyIHRoYXQgbm90aGluZyB1c2FibGUgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske2N1cnJlbnRWYWx1ZX1dIHVzZWQgaW4gdGhlIGlucHV0IGlzIG5vdCBhIHZhbGlkIHZhbHVlIGF1dG9OdW1lcmljIGNhbiB3b3JrIHdpdGguYCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmFuRGVmYXVsdCAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hbkRlZmF1bHQudG9TdHJpbmcoKSAhPT0gY3VycmVudFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gbnVsbCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGN1cnJlbnRWYWx1ZSAhPT0gJHRoaXMuYXR0cigndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjICE9PSBudWxsICYmIHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IG5lZ2F0aXZlQnJhY2tldChjdXJyZW50VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gKChzZXR0aW5ncy5wTmVnID09PSAncycgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyAhPT0gJ3AnKSkgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKT8nLScgKyBhdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpOmF1dG9TdHJpcCh0b1N0cmlwLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy53RW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmFTaWduKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSAmJiAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCA9PT0gJHRoaXMudGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBFeHRyYWN0IHRoZSBldmVudCBsaXN0ZW5lcnMgdG8gYW5vdGhlciBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIGlucHV0IHR5cGVzIHN1cHBvcnRlZCBcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2ZvY3VzaW4uYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAkc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwobmVnYXRpdmVCcmFja2V0KCR0aGlzLnZhbCgpLCAkc2V0dGluZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5lRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLm5TZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBhdXRvU3RyaXAoJHRoaXMudmFsKCksICRzZXR0aW5ncykpICE9PSAkc2V0dGluZ3MucmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci5pblZhbCwgJHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgJHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleWRvd24uYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogLy8gVGhlIGNvZGUgYmVsb3cgYWxsb3dzIHRoZSBcImVudGVyXCIga2V5ZG93biB0byB0aHJvdyBhIGNoYW5nZSgpIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci5pblZhbCAhPT0gJHRoaXMudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnByb2Nlc3NBbHdheXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IGluIGRlbGV0aW9uIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXlwcmVzcy5hdXRvTnVtZXJpYycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBmaXggZm9yIFNoaWZ0ICYmIGluc2VydCBwYXN0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkgfHwgaG9sZGVyLnByb2Nlc3NLZXlwcmVzcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigna2V5dXAuYXV0b051bWVyaWMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLnNraXBBbHdheXMoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWIgPSBob2xkZXIua2RDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmtkQ29kZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYiA9PT0ga2V5Q29kZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsICR0aGlzLnZhbCgpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXNvdXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsICRzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAkc2V0dGluZ3Mub1NlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNpZ24gPSAkc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTdWZmaXggPSAkc2V0dGluZ3Mub1N1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuZURlYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFQYWQgPSAkc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubkJyYWNrZXQgPSAkc2V0dGluZ3Mub0JyYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0VtcHR5KHZhbHVlLCAkc2V0dGluZ3MpID09PSBudWxsICYmIG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgJHNldHRpbmdzLmFEZWMsICRzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gJHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICRzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gKyRzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiAkc2V0dGluZ3MubURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKCcwJywgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgJHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKCRzZXR0aW5ncy5zY2FsZVN5bWJvbCkgPyBncm91cGVkVmFsdWUgKyAkc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIuaW5WYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLmluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FIEFmdGVyIGEgcGFzdGUsIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIGZhciByaWdodCBvZiB0aGUgaW5wdXQsIGl0IHNob3VsZCBiZSBzZXQgdG8gc29tZXRoaW5nIGxpa2UgYG5ld0NhcmV0UG9zaXRpb24gPSBvbGRDYXJldFBvc2l0aW9uICsgcGFzdGVUZXh0Lmxlbmd0aDtgLCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b1N0cmlwKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmFEZWMsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQsIGN1cnJlbnRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmUoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhc3RlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlKHByZWZpeCArIE51bWJlcihwYXN0ZWRUZXh0KS52YWx1ZU9mKCkgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld1ZhbHVlKSAmJiBOdW1iZXIob2xkUmF3VmFsdWUpLnZhbHVlT2YoKSAhPT0gTnVtYmVyKG5ld1ZhbHVlKS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuU2V0T25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlbW92ZSBzZXR0aW5ncyBhbmQgc3RvcCBhdXRvTnVtZXJpYygpIC0gZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIGRlc3Ryb3lzIGF1dG9OdW1lcmljXG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGFuZCBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gcmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgd2lwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IHVwZGF0ZXMgdGhlIGF1dG9OdW1lcmljIHNldHRpbmdzXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyB1cGRhdGVzIHRoZSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJ1cGRhdGVcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSBzZXR0aW5ncy5hU2VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGFEZWM6IFwiJHtzZXR0aW5ncy5hRGVjfVwiIGFuZCB0aG91c2FuZCBzZXBhcmF0b3IgYVNlcDogXCIke3NldHRpbmdzLmFTZXB9XCIgYXJlIHRoZSBzYW1lIGNoYXJhY3RlcmAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzdHJpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBmb3JtYXQgdGhlIHZhbHVlIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAndmFsdWUnKTsgLy8gZm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcbiAgICAgICAgICogYW5kIG11c3QgY29udGFpbiBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIChwZXJpb2QpIGNoYXJhY3RlclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KHZhbHVlSW4pIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSW4gPT09IG51bGwgfHwgaXNVbmRlZmluZWQodmFsdWVJbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZUluLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBiZWluZyBzZXQgaXMgbm90IG51bWVyaWNcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNOdW1lcmljKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgaGFzIGNhdXNlZCBhIGVycm9yIHRvIGJlIHRocm93bmAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCAmJiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiBtYXggcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgfHwgaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5zY2FsZURpdmlzb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3RvciAmJiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3MgZm9yIHRoaXMgZWxlbWVudGAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gZ2V0IHRoZSB1bmZvcm1hdHRlZCB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIHBhcmFtZXRlclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpOyBubyBwYXJhbWV0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBsb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzLmFEZWMsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgTnVtZXJpYyBTdHJpbmdcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgcmV0dXJuIGBOdW1iZXIodmFsdWUpYCBzaW5jZSB0aGUgZ29hbCBvZiBgZ2V0YCBpcyB0byBnZXQgdGhlIHJhdyBqYXZhc2NyaXB0IHZhbHVlP1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnMCcpIHx8ICEoJ3ZhbHVlJyBpbiB0aGlzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhdXRvTnVtZXJpYyBmdW5jdGlvblxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxuICAgICAqIC0gSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXG4gICAgICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcbiAgICAgKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAgICAgKi9cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0ge1xuICAgICAgICAvKiBBbGxvd2VkIHRob3VzYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAgICAgKiBhcG9zdHJvcGhlIGlzIGVzY2FwZWQgPSBcIlxcXCJcIlxuICAgICAgICAgKiBzcGFjZSA9IFwiIFwiXG4gICAgICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICAgICAqIE5PVEU6IGRvIG5vdCB1c2UgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBhU2VwOiAnLCcsXG5cbiAgICAgICAgLyogV2hlbiB0cnVlID0+IHJlbW92ZXMgdGhlIHRob3VzYW5kIHNlcGVyYXRvciwgY3VycmVuY3kgc3ltYm9sICYgc3VmZml4IFwiZm9jdXNpblwiXG4gICAgICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAgICAgKiBvbiBcImZvY3VzaW5cIiBpdCBiZWNvbWVzIFwiMTk5OS44OFwiIGFuZCBiYWNrIHRvIFwiJCAxLDk5OS44OCBzdWZmaXhcIiBvbiBmb2N1cyBvdXQuXG4gICAgICAgICAqL1xuICAgICAgICBuU2VwOiBmYWxzZSxcblxuICAgICAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICAgICAqIGRHcm91cDogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgICAgICogZEdyb3VwOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAgICAgKiBkR3JvdXA6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgICAgICogZEdyb3VwOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICAgICAqL1xuICAgICAgICBkR3JvdXA6ICczJyxcblxuICAgICAgICAvKiBBbGxvd2VkIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICAgICAqL1xuICAgICAgICBhRGVjOiAnLicsXG5cbiAgICAgICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGFEZWNcbiAgICAgICAgICogZGV2ZWxvcGVkIGZvciBjb3VudHJpZXMgdGhlIHVzZSBhIGNvbW1hIFwiLFwiIGFzIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgICAgICovXG4gICAgICAgIGFsdERlYzogbnVsbCxcblxuICAgICAgICAvKiBhU2lnbiA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXG4gICAgICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTaWduOiBcIiRcIlxuICAgICAgICAgKiBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyQgJ1xuICAgICAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnICQnXG4gICAgICAgICAqL1xuICAgICAgICBhU2lnbjogJycsXG5cbiAgICAgICAgLyogcFNpZ24gPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XG4gICAgICAgICAqIGZvciBwcmVmaXggcFNpZ246IFwicFwiIChkZWZhdWx0KVxuICAgICAgICAgKiBmb3Igc3VmZml4IHBTaWduOiBcInNcIlxuICAgICAgICAgKi9cbiAgICAgICAgcFNpZ246ICdwJyxcblxuICAgICAgICAvKiBQbGFjZW1lbnQgb2YgbmVnYXRpdmUgc2lnbiByZWxhdGl2ZSB0byB0aGUgYVNpZ24gb3B0aW9uIGw9bGVmdCwgcj1yaWdodCwgcD1wcmVmaXggJiBzPXN1ZmZpeFxuICAgICAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxuICAgICAgICAgKiAtJDEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCJ9XG4gICAgICAgICAqICQtMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIiwgcE5lZzogXCJyXCJ9XG4gICAgICAgICAqIC0xLDIzNC41NiQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn1cbiAgICAgICAgICogMSwyMzQuNTYtICA9PiB7cE5lZzogXCJzXCJ9XG4gICAgICAgICAqICQxLDIzNC41Ni0gPT4ge2FTaWduOiBcIiRcIiwgcE5lZzogXCJzXCJ9XG4gICAgICAgICAqIDEsMjM0LjU2LSQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wifVxuICAgICAgICAgKiAxLDIzNC41NiQtID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJyXCJ9XG4gICAgICAgICAqL1xuICAgICAgICBwTmVnOiAnbCcsXG5cbiAgICAgICAgLyogQWRkaXRpb25hbCBzdWZmaXhcbiAgICAgICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVN1ZmZpeDogJ2dyb3NzJywgYSBzcGFjZSBpcyBhbGxvd2VkIGFTdWZmaXg6ICcgZG9sbGFycydcbiAgICAgICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYVN1ZmZpeDogJycsXG5cbiAgICAgICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcbiAgICAgICAgICogb0xpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byB2TWF4IGFuZCBpZ25vcmVzIHZNaW4gc2V0dGluZ3NcbiAgICAgICAgICogb0xpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gdk1pbiBhbmQgaWdub3JlcyB2TWF4IHNldHRpbmdzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICAgICAqL1xuICAgICAgICBvTGltaXRzOiBudWxsLFxuXG4gICAgICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIHZNaW5cbiAgICAgICAgICovXG4gICAgICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxuICAgICAgICAgKi9cbiAgICAgICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIixcbiAgICAgICAgICovXG4gICAgICAgIG1EZWM6IG51bGwsXG5cbiAgICAgICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XG4gICAgICAgICAqIHtlRGVjOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAqL1xuICAgICAgICBlRGVjOiBudWxsLFxuXG4gICAgICAgIC8qIFRoZSBuZXh0IHRocmVlIG9wdGlvbnMgKHNjYWxlRGl2aXNvciwgc2NhbGVEZWNpbWFsICYgc2NhbGVTeW1ib2wpIGhhbmRsZSBzY2FsaW5nIG9mIHRoZSBpbnB1dCB3aGVuIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIGZvY3VzXG4gICAgICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJhU3RvcmVcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWUgICAgICAgICAqIFtcImRpdmlzb3JcIiwgXCJkZWNpbWFsIHBsYWNlc1wiLCBcInN5bWJvbFwiXVxuICAgICAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWw6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XG4gICAgICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAgICAgKi9cblxuICAgICAgICAvKiBUaGUgYHNjYWxlRGl2aXNvcmAgZGVjaWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxuICAgICAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgICAgICogVGhlIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciBidXQgcGxlYXNlIHVuZGVyc3RhbmQgdGhhdCBKYXZhc2NyaXB0IGhhcyBsaW1pdGVkIGFjY3VyYWN5IGluIG1hdGhcbiAgICAgICAgICogVGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZURpdmlzb3I6IG51bGwsXG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGBzY2FsZURlY2ltYWxgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVEZWNpbWFsOiBudWxsLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXG4gICAgICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgdG9vLlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGVTeW1ib2w6IG51bGwsXG5cbiAgICAgICAgLyogU2V0IHRvIHRydWUgdG8gYWxsb3cgdGhlIGVEZWMgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxuICAgICAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAgICAgKi9cbiAgICAgICAgYVN0b3I6IGZhbHNlLFxuXG4gICAgICAgIC8qIG1ldGhvZCB1c2VkIGZvciByb3VuZGluZ1xuICAgICAgICAgKiBtUm91bmQ6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgICAgICogbVJvdW5kOiBcIkFcIiwgUm91bmQtSGFsZi1VcCBBc3ltbWV0cmljXG4gICAgICAgICAqIG1Sb3VuZDogXCJzXCIsIFJvdW5kLUhhbGYtRG93biBTeW1tZXRyaWMgKGxvd2VyIGNhc2UgcylcbiAgICAgICAgICogbVJvdW5kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgICAgICogbVJvdW5kOiBcIkJcIiwgUm91bmQtSGFsZi1FdmVuIFwiQmFua2VycyBSb3VuZGluZ1wiXG4gICAgICAgICAqIG1Sb3VuZDogXCJVXCIsIFJvdW5kIFVwIFwiUm91bmQtQXdheS1Gcm9tLVplcm9cIlxuICAgICAgICAgKiBtUm91bmQ6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgICAgICogbVJvdW5kOiBcIkNcIiwgUm91bmQgdG8gQ2VpbGluZyBcIlRvd2FyZCBQb3NpdGl2ZSBJbmZpbml0eVwiXG4gICAgICAgICAqIG1Sb3VuZDogXCJGXCIsIFJvdW5kIHRvIEZsb29yIFwiVG93YXJkIE5lZ2F0aXZlIEluZmluaXR5XCJcbiAgICAgICAgICogbVJvdW5kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgICAgICogbVJvdW5kOiBcIlUwNVwiIFJvdW5kcyB1cCB0byBuZXh0IC4wNVxuICAgICAgICAgKiBtUm91bmQ6IFwiRDA1XCIgUm91bmRzIGRvd24gdG8gbmV4dCAuMDVcbiAgICAgICAgICovXG4gICAgICAgIG1Sb3VuZDogJ1MnLFxuXG4gICAgICAgIC8qIENvbnRyb2xzIGRlY2ltYWwgcGFkZGluZ1xuICAgICAgICAgKiBhUGFkOiB0cnVlIC0gYWx3YXlzIFBhZCBkZWNpbWFscyB3aXRoIHplcm9zXG4gICAgICAgICAqIGFQYWQ6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICAgICAqIE5vdGU6IHNldHRpbmcgYVBhZCB0byAnZmFsc2UnIHdpbGwgb3ZlcnJpZGUgdGhlICdtRGVjJyBzZXR0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYVBhZDogdHJ1ZSxcblxuICAgICAgICAvKiBBZGRzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlcyAoaWUuIHRyYW5zZm9ybXMgJy0kIDk5OS45OScgdG8gJyg5OTkuOTkpJylcbiAgICAgICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgICAgICogbkJyYWNrZXQ6IG51bGwgLSAoZGVmYXVsdClcbiAgICAgICAgICogbkJyYWNrZXQ6ICcoLCknLCBuQnJhY2tldDogJ1ssXScsIG5CcmFja2V0OiAnPCw+JyBvciBuQnJhY2tldDogJ3ssfSdcbiAgICAgICAgICovXG4gICAgICAgIG5CcmFja2V0OiBudWxsLFxuXG4gICAgICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAgICAgKiB3RW1wdHk6IFwiZm9jdXNcIiAtIChkZWZhdWx0KSBjdXJyZW5jeSBzaWduIGRpc3BsYXllZCBhbmQgdGhlIGlucHV0IHJlY2VpdmVzIGZvY3VzXG4gICAgICAgICAqIHdFbXB0eTogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcbiAgICAgICAgICogd0VtcHR5OiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgICAgICogd0VtcHR5OiBcInplcm9cIiAtIGlmIHRoZSBpbnB1dCBoYXMgbm8gdmFsdWUgb24gZm9jdXMgb3V0IGRpc3BsYXlzIGEgemVybyBcInJvdW5kZWRcIiB3aXRoIG9yIHdpdGggYSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICAvL1RPRE8gQWRkIGFuIG9wdGlvbiB0byBkaXNwbGF5IHRoZSBjdXJyZW5jeSBzaWduIG9ubHkgb24gaG92ZXIgKGlmIHRoZSBpbnB1dCBpcyBlbXB0eSlcbiAgICAgICAgd0VtcHR5OiAnZm9jdXMnLFxuXG4gICAgICAgIC8qIENvbnRyb2xzIGxlYWRpbmcgemVybyBiZWhhdmlvclxuICAgICAgICAgKiBsWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgICAgICogbFplcm86IFwia2VlcFwiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIG9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgcmV0YWluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBsWmVybzogJ2FsbG93JyxcblxuICAgICAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICogZmFsc2UgPSB3aWxsIG5vdCBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIGFGb3JtOiB0cnVlLFxuXG4gICAgICAgIC8qIERldGVybWluZSBpZiB0aGUgc2VsZWN0IGFsbCBrZXlib2FyZCBjb21tYW5kIHdpbGwgc2VsZWN0XG4gICAgICAgICAqIHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0IG9yIG9ubHkgdGhlIGlucHV0IG51bWVyaWMgdmFsdWVcbiAgICAgICAgICogaWYgdGhlIGN1cnJlbmN5IHN5bWJvbCBpcyBiZXR3ZWVuIHRoZSBudW1lcmljIHZhbHVlIGFuZCB0aGUgbmVnYXRpdmUgc2lnbiBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHNOdW1iZXI6IGZhbHNlLFxuXG4gICAgICAgIC8qIEhlbHBlciBvcHRpb24gZm9yIEFTUC5ORVQgcG9zdGJhY2tcbiAgICAgICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgKiBleGFtcGxlczpcbiAgICAgICAgICogbm8gZGVmYXVsdCB2YWx1ZT1cIlwiIHthbkRlZmF1bHQ6IFwiXCJ9XG4gICAgICAgICAqIHZhbHVlPTEyMzQuNTYge2FuRGVmYXVsdDogJzEyMzQuNTYnfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5EZWZhdWx0OiBudWxsLFxuXG4gICAgICAgIC8qIFJlbW92ZXMgZm9ybWF0dGluZyBvbiBzdWJtaXQgZXZlbnRcbiAgICAgICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICAgICAqL1xuICAgICAgICB1blNldE9uU3VibWl0OiBmYWxzZSxcblxuICAgICAgICAvKiBBbGxvd3MgdGhlIG91dHB1dCB0byBiZSBpbiB0aGUgbG9jYWxlIGZvcm1hdCB2aWEgdGhlIFwiZ2V0XCIsIFwiZ2V0U3RyaW5nXCIgJiBcImdldEFycmF5XCIgbWV0aG9kc1xuICAgICAgICAgKiBudWxsID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gZGVmYXVsdFxuICAgICAgICAgKiBcIixcIiAgPT4gbm5ubixubiBvciAtbm5ubixubiBjYW4gYWxzbyBiZSBcIi0sXCJcbiAgICAgICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZU91dHB1dDogbnVsbCxcblxuICAgICAgICAvKiBFcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xuICAgICAgICAgKi9cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG5cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cztcblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyXG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB2TWF4ID0gc2V0dGluZ3Mudk1heC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBkZWNMZW5ndGgodk1pbiwgdk1heCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGN1c3RvbSBldmVudFxuICAgICAgICAgICAgc2VuZEN1c3RvbUV2ZW50KCdhdXRvRm9ybWF0LmF1dG9OdW1lcmljJywgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHNldHRpbmdzYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDtcblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XG4gICAgICAgIGNvbnN0IGF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5uQnJhY2tldCAmJiBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpWzBdID09PSB2YWx1ZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFOZWcgPSAnLSc7XG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVidWcgPSB0cnVlOyAvLyBUaGUgZXJyb3IgaGVyZSBtdXN0IGFsd2F5cyBiZSB0aHJvd24sIHNpbmNlIGEgYmFkbHkgY29uZmlndXJlZCBvcHRpb25zIG9iamVjdCB3aWxsIGxlYWQgdG8gd3JvbmcgcmVzdWx0cywgaWYgYW55LlxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdXNlciBjYW4gY2hvb3NlIGlmIHRoZSBgdXNlck9wdGlvbnNgIGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLCBvciBub3RcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFTZXAsIFsnLCcsICcuJywgJyAnLCAnJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FTZXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJywnLCAnLicsICcgJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmFTZXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5uU2VwKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMublNlcCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnblNlcCcgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5TZXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRHcm91cCkpIHsgLy8gaXNOYU4ocGFyc2VJbnQob3B0aW9ucy5kR3JvdXApKSAvL0RFQlVHXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZEdyb3VwJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kR3JvdXB9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFEZWMsIFsnLCcsICcuJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLicgb3IgJywnLCBbJHtvcHRpb25zLmFEZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChvcHRpb25zLmFEZWMgPT09IG9wdGlvbnMuYVNlcCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ2FEZWMnIFske29wdGlvbnMuYURlY31dIGFuZCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yICdhU2VwJyBbJHtvcHRpb25zLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuYWx0RGVjKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5hbHREZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FsdERlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hbHREZWN9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hU2lnbiAhPT0gJycgJiYgIWlzU3RyaW5nKG9wdGlvbnMuYVNpZ24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnYVNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuYVNpZ259XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnBTaWduLCBbJ3AnLCAncyddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBsYWNlbWVudCBvZiB0aGUgY3VycmVuY3kgc2lnbiBvcHRpb24gJ3BTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCkgb3IgJ3MnIChzdWZmaXgpLCBbJHtvcHRpb25zLnBTaWdufV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5wTmVnLCBbJ3AnLCAncycsICdsJywgJ3InXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICdwTmVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSBvciAncicgKHJpZ2h0KSwgWyR7b3B0aW9ucy5wTmVnfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLmFTdWZmaXgpIHx8IChvcHRpb25zLmFTdWZmaXggIT09ICcnICYmIChjb250YWlucyhvcHRpb25zLmFTdWZmaXgsICctJykgfHwgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMudGVzdChvcHRpb25zLmFTdWZmaXgpKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhZGRpdGlvbmFsIHN1ZmZpeCBvcHRpb24gJ2FTdWZmaXgnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgbm90IGNvbnRhaW5zIHRoZSBuZWdhdGl2ZSBzaWduICctJyBub3IgYW55IG51bWVyaWNhbCBjaGFyYWN0ZXJzLCBbJHtvcHRpb25zLmFTdWZmaXh9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm9MaW1pdHMpICYmICFpc0luQXJyYXkob3B0aW9ucy5vTGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ29MaW1pdHMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdjZWlsaW5nJywgJ2Zsb29yJyBvciAnaWdub3JlJywgWyR7b3B0aW9ucy5vTGltaXRzfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNYXgpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1heCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1heH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy52TWluKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLnZNaW4pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ3ZNaW4nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLnZNaW59XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLnZNaW4pID4gcGFyc2VGbG9hdChvcHRpb25zLnZNYXgpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiA7ICd2TWluJyBbJHtvcHRpb25zLnZNaW59XSBzaG91bGQgYmUgc21hbGxlciB0aGFuICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm1EZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5tRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdtRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5tRGVjfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFQYWQgJiYgIWlzTnVsbChvcHRpb25zLm1EZWMpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdhUGFkJyB0byBbZmFsc2VdIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ21EZWMnIHNldHRpbmcgWyR7b3B0aW9ucy5tRGVjfV0uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIHZNaW4vdk1heCBpcyBvdmVycmlkZGVuIGJ5IG1EZWMgKGFuZCBub3QgaWYgbURlYyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiB2TWluL3ZNYXgpXG4gICAgICAgIGxldCBkcFZNaW4gPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1pbik7XG4gICAgICAgIGxldCBkcFZNYXggPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1heCk7XG4gICAgICAgIGRwVk1pbiA9IGlzTnVsbChkcFZNaW4pPzA6ZHBWTWluO1xuICAgICAgICBkcFZNYXggPSBpc051bGwoZHBWTWF4KT8wOmRwVk1heDtcbiAgICAgICAgY29uc3Qgdk1pbk1heERlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChkcFZNaW4sIGRwVk1heCk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiZcbiAgICAgICAgICAgICgoaGFzRGVjaW1hbHMob3B0aW9ucy52TWluKSB8fCBoYXNEZWNpbWFscyhvcHRpb25zLnZNYXgpKSAmJiB2TWluTWF4RGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdtRGVjJyB0byBbJHtvcHRpb25zLm1EZWN9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAndk1pbicgWyR7b3B0aW9ucy52TWlufV0gYW5kICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5lRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZURlY31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJlRGVjXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJtRGVjXCJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5lRGVjKSAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykgJiYgTnVtYmVyKG9wdGlvbnMubURlYykgPCBOdW1iZXIob3B0aW9ucy5lRGVjKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgJ2VEZWMnIFske29wdGlvbnMuZURlY31dIGlzIGdyZWF0ZXIgdGhhbiB0aGUgJ21EZWMnIFske29wdGlvbnMubURlY31dIHZhbHVlLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWwpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWwpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWx9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlU3ltYm9sKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5zY2FsZVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBzeW1ib2wgb3B0aW9uICdzY2FsZVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5zY2FsZVN5bWJvbH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFTdG9yKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2F2ZSB0byBzZXNzaW9uIHN0b3JhZ2Ugb3B0aW9uICdhU3RvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYVN0b3J9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm1Sb3VuZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAnbVJvdW5kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMubVJvdW5kfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYVBhZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFQYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY29udHJvbCBkZWNpbWFsIHBhZGRpbmcgb3B0aW9uICdhUGFkJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hUGFkfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uQnJhY2tldCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm5CcmFja2V0LCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduQnJhY2tldCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uQnJhY2tldH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMud0VtcHR5LCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICd3RW1wdHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy53RW1wdHl9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmxaZXJvLCBbJ2FsbG93JywgJ2RlbnknLCAna2VlcCddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGxlYWRpbmcgemVybyBiZWhhdmlvciBvcHRpb24gJ2xaZXJvJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnYWxsb3cnLCAnZGVueScgb3IgJ2tlZXAnLCBbJHtvcHRpb25zLmxaZXJvfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYUZvcm0pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hRm9ybSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdhRm9ybScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYUZvcm19XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zTnVtYmVyKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc051bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzTnVtYmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zTnVtYmVyfV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbkRlZmF1bHQpICYmIChvcHRpb25zLmFuRGVmYXVsdCAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5hbkRlZmF1bHQpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdhbkRlZmF1bHQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLmFuRGVmYXVsdH1dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuU2V0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51blNldE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuU2V0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuU2V0T25TdWJtaXR9XSBnaXZlbi5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmxvY2FsZU91dHB1dCkgJiYgIWlzSW5BcnJheShvcHRpb25zLmxvY2FsZU91dHB1dCwgW1xuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ2xvY2FsZU91dHB1dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgZW1wdHksICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMubG9jYWxlT3V0cHV0fV0gZ2l2ZW4uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZGVidWcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5kZWJ1ZykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ2RlYnVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5kZWJ1Z31dIGdpdmVuLmAsIGRlYnVnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkLmZuLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlU2V0dGluZ3NWYWxpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICAvKiBsZXQgZXZlbnRJbmZvID0gbmV3IEN1c3RvbUV2ZW50SW5pdCgpOyAvL1RoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCwgYnV0IElFIGRvZXMgbm90IHN1cHBvcnQgJ0N1c3RvbUV2ZW50SW5pdCcgeWV0XG4gICAgICAgIGV2ZW50SW5mby5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9KSgpO1xufSkpO1xuXG4vKipcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxuICAgIGdldERlZmF1bHRDb25maWcsXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxuICAgIGFyZVNldHRpbmdzVmFsaWQsIC8vYW4uYXJlU2V0dGluZ3NWYWxpZChvcHRpb25zKSA6IHJldHVybiB0cnVlIG9yIGZhbHNlIC8vVE9ETyBJcyB0aGlzIHJlZHVuZGFudD8gU2hvdWxkIHdlIGxldCB0aGUgZGV2ZWxvcGVycyB3cmFwIGVhY2ggYXV0b051bWVyaWMudmFsaWRhdGUoKSBjYWxscyBpbiB0cnkvY2F0Y2ggYmxvY2s/IE9yIHNob3VsZCB3ZSBqdXN0IGZhY2lsaXRhdGUgdGhlaXIgbGlmZSBieSBkb2luZyBpdCBhbHJlYWR5P1xuXG4gICAgLy9UT0RPIENvbXBsZXRlIHRoZSBpbnRlcmZhY2Ugd2l0aCBmdW5jdGlvbnMgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyA6XG4gICAgLy9pbml0ICAgICAgICAgOiBhbi5pbml0KG9wdGlvbnMsIGlucHV0KVxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxuICAgIC8vc2V0ICAgICAgICAgIDogYW4uc2V0KHZhbHVlLCBpbnB1dClcbiAgICAvL2Zvcm1TdHJpbmcgICA6IGFuLmZvcm1TdHJpbmcoZm9ybSlcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxuICAgIC8vZ2V0Rm9ybWF0dGVkIDogYW4uZ2V0Rm9ybWF0dGVkKGlucHV0KVxuICAgIC8vdW5zZXQgICAgICAgIDogYW4udW5zZXQoaW5wdXQpIC8vdG8gcmVuYW1lIHRvICd1bmZvcm1hdCc/IChhbmQgbWVyZ2Ugd2l0aCBhdXRvVW5Gb3JtYXQvdW5Gb3JtYXQ/KVxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cbiAgICAvL3NldHRpbmdzICAgICA6IGFuLnNldHRpbmdzKGlucHV0KVxuICAgIC8vdXBkYXRlICAgICAgIDogYW4udXBkYXRlKG9wdGlvbnMsIGlucHV0KVxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcbiAgICAvL2Rlc3Ryb3kgICAgICA6IGFuLmRlc3Ryb3koaW5wdXQpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;